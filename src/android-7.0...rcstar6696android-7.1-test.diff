diff --git a/arch/arm/Kconfig b/arch/arm/Kconfig
index 3523174..65ea6eb 100644
--- a/arch/arm/Kconfig
+++ b/arch/arm/Kconfig
@@ -1649,6 +1649,7 @@ config HZ
 	int
 	default 200 if ARCH_EBSA110 || ARCH_S3C24XX || ARCH_S5P64X0 || \
 		ARCH_S5PV210 || ARCH_EXYNOS4
+	default 300 if ARCH_MSM8974
 	default AT91_TIMER_HZ if ARCH_AT91
 	default SHMOBILE_TIMER_HZ if ARCH_SHMOBILE
 	default 100
diff --git a/arch/arm/boot/dts/qcom/msm8974.dtsi b/arch/arm/boot/dts/qcom/msm8974.dtsi
index 6fda476..78c9cfb 100644
--- a/arch/arm/boot/dts/qcom/msm8974.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8974.dtsi
@@ -1727,6 +1727,7 @@
 			 <&clock_krait clk_krait2_clk>,
 			 <&clock_krait clk_krait3_clk>;
 		qcom,cpufreq-table =
+			<  268800 >,
 			<  300000 >,
 			<  422400 >,
 			<  652800 >,
@@ -1741,7 +1742,12 @@
 			< 1728000 >,
 			< 1958400 >,
 			< 2265600 >,
-			< 2457600 >;
+			< 2342400 >,
+			< 2457600 >,
+			< 2572800 >,
+			< 2649600 >,
+			< 2726400 >,
+			< 2803200 >;
 	};
 
 	usb3: ssusb@f9200000 {
diff --git a/arch/arm/boot/dts/qcom/msm8974pro-ab-shinano_common.dtsi b/arch/arm/boot/dts/qcom/msm8974pro-ab-shinano_common.dtsi
index 918383e..1feabfa 100644
--- a/arch/arm/boot/dts/qcom/msm8974pro-ab-shinano_common.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8974pro-ab-shinano_common.dtsi
@@ -117,8 +117,17 @@
 
 	/* I2C : BLSP6 */
 	i2c@f9928000 {
+		cell-index = <3>;
+		compatible = "qcom,i2c-qup";
+		reg = <0xf9928000 0x1000>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		reg-names = "qup_phys_addr";
+		interrupts = <0 100 0>;
+		interrupt-names = "qup_err_intr";
 		qcom,i2c-bus-freq = <355000>;
 		qcom,i2c-src-freq = <50000000>;
+		qcom,master-id = <86>;
 		status = "ok";
 
 		nfc@28 {
diff --git a/arch/arm/boot/dts/qcom/msm8974pro-pm8941.dtsi b/arch/arm/boot/dts/qcom/msm8974pro-pm8941.dtsi
index c491743..3903b76 100644
--- a/arch/arm/boot/dts/qcom/msm8974pro-pm8941.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8974pro-pm8941.dtsi
@@ -38,22 +38,22 @@
 };
 
 &krait0_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1275000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait1_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1275000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait2_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1275000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
 &krait3_vreg {
-		regulator-max-microvolt = <1120000>;
+		regulator-max-microvolt = <1275000>;
 		qcom,ldo-delta-voltage = <12500>;
 };
 
diff --git a/arch/arm/boot/dts/qcom/msm8974pro-pma8084-regulator.dtsi b/arch/arm/boot/dts/qcom/msm8974pro-pma8084-regulator.dtsi
index 90b2d72..c222cdc 100644
--- a/arch/arm/boot/dts/qcom/msm8974pro-pma8084-regulator.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8974pro-pma8084-regulator.dtsi
@@ -504,9 +504,9 @@
 				<0xf908a800 0x1000>; /* APCS_ALIAS0_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1275000>;
 			qcom,headroom-voltage = <150000>;
-			qcom,retention-voltage = <675000>;
+			qcom,retention-voltage = <600000>;
 			qcom,ldo-default-voltage = <750000>;
 			qcom,ldo-threshold-voltage = <850000>;
 			qcom,ldo-delta-voltage = <12500>;
@@ -524,9 +524,9 @@
 				<0xf909a800 0x1000>; /* APCS_ALIAS1_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1275000>;
 			qcom,headroom-voltage = <150000>;
-			qcom,retention-voltage = <675000>;
+			qcom,retention-voltage = <600000>;
 			qcom,ldo-default-voltage = <750000>;
 			qcom,ldo-threshold-voltage = <850000>;
 			qcom,ldo-delta-voltage = <12500>;
@@ -544,9 +544,9 @@
 				<0xf90aa800 0x1000>; /* APCS_ALIAS2_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1275000>;
 			qcom,headroom-voltage = <150000>;
-			qcom,retention-voltage = <675000>;
+			qcom,retention-voltage = <600000>;
 			qcom,ldo-default-voltage = <750000>;
 			qcom,ldo-threshold-voltage = <850000>;
 			qcom,ldo-delta-voltage = <12500>;
@@ -564,9 +564,9 @@
 				<0xf90ba800 0x1000>; /* APCS_ALIAS3_KPSS_MDD */
 			reg-names = "acs", "mdd";
 			regulator-min-microvolt = <500000>;
-			regulator-max-microvolt = <1120000>;
+			regulator-max-microvolt = <1275000>;
 			qcom,headroom-voltage = <150000>;
-			qcom,retention-voltage = <675000>;
+			qcom,retention-voltage = <600000>;
 			qcom,ldo-default-voltage = <750000>;
 			qcom,ldo-threshold-voltage = <850000>;
 			qcom,ldo-delta-voltage = <12500>;
diff --git a/arch/arm/boot/dts/qcom/msm8974pro.dtsi b/arch/arm/boot/dts/qcom/msm8974pro.dtsi
index e97c106..b4b40f4a 100644
--- a/arch/arm/boot/dts/qcom/msm8974pro.dtsi
+++ b/arch/arm/boot/dts/qcom/msm8974pro.dtsi
@@ -116,9 +116,10 @@
 		/delete-property/ qcom,pmic-sw-mode-regs;
 	};
 
-	qcom,clock-krait@f9016000 {
+qcom,clock-krait@f9016000 {
 		qcom,speed1-pvs0-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   74 >,
 			<  345600000  775000   85 >,
 			<  422400000  775000  104 >,
@@ -150,6 +151,7 @@
 
 		qcom,speed1-pvs1-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   74 >,
 			<  345600000  775000   85 >,
 			<  422400000  775000  104 >,
@@ -181,6 +183,7 @@
 
 		qcom,speed1-pvs2-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   74 >,
 			<  345600000  750000   85 >,
 			<  422400000  750000  104 >,
@@ -212,6 +215,7 @@
 
 		qcom,speed1-pvs3-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   74 >,
 			<  345600000  750000   85 >,
 			<  422400000  750000  104 >,
@@ -243,6 +247,7 @@
 
 		qcom,speed1-pvs4-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   74 >,
 			<  345600000  750000   85 >,
 			<  422400000  750000  104 >,
@@ -274,6 +279,7 @@
 
 		qcom,speed1-pvs5-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  720000   68 >,
 			<  300000000  725000   74 >,
 			<  345600000  725000   85 >,
 			<  422400000  725000  104 >,
@@ -305,6 +311,7 @@
 
 		qcom,speed1-pvs6-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  720000   68 >,
 			<  300000000  725000   74 >,
 			<  345600000  725000   85 >,
 			<  422400000  725000  104 >,
@@ -336,6 +343,7 @@
 
 		qcom,speed3-pvs0-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -370,6 +378,7 @@
 
 		qcom,speed3-pvs1-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -404,6 +413,7 @@
 
 		qcom,speed3-pvs2-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -438,6 +448,7 @@
 
 		qcom,speed3-pvs3-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -472,6 +483,7 @@
 
 		qcom,speed3-pvs4-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -506,6 +518,7 @@
 
 		qcom,speed3-pvs5-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  106 >,
@@ -540,6 +553,7 @@
 
 		qcom,speed3-pvs6-bin-v0 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  106 >,
@@ -574,6 +588,7 @@
 
 		qcom,speed1-pvs0-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  810000   87 >,
 			<  422400000  820000  108 >,
@@ -601,10 +616,16 @@
 			< 2112000000 1090000  669 >,
 			< 2150400000 1105000  703 >,
 			< 2188800000 1105000  703 >,
-			< 2265600000 1120000  738 >;
+			< 2265600000 1120000  738 >,
+			/* overclocking */
+			< 2419200000 1150000  778 >,
+			< 2572800000 1180000  847 >,
+			< 2726400000 1210000  920 >,
+			< 2803200000 1240000  957 >;
 
 		qcom,speed1-pvs1-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  810000  108 >,
@@ -632,10 +653,16 @@
 			< 2112000000 1080000  669 >,
 			< 2150400000 1095000  703 >,
 			< 2188800000 1095000  703 >,
-			< 2265600000 1110000  738 >;
+			< 2265600000 1110000  738 >,
+			/* overclocking */
+			< 2419200000 1140000  778 >,
+			< 2572800000 1170000  847 >,
+			< 2726400000 1200000  920 >,
+			< 2803200000 1230000  957 >;
 
 		qcom,speed1-pvs2-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  108 >,
@@ -663,10 +690,16 @@
 			< 2112000000 1070000  669 >,
 			< 2150400000 1085000  703 >,
 			< 2188800000 1085000  703 >,
-			< 2265600000 1100000  738 >;
+			< 2265600000 1100000  738 >,
+			/* overclocking */
+			< 2419200000 1130000  778 >,
+			< 2572800000 1160000  847 >,
+			< 2726400000 1190000  920 >,
+			< 2803200000 1220000  957 >;
 
 		qcom,speed1-pvs3-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  108 >,
@@ -694,10 +727,16 @@
 			< 2112000000 1060000  669 >,
 			< 2150400000 1075000  703 >,
 			< 2188800000 1075000  703 >,
-			< 2265600000 1090000  738 >;
+			< 2265600000 1090000  738 >,
+			/* overclocking */
+			< 2419200000 1120000  778 >,
+			< 2572800000 1150000  847 >,
+			< 2726400000 1180000  920 >,
+			< 2803200000 1210000  957 >;
 
 		qcom,speed1-pvs4-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  108 >,
@@ -725,10 +764,16 @@
 			< 2112000000 1050000  669 >,
 			< 2150400000 1065000  703 >,
 			< 2188800000 1065000  703 >,
-			< 2265600000 1080000  738 >;
+			< 2265600000 1080000  738 >,
+			/* overclocking */
+			< 2419200000 1110000  778 >,
+			< 2572800000 1140000  847 >,
+			< 2726400000 1170000  920 >,
+			< 2803200000 1200000  957 >;
 
 		qcom,speed1-pvs5-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  108 >,
@@ -756,10 +801,16 @@
 			< 2112000000 1040000  669 >,
 			< 2150400000 1055000  703 >,
 			< 2188800000 1055000  703 >,
-			< 2265600000 1070000  738 >;
+			< 2265600000 1070000  738 >,
+			/* overclocking */
+			< 2419200000 1100000  778 >,
+			< 2572800000 1130000  847 >,
+			< 2726400000 1160000  920 >,
+			< 2803200000 1190000  957 >;
 
 		qcom,speed1-pvs6-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -787,10 +838,16 @@
 			< 2112000000 1030000  669 >,
 			< 2150400000 1045000  703 >,
 			< 2188800000 1045000  703 >,
-			< 2265600000 1060000  738 >;
+			< 2265600000 1060000  738 >,
+			/* overclocking */
+			< 2419200000 1090000  778 >,
+			< 2572800000 1120000  847 >,
+			< 2726400000 1150000  920 >,
+			< 2803200000 1180000  957 >;
 
 		qcom,speed1-pvs7-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -818,10 +875,16 @@
 			< 2112000000 1020000  669 >,
 			< 2150400000 1035000  703 >,
 			< 2188800000 1035000  703 >,
-			< 2265600000 1050000  738 >;
+			< 2265600000 1050000  738 >,
+			/* overclocking */
+			< 2419200000 1080000  778 >,
+			< 2572800000 1110000  847 >,
+			< 2726400000 1140000  920 >,
+			< 2803200000 1170000  957 >;
 
 		qcom,speed1-pvs8-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -849,10 +912,16 @@
 			< 2112000000 1010000  669 >,
 			< 2150400000 1025000  703 >,
 			< 2188800000 1025000  703 >,
-			< 2265600000 1040000  738 >;
+			< 2265600000 1040000  738 >,
+			/* overclocking */
+			< 2419200000 1070000  778 >,
+			< 2572800000 1100000  847 >,
+			< 2726400000 1130000  920 >,
+			< 2803200000 1160000  957 >;
 
 		qcom,speed1-pvs9-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -880,10 +949,16 @@
 			< 2112000000 1000000  669 >,
 			< 2150400000 1015000  703 >,
 			< 2188800000 1015000  703 >,
-			< 2265600000 1030000  738 >;
+			< 2265600000 1030000  738 >,
+			/* overclocking */
+			< 2419200000 1060000  778 >,
+			< 2572800000 1090000  847 >,
+			< 2726400000 1120000  920 >,
+			< 2803200000 1150000  957 >;
 
 		qcom,speed1-pvs10-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -911,10 +986,16 @@
 			< 2112000000  990000  669 >,
 			< 2150400000 1005000  703 >,
 			< 2188800000 1005000  703 >,
-			< 2265600000 1020000  738 >;
+			< 2265600000 1020000  738 >,
+			/* overclocking */
+			< 2419200000 1050000  778 >,
+			< 2572800000 1080000  847 >,
+			< 2726400000 1110000  920 >,
+			< 2803200000 1140000  957 >;
 
 		qcom,speed1-pvs11-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -942,10 +1023,16 @@
 			< 2112000000  980000  669 >,
 			< 2150400000  995000  703 >,
 			< 2188800000  995000  703 >,
-			< 2265600000 1010000  738 >;
+			< 2265600000 1010000  738 >,
+			/* overclocking */
+			< 2419200000 1040000  778 >,
+			< 2572800000 1070000  847 >,
+			< 2726400000 1100000  920 >,
+			< 2803200000 1130000  957 >;
 
 		qcom,speed1-pvs12-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -973,10 +1060,16 @@
 			< 2112000000  970000  669 >,
 			< 2150400000  985000  703 >,
 			< 2188800000  985000  703 >,
-			< 2265600000 1000000  738 >;
+			< 2265600000 1000000  738 >,
+			/* overclocking */
+			< 2419200000 1030000  778 >,
+			< 2572800000 1060000  847 >,
+			< 2726400000 1090000  920 >,
+			< 2803200000 1120000  957 >;
 
 		qcom,speed1-pvs13-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  108 >,
@@ -1004,10 +1097,16 @@
 			< 2112000000  960000  669 >,
 			< 2150400000  975000  703 >,
 			< 2188800000  975000  703 >,
-			< 2265600000  990000  738 >;
+			< 2265600000  990000  738 >,
+			/* overclocking */
+			< 2419200000 1020000  778 >,
+			< 2572800000 1050000  847 >,
+			< 2726400000 1080000  920 >,
+			< 2803200000 1110000  957 >;
 
 		qcom,speed1-pvs14-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  108 >,
@@ -1035,10 +1134,16 @@
 			< 2112000000  950000  669 >,
 			< 2150400000  965000  703 >,
 			< 2188800000  965000  703 >,
-			< 2265600000  980000  738 >;
+			< 2265600000  980000  738 >,
+			/* overclocking */
+			< 2419200000 1010000  778 >,
+			< 2572800000 1040000  847 >,
+			< 2726400000 1070000  920 >,
+			< 2803200000 1100000  957 >;
 
 		qcom,speed1-pvs15-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  108 >,
@@ -1066,10 +1171,16 @@
 			< 2112000000  940000  669 >,
 			< 2150400000  955000  703 >,
 			< 2188800000  955000  703 >,
-			< 2265600000  970000  738 >;
+			< 2265600000  970000  738 >,
+			/* overclocking */
+			< 2419200000 1000000  778 >,
+			< 2572800000 1030000  847 >,
+			< 2726400000 1060000  920 >,
+			< 2803200000 1090000  957 >;
 
 		qcom,speed3-pvs0-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1100,10 +1211,15 @@
 			< 2265600000 1085000  716 >,
 			< 2342400000 1100000  751 >,
 			< 2419200000 1115000  786 >,
-			< 2457600000 1120000  802 >;
+			< 2457600000 1120000  812 >,
+			< 2572800000 1135000  851 >,
+			< 2649600000 1150000  886 >,
+			< 2726400000 1165000  920 >,
+			< 2803200000 1180000  957 >;
 
 		qcom,speed3-pvs1-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1132,12 +1248,18 @@
 			< 2150400000 1060000  682 >,
 			< 2188800000 1060000  682 >,
 			< 2265600000 1075000  716 >,
+				/* overclocking */
 			< 2342400000 1090000  751 >,
 			< 2419200000 1105000  786 >,
-			< 2457600000 1110000  802 >;
+			< 2457600000 1110000  812 >,
+			< 2572800000 1125000  851 >,
+			< 2649600000 1140000  886 >,
+			< 2726400000 1155000  920 >,
+			< 2803200000 1170000  957 >;
 
 		qcom,speed3-pvs2-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1166,12 +1288,18 @@
 			< 2150400000 1050000  682 >,
 			< 2188800000 1050000  682 >,
 			< 2265600000 1065000  716 >,
+				/* overclocking */
 			< 2342400000 1080000  751 >,
 			< 2419200000 1095000  786 >,
-			< 2457600000 1100000  802 >;
+			< 2457600000 1100000  812 >,
+			< 2572800000 1115000  851 >,
+			< 2649600000 1130000  886 >,
+			< 2726400000 1145000  920 >,
+			< 2803200000 1160000  957 >;
 
 		qcom,speed3-pvs3-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1200,12 +1328,18 @@
 			< 2150400000 1040000  682 >,
 			< 2188800000 1040000  682 >,
 			< 2265600000 1055000  716 >,
+				/* overclocking */
 			< 2342400000 1070000  751 >,
 			< 2419200000 1085000  786 >,
-			< 2457600000 1090000  802 >;
+			< 2457600000 1090000  812 >,
+			< 2572800000 1105000  851 >,
+			< 2649600000 1120000  886 >,
+			< 2726400000 1135000  920 >,
+			< 2803200000 1150000  957 >;
 
 		qcom,speed3-pvs4-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1234,12 +1368,18 @@
 			< 2150400000 1030000  682 >,
 			< 2188800000 1030000  682 >,
 			< 2265600000 1045000  716 >,
+				/* overclocking */
 			< 2342400000 1060000  751 >,
 			< 2419200000 1075000  786 >,
-			< 2457600000 1080000  802 >;
+			< 2457600000 1080000  812 >,
+			< 2572800000 1095000  851 >,
+			< 2649600000 1110000  886 >,
+			< 2726400000 1125000  920 >,
+			< 2803200000 1140000  957 >;
 
 		qcom,speed3-pvs5-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  795000   68 >,
 			<  300000000  800000   76 >,
 			<  345600000  800000   87 >,
 			<  422400000  800000  106 >,
@@ -1268,12 +1408,18 @@
 			< 2150400000 1020000  682 >,
 			< 2188800000 1020000  682 >,
 			< 2265600000 1035000  716 >,
+				/* overclocking */
 			< 2342400000 1050000  751 >,
 			< 2419200000 1065000  786 >,
-			< 2457600000 1070000  802 >;
+			< 2457600000 1070000  812 >,
+			< 2572800000 1085000  851 >,
+			< 2649600000 1100000  886 >,
+			< 2726400000 1115000  920 >,
+			< 2803200000 1130000  957 >;
 
 		qcom,speed3-pvs6-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1302,12 +1448,18 @@
 			< 2150400000 1010000  682 >,
 			< 2188800000 1010000  682 >,
 			< 2265600000 1025000  716 >,
+				/* overclocking */
 			< 2342400000 1040000  751 >,
 			< 2419200000 1055000  786 >,
-			< 2457600000 1060000  802 >;
+			< 2457600000 1060000  812 >,
+			< 2572800000 1075000  851 >,
+			< 2649600000 1090000  886 >,
+			< 2726400000 1105000  920 >,
+			< 2803200000 1120000  957 >;
 
 		qcom,speed3-pvs7-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1336,12 +1488,18 @@
 			< 2150400000 1000000  682 >,
 			< 2188800000 1000000  682 >,
 			< 2265600000 1015000  716 >,
+				/* overclocking */
 			< 2342400000 1030000  751 >,
 			< 2419200000 1045000  786 >,
-			< 2457600000 1050000  802 >;
+			< 2457600000 1050000  812 >,
+			< 2572800000 1065000  851 >,
+			< 2649600000 1080000  886 >,
+			< 2726400000 1095000  920 >,
+			< 2803200000 1110000  957 >;
 
 		qcom,speed3-pvs8-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1370,12 +1528,18 @@
 			< 2150400000  990000  682 >,
 			< 2188800000  990000  682 >,
 			< 2265600000 1005000  716 >,
+				/* overclocking */
 			< 2342400000 1020000  751 >,
 			< 2419200000 1035000  786 >,
-			< 2457600000 1040000  802 >;
+			< 2457600000 1040000  812 >,
+			< 2572800000 1055000  851 >,
+			< 2649600000 1070000  886 >,
+			< 2726400000 1085000  920 >,
+			< 2803200000 1100000  957 >;
 
 		qcom,speed3-pvs9-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1404,12 +1568,18 @@
 			< 2150400000  980000  682 >,
 			< 2188800000  980000  682 >,
 			< 2265600000  995000  716 >,
+				/* overclocking */
 			< 2342400000 1010000  751 >,
 			< 2419200000 1025000  786 >,
-			< 2457600000 1030000  802 >;
+			< 2457600000 1030000  812 >,
+			< 2572800000 1045000  851 >,
+			< 2649600000 1060000  886 >,
+			< 2726400000 1075000  920 >,
+			< 2803200000 1090000  957 >;
 
 		qcom,speed3-pvs10-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1438,12 +1608,18 @@
 			< 2150400000  970000  682 >,
 			< 2188800000  970000  682 >,
 			< 2265600000  985000  716 >,
+				/* overclocking */
 			< 2342400000 1000000  751 >,
 			< 2419200000 1015000  786 >,
-			< 2457600000 1020000  802 >;
+			< 2457600000 1020000  812 >,
+			< 2572800000 1035000  851 >,
+			< 2649600000 1050000  886 >,
+			< 2726400000 1065000  920 >,
+			< 2803200000 1080000  957 >;
 
 		qcom,speed3-pvs11-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1472,12 +1648,18 @@
 			< 2150400000  960000  682 >,
 			< 2188800000  960000  682 >,
 			< 2265600000  975000  716 >,
+				/* overclocking */
 			< 2342400000  990000  751 >,
 			< 2419200000 1005000  786 >,
-			< 2457600000 1010000  802 >;
+			< 2457600000 1010000  812 >,
+			< 2572800000 1025000  851 >,
+			< 2649600000 1040000  886 >,
+			< 2726400000 1055000  920 >,
+			< 2803200000 1070000  957 >;
 
 		qcom,speed3-pvs12-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1506,12 +1688,18 @@
 			< 2150400000  950000  682 >,
 			< 2188800000  950000  682 >,
 			< 2265600000  965000  716 >,
+				/* overclocking */
 			< 2342400000  980000  751 >,
 			< 2419200000  995000  786 >,
-			< 2457600000 1000000  802 >;
+			< 2457600000 1000000  812 >,
+			< 2572800000 1015000  851 >,
+			< 2649600000 1030000  886 >,
+			< 2726400000 1045000  920 >,
+			< 2803200000 1060000  957 >;
 
 		qcom,speed3-pvs13-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  770000   68 >,
 			<  300000000  775000   76 >,
 			<  345600000  775000   87 >,
 			<  422400000  775000  106 >,
@@ -1540,12 +1728,18 @@
 			< 2150400000  940000  682 >,
 			< 2188800000  940000  682 >,
 			< 2265600000  955000  716 >,
+				/* overclocking */
 			< 2342400000  970000  751 >,
 			< 2419200000  985000  786 >,
-			< 2457600000  990000  802 >;
+			< 2457600000  990000  812 >,
+			< 2572800000 1005000  851 >,
+			< 2649600000 1020000  886 >,
+			< 2726400000 1035000  920 >,
+			< 2803200000 1050000  957 >;
 
 		qcom,speed3-pvs14-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  106 >,
@@ -1574,12 +1768,18 @@
 			< 2150400000  930000  682 >,
 			< 2188800000  930000  682 >,
 			< 2265600000  945000  716 >,
+				/* overclocking */
 			< 2342400000  960000  751 >,
 			< 2419200000  975000  786 >,
-			< 2457600000  980000  802 >;
+			< 2457600000  980000  812 >,
+			< 2572800000  995000  851 >,
+			< 2649600000 1010000  886 >,
+			< 2726400000 1025000  920 >,
+			< 2803200000 1040000  957 >;
 
 		qcom,speed3-pvs15-bin-v1 =
 			<          0       0    0 >,
+			<  268800000  745000   68 >,
 			<  300000000  750000   76 >,
 			<  345600000  750000   87 >,
 			<  422400000  750000  106 >,
@@ -1608,9 +1808,14 @@
 			< 2150400000  920000  682 >,
 			< 2188800000  920000  682 >,
 			< 2265600000  935000  716 >,
+				/* overclocking */
 			< 2342400000  950000  751 >,
 			< 2419200000  965000  786 >,
-			< 2457600000  970000  802 >;
+			< 2457600000  970000  812 >,
+			< 2572800000  985000  851 >,
+			< 2649600000 1000000  886 >,
+			< 2726400000 1015000  920 >,
+			< 2803200000 1030000  957 >;
 	};
 
 	sound {
@@ -1667,7 +1872,7 @@
 	qcom,chipid = <0x03030002>;
 	qcom,msm-bus,num-cases = <14>;
 	qcom,bus-control;
-	qcom,initial-pwrlevel = <3>;
+	qcom,initial-pwrlevel = <4>;
 
 	/* Updated bus bandwidth requirements */
 	qcom,msm-bus,vectors-KBps =
@@ -1700,7 +1905,7 @@
 		/* Turbo / Turbo */
 		<26 512 0 7464000>, <89 604 0 9248000>;
 
-       qcom,gpu-pwrlevels {
+	qcom,gpu-pwrlevels {
                #address-cells = <1>;
                #size-cells = <0>;
 
@@ -1708,38 +1913,51 @@
 
                qcom,gpu-pwrlevel@0 {
                        reg = <0>;
-                       qcom,gpu-freq = <578000000>;
-                       qcom,bus-freq = <13>;
+                       qcom,gpu-freq = <657500000>;
+                       qcom,bus-freq = <14>;
+                       qcom,io-fraction = <101>;
                };
 
                qcom,gpu-pwrlevel@1 {
                        reg = <1>;
-                       qcom,gpu-freq = <462400000>;
-                       qcom,bus-freq = <10>;
+                       qcom,gpu-freq = <578000000>;
+                       qcom,bus-freq = <14>;
+                       qcom,io-fraction = <101>;
                };
 
                qcom,gpu-pwrlevel@2 {
                        reg = <2>;
-                       qcom,gpu-freq = <389000000>;
-                       qcom,bus-freq = <7>;
+                       qcom,gpu-freq = <462400000>;
+                       qcom,bus-freq = <11>;
+                       qcom,io-fraction = <101>;
                };
 
                qcom,gpu-pwrlevel@3 {
                        reg = <3>;
-                       qcom,gpu-freq = <330000000>;
-                       qcom,bus-freq = <4>;
+                       qcom,gpu-freq = <389000000>;
+                       qcom,bus-freq = <8>;
+                       qcom,io-fraction = <101>;
                };
 
                qcom,gpu-pwrlevel@4 {
                        reg = <4>;
-                       qcom,gpu-freq = <200000000>;
-                       qcom,bus-freq = <1>;
+                       qcom,gpu-freq = <330000000>;
+                       qcom,bus-freq = <5>;
+                       qcom,io-fraction = <101>;
                };
 
                qcom,gpu-pwrlevel@5 {
                        reg = <5>;
-                       qcom,gpu-freq = <27000000>;
-                       qcom,bus-freq = <0>;
+                       qcom,gpu-freq = <200000000>;
+                       qcom,bus-freq = <2>;
+                       qcom,io-fraction = <101>;
+               };
+
+               qcom,gpu-pwrlevel@6 {
+                       reg = <6>;
+                       qcom,gpu-freq = <150000000>;
+                       qcom,bus-freq = <1>;
+                       qcom,io-fraction = <101>;
                };
        };
 };
diff --git a/arch/arm/configs/aosp_shinano_castor_defconfig b/arch/arm/configs/aosp_shinano_castor_defconfig
index e3c8c75..c5d7ebf 100644
--- a/arch/arm/configs/aosp_shinano_castor_defconfig
+++ b/arch/arm/configs/aosp_shinano_castor_defconfig
@@ -33,6 +33,7 @@ CONFIG_PARTITION_ADVANCED=y
 # CONFIG_IOSCHED_TEST is not set
 # CONFIG_IOSCHED_DEADLINE is not set
 # CONFIG_IOSCHED_ROW is not set
+CONFIG_IOSCHED_ZEN=y
 CONFIG_ARCH_MSM=y
 CONFIG_ARCH_MSM8974=y
 CONFIG_MACH_SONY_CASTOR=y
@@ -56,10 +57,16 @@ CONFIG_ENABLE_VMALLOC_SAVING=y
 CONFIG_SECCOMP=y
 CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE=y
 CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_ZZMOOVE=y
 CONFIG_CPU_BOOST=y
 CONFIG_CPU_IDLE=y
+CONFIG_POWERSUSPEND=y
+CONFIG_DEVFREQ_GOV_MSM_ADRENO_TZ=y
+CONFIG_ADRENO_IDLER=y
 # CONFIG_CPU_IDLE_GOV_LADDER is not set
 # CONFIG_CPU_IDLE_GOV_MENU is not set
 CONFIG_VFP=y
@@ -645,3 +652,5 @@ CONFIG_ASYMMETRIC_KEY_TYPE=y
 CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
 CONFIG_PUBLIC_KEY_ALGO_RSA=y
 CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+CONFIG_QUICK_WAKEUP=y
diff --git a/arch/arm/configs/aosp_shinano_scorpion_defconfig b/arch/arm/configs/aosp_shinano_scorpion_defconfig
index 68eccc7..32b9663 100644
--- a/arch/arm/configs/aosp_shinano_scorpion_defconfig
+++ b/arch/arm/configs/aosp_shinano_scorpion_defconfig
@@ -33,6 +33,7 @@ CONFIG_PARTITION_ADVANCED=y
 # CONFIG_IOSCHED_TEST is not set
 # CONFIG_IOSCHED_DEADLINE is not set
 # CONFIG_IOSCHED_ROW is not set
+CONFIG_IOSCHED_ZEN=y
 CONFIG_ARCH_MSM=y
 CONFIG_ARCH_MSM8974=y
 CONFIG_MACH_SONY_SCORPION=y
@@ -58,8 +59,13 @@ CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE=y
 CONFIG_CPU_FREQ=y
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_ZZMOOVE=y
 CONFIG_CPU_BOOST=y
 CONFIG_CPU_IDLE=y
+# Powersuspend and adreno idler
+CONFIG_POWERSUSPEND=y
+CONFIG_DEVFREQ_GOV_MSM_ADRENO_TZ=y
+CONFIG_ADRENO_IDLER=y
 # CONFIG_CPU_IDLE_GOV_LADDER is not set
 # CONFIG_CPU_IDLE_GOV_MENU is not set
 CONFIG_VFP=y
diff --git a/arch/arm/configs/aosp_shinano_sirius_defconfig b/arch/arm/configs/aosp_shinano_sirius_defconfig
index 6b824e4..732d339 100644
--- a/arch/arm/configs/aosp_shinano_sirius_defconfig
+++ b/arch/arm/configs/aosp_shinano_sirius_defconfig
@@ -56,10 +56,16 @@ CONFIG_ENABLE_VMALLOC_SAVING=y
 CONFIG_SECCOMP=y
 CONFIG_BUILD_ARM_APPENDED_DTB_IMAGE=y
 CONFIG_CPU_FREQ=y
+CONFIG_CPU_FREQ_GOV_PERFORMANCE=y
+CONFIG_CPU_FREQ_GOV_ONDEMAND=y
 CONFIG_CPU_FREQ_GOV_POWERSAVE=y
 CONFIG_CPU_FREQ_GOV_INTERACTIVE=y
+CONFIG_CPU_FREQ_GOV_ZZMOOVE=y
 CONFIG_CPU_BOOST=y
 CONFIG_CPU_IDLE=y
+CONFIG_POWERSUSPEND=y
+CONFIG_DEVFREQ_GOV_MSM_ADRENO_TZ=y
+CONFIG_ADRENO_IDLER=y
 # CONFIG_CPU_IDLE_GOV_LADDER is not set
 # CONFIG_CPU_IDLE_GOV_MENU is not set
 CONFIG_VFP=y
@@ -639,3 +645,5 @@ CONFIG_ASYMMETRIC_KEY_TYPE=y
 CONFIG_ASYMMETRIC_PUBLIC_KEY_SUBTYPE=y
 CONFIG_PUBLIC_KEY_ALGO_RSA=y
 CONFIG_X509_CERTIFICATE_PARSER=y
+CONFIG_SOUND_CONTROL_HAX_3_GPL=y
+CONFIG_QUICK_WAKEUP=y
diff --git a/arch/arm/kernel/irq.c b/arch/arm/kernel/irq.c
index 8d3bda9..7f87cdb 100644
--- a/arch/arm/kernel/irq.c
+++ b/arch/arm/kernel/irq.c
@@ -183,7 +183,7 @@ void migrate_irqs(void)
 		raw_spin_unlock(&desc->lock);
 
 		if (affinity_broken && printk_ratelimit())
-			pr_warning("IRQ%u no longer affine to CPU%u\n", i,
+			pr_debug("IRQ%u no longer affine to CPU%u\n", i,
 				smp_processor_id());
 	}
 
diff --git a/arch/arm64/configs/aosp_kanuti_tulip_defconfig b/arch/arm64/configs/aosp_kanuti_tulip_defconfig
index e1b49487..fee2f38 100644
--- a/arch/arm64/configs/aosp_kanuti_tulip_defconfig
+++ b/arch/arm64/configs/aosp_kanuti_tulip_defconfig
@@ -199,6 +199,8 @@ CONFIG_BT_HIDP=y
 CONFIG_CFG80211=y
 CONFIG_CFG80211_INTERNAL_REGDB=y
 CONFIG_RFKILL=y
+CONFIG_NFC_PN547=y
+CONFIG_NFC_PN547_PMC_CLK_REQ=y
 CONFIG_IPC_ROUTER=y
 CONFIG_IPC_ROUTER_SECURITY=y
 CONFIG_DEVTMPFS=y
diff --git a/block/Kconfig.iosched b/block/Kconfig.iosched
index e35a11526..2f6b297 100644
--- a/block/Kconfig.iosched
+++ b/block/Kconfig.iosched
@@ -43,6 +43,13 @@ config IOSCHED_ROW
 	  according to queue priority.
 	  Most suitable for mobile devices.
 
+config IOSCHED_ZEN
+	tristate "Zen I/O scheduler"
+	default y
+	---help---
+	FCFS, dispatches are back-inserted, deadlines ensure fairness.
+        Should work best with devices where there is no travel delay.
+
 config IOSCHED_CFQ
 	tristate "CFQ I/O scheduler"
 	default y
@@ -95,6 +102,7 @@ config DEFAULT_IOSCHED
 	default "row" if DEFAULT_ROW
 	default "cfq" if DEFAULT_CFQ
 	default "noop" if DEFAULT_NOOP
+	default "zen" if DEFAULT_ZEN
 
 endmenu
 
diff --git a/block/Makefile b/block/Makefile
index b5e6637..97fe23f 100644
--- a/block/Makefile
+++ b/block/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_IOSCHED_NOOP)	+= noop-iosched.o
 obj-$(CONFIG_IOSCHED_DEADLINE)	+= deadline-iosched.o
 obj-$(CONFIG_IOSCHED_ROW)	+= row-iosched.o
 obj-$(CONFIG_IOSCHED_CFQ)	+= cfq-iosched.o
+obj-$(CONFIG_IOSCHED_ZEN)       += zen-iosched.o
 obj-$(CONFIG_IOSCHED_TEST)	+= test-iosched.o
 
 obj-$(CONFIG_BLOCK_COMPAT)	+= compat_ioctl.o
diff --git a/block/zen-iosched.c b/block/zen-iosched.c
new file mode 100644
index 0000000..7a97f01
--- /dev/null
+++ b/block/zen-iosched.c
@@ -0,0 +1,290 @@
+/*
+ * Zen IO scheduler
+ * Primarily based on Noop, deadline, and SIO IO schedulers.
+ *
+ * Copyright (C) 2012 Brandon Berhent <bbedward@gmail.com>
+ *           (C) 2014 LoungeKatt <twistedumbrella@gmail.com>
+ *           (C) 2015 Matthew Alex <matthewalex@outlook.com> (Fixes to stop crashing on 3.10)
+ * FCFS, dispatches are back-inserted, deadlines ensure fairness.
+ * Should work best with devices where there is no travel delay.
+ */
+#include <linux/blkdev.h>
+#include <linux/elevator.h>
+#include <linux/bio.h>
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/init.h>
+
+enum zen_data_dir { ASYNC, SYNC };
+
+static const int sync_expire  = HZ / 2;    /* max time before a sync is submitted. */
+static const int async_expire = 5 * HZ;    /* ditto for async, these limits are SOFT! */
+static const int fifo_batch = 16;
+
+struct zen_data {
+	/* Runtime Data */
+	/* Requests are only present on fifo_list */
+	struct list_head fifo_list[2];
+
+        unsigned int batching;          /* number of sequential requests made */
+
+	/* tunables */
+	int fifo_expire[2];
+	int fifo_batch;
+};
+
+static inline struct zen_data *
+zen_get_data(struct request_queue *q) {
+	return q->elevator->elevator_data;
+}
+
+static void zen_dispatch(struct zen_data *, struct request *);
+
+static void
+zen_merged_requests(struct request_queue *q, struct request *rq,
+                    struct request *next)
+{
+	/*
+	 * if next expires before rq, assign its expire time to arq
+	 * and move into next position (next will be deleted) in fifo
+	 */
+	if (!list_empty(&rq->queuelist) && !list_empty(&next->queuelist)) {
+		if (time_before(rq_fifo_time(next), rq_fifo_time(rq))) {
+			list_move(&rq->queuelist, &next->queuelist);
+			rq_set_fifo_time(rq, rq_fifo_time(next));
+		}
+	}
+
+	/* next request is gone */
+	rq_fifo_clear(next);
+}
+
+static void zen_add_request(struct request_queue *q, struct request *rq)
+{
+	struct zen_data *zdata = zen_get_data(q);
+	const int dir = rq_data_dir(rq);
+
+	if (zdata->fifo_expire[dir]) {
+		rq_set_fifo_time(rq, jiffies + zdata->fifo_expire[dir]);
+		list_add_tail(&rq->queuelist, &zdata->fifo_list[dir]);
+	}
+}
+
+static void zen_dispatch(struct zen_data *zdata, struct request *rq)
+{
+	/* Remove request from list and dispatch it */
+	rq_fifo_clear(rq);
+	elv_dispatch_add_tail(rq->q, rq);
+
+	/* Increment # of sequential requests */
+	zdata->batching++;
+}
+
+/*
+ * get the first expired request in direction ddir
+ */
+static struct request *
+zen_expired_request(struct zen_data *zdata, int ddir)
+{
+        struct request *rq;
+
+        if (list_empty(&zdata->fifo_list[ddir]))
+                return NULL;
+
+        rq = rq_entry_fifo(zdata->fifo_list[ddir].next);
+        if (time_after(jiffies, rq_fifo_time(rq)))
+                return rq;
+
+        return NULL;
+}
+
+/*
+ * zen_check_fifo returns 0 if there are no expired requests on the fifo,
+ * otherwise it returns the next expired request
+ */
+static struct request *
+zen_check_fifo(struct zen_data *zdata)
+{
+        struct request *rq_sync = zen_expired_request(zdata, SYNC);
+        struct request *rq_async = zen_expired_request(zdata, ASYNC);
+
+        if (rq_async && rq_sync) {
+        	if (time_after(rq_fifo_time(rq_async), rq_fifo_time(rq_sync)))
+                	return rq_sync;
+        } else if (rq_sync) {
+                return rq_sync;
+	} else if (rq_async) {
+		return rq_async;
+	}
+
+        return 0;
+}
+
+static struct request *
+zen_choose_request(struct zen_data *zdata)
+{
+        /*
+         * Retrieve request from available fifo list.
+         * Synchronous requests have priority over asynchronous.
+         */
+        if (!list_empty(&zdata->fifo_list[SYNC]))
+                return rq_entry_fifo(zdata->fifo_list[SYNC].next);
+        if (!list_empty(&zdata->fifo_list[ASYNC]))
+                return rq_entry_fifo(zdata->fifo_list[ASYNC].next);
+
+        return NULL;
+}
+
+static int zen_dispatch_requests(struct request_queue *q, int force)
+{
+	struct zen_data *zdata = zen_get_data(q);
+	struct request *rq = NULL;
+
+	/* Check for and issue expired requests */
+	if (zdata->batching > zdata->fifo_batch) {
+		zdata->batching = 0;
+		rq = zen_check_fifo(zdata);
+	}
+
+	if (!rq) {
+		rq = zen_choose_request(zdata);
+		if (!rq)
+			return 0;
+	}
+
+	zen_dispatch(zdata, rq);
+
+	return 1;
+}
+
+static int zen_init_queue(struct request_queue *q, struct elevator_type *e)
+{
+	struct zen_data *zdata;
+    struct elevator_queue *eq;
+    
+    eq = elevator_alloc(q, e);
+    if (!eq)
+        return -ENOMEM;
+
+	zdata = kmalloc_node(sizeof(*zdata), GFP_KERNEL, q->node);
+    if (!zdata) {
+        kobject_put(&eq->kobj);
+        return -ENOMEM;
+    }
+    eq->elevator_data = zdata;
+	
+ 
+    spin_lock_irq(q->queue_lock);
+	q->elevator = eq;
+	spin_unlock_irq(q->queue_lock);
+	
+	INIT_LIST_HEAD(&zdata->fifo_list[SYNC]);
+	INIT_LIST_HEAD(&zdata->fifo_list[ASYNC]);
+	zdata->fifo_expire[SYNC] = sync_expire;
+	zdata->fifo_expire[ASYNC] = async_expire;
+	zdata->fifo_batch = fifo_batch;
+	return 0;
+}
+
+static void zen_exit_queue(struct elevator_queue *e)
+{
+	struct zen_data *zdata = e->elevator_data;
+
+	BUG_ON(!list_empty(&zdata->fifo_list[SYNC]));
+	BUG_ON(!list_empty(&zdata->fifo_list[ASYNC]));
+	kfree(zdata);
+}
+
+/* Sysfs */
+static ssize_t
+zen_var_show(int var, char *page)
+{
+	return sprintf(page, "%d\n", var);
+}
+
+static ssize_t
+zen_var_store(int *var, const char *page, size_t count)
+{
+	*var = simple_strtol(page, NULL, 10);
+	return count;
+}
+
+#define SHOW_FUNCTION(__FUNC, __VAR, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, char *page) \
+{ \
+	struct zen_data *zdata = e->elevator_data; \
+	int __data = __VAR; \
+	if (__CONV) \
+		__data = jiffies_to_msecs(__data); \
+		return zen_var_show(__data, (page)); \
+}
+SHOW_FUNCTION(zen_sync_expire_show, zdata->fifo_expire[SYNC], 1);
+SHOW_FUNCTION(zen_async_expire_show, zdata->fifo_expire[ASYNC], 1);
+SHOW_FUNCTION(zen_fifo_batch_show, zdata->fifo_batch, 0);
+#undef SHOW_FUNCTION
+
+#define STORE_FUNCTION(__FUNC, __PTR, MIN, MAX, __CONV) \
+static ssize_t __FUNC(struct elevator_queue *e, const char *page, size_t count) \
+{ \
+	struct zen_data *zdata = e->elevator_data; \
+	int __data; \
+	int ret = zen_var_store(&__data, (page), count); \
+	if (__data < (MIN)) \
+		__data = (MIN); \
+	else if (__data > (MAX)) \
+		__data = (MAX); \
+	if (__CONV) \
+		*(__PTR) = msecs_to_jiffies(__data); \
+	else \
+		*(__PTR) = __data; \
+	return ret; \
+}
+STORE_FUNCTION(zen_sync_expire_store, &zdata->fifo_expire[SYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(zen_async_expire_store, &zdata->fifo_expire[ASYNC], 0, INT_MAX, 1);
+STORE_FUNCTION(zen_fifo_batch_store, &zdata->fifo_batch, 0, INT_MAX, 0);
+#undef STORE_FUNCTION
+
+#define DD_ATTR(name) \
+        __ATTR(name, S_IRUGO|S_IWUSR, zen_##name##_show, \
+                                      zen_##name##_store)
+
+static struct elv_fs_entry zen_attrs[] = {
+        DD_ATTR(sync_expire),
+        DD_ATTR(async_expire),
+        DD_ATTR(fifo_batch),
+        __ATTR_NULL
+};
+
+static struct elevator_type iosched_zen = {
+	.ops = {
+		.elevator_merge_req_fn		= zen_merged_requests,
+		.elevator_dispatch_fn		= zen_dispatch_requests,
+		.elevator_add_req_fn		= zen_add_request,
+		.elevator_former_req_fn         = elv_rb_former_request,
+		.elevator_latter_req_fn         = elv_rb_latter_request,
+		.elevator_init_fn		= zen_init_queue,
+		.elevator_exit_fn		= zen_exit_queue,
+	},
+	.elevator_attrs = zen_attrs,
+	.elevator_name = "zen",
+	.elevator_owner = THIS_MODULE,
+};
+
+static int __init zen_init(void)
+{
+	return elv_register(&iosched_zen);
+}
+
+static void __exit zen_exit(void)
+{
+	elv_unregister(&iosched_zen);
+}
+
+module_init(zen_init);
+module_exit(zen_exit);
+
+
+MODULE_AUTHOR("Brandon Berhent");
+MODULE_LICENSE("GPL");
+MODULE_DESCRIPTION("Zen IO scheduler");
+MODULE_VERSION("1.0");
diff --git a/drivers/clk/qcom/clock-krait-8974.c b/drivers/clk/qcom/clock-krait-8974.c
index 299a68c..394f556 100644
--- a/drivers/clk/qcom/clock-krait-8974.c
+++ b/drivers/clk/qcom/clock-krait-8974.c
@@ -984,6 +984,49 @@ static struct platform_driver clock_krait_8974_driver = {
 	},
 };
 
+ssize_t vc_get_vdd(char *buf)
+{
+        struct clk_vdd_class *vdd = krait0_clk.c.vdd_class;
+        int i, len = 0;
+        int levels = vdd->num_levels;
+
+        if (buf) {
+                for(i=1; i < levels; i++) {
+                        len += sprintf(buf + len, "%umhz: %d mV\n",
+                                (unsigned int)krait0_clk.c.fmax[i]/1000000,
+                                vdd->vdd_uv[i]/1000 );
+                }
+        }
+        return len;
+}
+void vc_set_vdd(const char *buf)
+{
+        struct clk_vdd_class *vdd0 = krait0_clk.c.vdd_class;
+        struct clk_vdd_class *vdd1 = krait1_clk.c.vdd_class;
+        struct clk_vdd_class *vdd2 = krait2_clk.c.vdd_class;
+        struct clk_vdd_class *vdd3 = krait3_clk.c.vdd_class;
+        int ret, i;
+        char size_cur[16];
+        unsigned int volt;
+        int levels = vdd0->num_levels;
+
+        for(i=1; i < levels; i++) {
+            ret = sscanf(buf, "%d", &volt);
+            pr_info("[imoseyon]: voltage for %lu changed to %d\n",
+                krait0_clk.c.fmax[i]/1000, volt*1000);
+            vdd0->vdd_uv[i] = min(max((unsigned int)volt*1000,
+                (unsigned int)500000), (unsigned int)1350000);
+            vdd1->vdd_uv[i] = min(max((unsigned int)volt*1000,
+                (unsigned int)500000), (unsigned int)1350000);
+            vdd2->vdd_uv[i] = min(max((unsigned int)volt*1000,
+                (unsigned int)500000), (unsigned int)1350000);
+            vdd3->vdd_uv[i] = min(max((unsigned int)volt*1000,
+                (unsigned int)500000), (unsigned int)1350000);
+            ret = sscanf(buf, "%s", size_cur);
+            buf += (strlen(size_cur)+1);
+        }
+}
+
 static int __init clock_krait_8974_init(void)
 {
 	return platform_driver_register(&clock_krait_8974_driver);
diff --git a/drivers/cpufreq/Kconfig b/drivers/cpufreq/Kconfig
index 29afa37..287d5a8 100644
--- a/drivers/cpufreq/Kconfig
+++ b/drivers/cpufreq/Kconfig
@@ -109,6 +109,15 @@ config CPU_FREQ_DEFAULT_GOV_CONSERVATIVE
 	  governor. If unsure have a look at the help section of the
 	  driver. Fallback governor will be the performance governor.
 
+config CPU_FREQ_DEFAULT_GOV_ZZMOOVE
+	  bool "zzmoove"
+	  select CPU_FREQ_GOV_ZZMOOVE
+	  select CPU_FREQ_GOV_PERFORMANCE
+	  help
+	  Use the CPUFreq governor 'zzmoove' as default, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+
 config CPU_FREQ_DEFAULT_GOV_INTERACTIVE
 	bool "interactive"
 	select CPU_FREQ_GOV_INTERACTIVE
@@ -216,6 +225,15 @@ config CPU_FREQ_GOV_CONSERVATIVE
 
 	  If in doubt, say N.
 
+config CPU_FREQ_GOV_ZZMOOVE
+	tristate "'zzmoove' cpufreq governor"
+	depends on CPU_FREQ
+	help
+	  'zzmoove' - based on cpufreq_conservative, using predefined
+	  frequency lookup tables and optimized scaling triggers instead of
+	  % frequency steps to get smooth up/downscaling dependant on CPU load.
+	  If in doubt, say N.
+
 config CPU_BOOST
 	tristate "Event base short term CPU freq boost"
 	depends on CPU_FREQ
diff --git a/drivers/cpufreq/Makefile b/drivers/cpufreq/Makefile
index df8d8a6..624eba3 100644
--- a/drivers/cpufreq/Makefile
+++ b/drivers/cpufreq/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_CPU_FREQ_GOV_POWERSAVE)	+= cpufreq_powersave.o
 obj-$(CONFIG_CPU_FREQ_GOV_USERSPACE)	+= cpufreq_userspace.o
 obj-$(CONFIG_CPU_FREQ_GOV_ONDEMAND)	+= cpufreq_ondemand.o
 obj-$(CONFIG_CPU_FREQ_GOV_CONSERVATIVE)	+= cpufreq_conservative.o
+obj-$(CONFIG_CPU_FREQ_GOV_ZZMOOVE)      += cpufreq_zzmoove.o
 obj-$(CONFIG_CPU_FREQ_GOV_INTERACTIVE)	+= cpufreq_interactive.o
 obj-$(CONFIG_CPU_FREQ_GOV_COMMON)		+= cpufreq_governor.o
 obj-$(CONFIG_CPU_BOOST)			+= cpu-boost.o
diff --git a/drivers/cpufreq/cpufreq.c b/drivers/cpufreq/cpufreq.c
index c01d18a..bc3cf7b0 100644
--- a/drivers/cpufreq/cpufreq.c
+++ b/drivers/cpufreq/cpufreq.c
@@ -633,6 +633,20 @@ static ssize_t show_bios_limit(struct cpufreq_policy *policy, char *buf)
 	return sprintf(buf, "%u\n", policy->cpuinfo.max_freq);
 }
 
+extern ssize_t vc_get_vdd(char *buf);
+extern void vc_set_vdd(const char *buf);
+
+static ssize_t show_UV_mV_table(struct cpufreq_policy *policy, char *buf)
+{
+       return vc_get_vdd(buf);
+}
+static ssize_t store_UV_mV_table
+(struct cpufreq_policy *policy, const char *buf, size_t count)
+{
+       vc_set_vdd(buf);
+       return count;
+}
+
 cpufreq_freq_attr_ro_perm(cpuinfo_cur_freq, 0400);
 cpufreq_freq_attr_ro(cpuinfo_min_freq);
 cpufreq_freq_attr_ro(cpuinfo_max_freq);
@@ -647,6 +661,7 @@ cpufreq_freq_attr_rw(scaling_min_freq);
 cpufreq_freq_attr_rw(scaling_max_freq);
 cpufreq_freq_attr_rw(scaling_governor);
 cpufreq_freq_attr_rw(scaling_setspeed);
+cpufreq_freq_attr_rw(UV_mV_table);
 
 static struct attribute *default_attrs[] = {
 	&cpuinfo_min_freq.attr,
@@ -660,6 +675,7 @@ static struct attribute *default_attrs[] = {
 	&scaling_driver.attr,
 	&scaling_available_governors.attr,
 	&scaling_setspeed.attr,
+	&UV_mV_table.attr,
 	NULL
 };
 
diff --git a/drivers/cpufreq/cpufreq_zzmoove.c b/drivers/cpufreq/cpufreq_zzmoove.c
new file mode 100644
index 0000000..7d6f20f
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_zzmoove.c
@@ -0,0 +1,9078 @@
+/*
+ *  drivers/cpufreq/cpufreq_zzmoove.c
+ *
+ *  Copyright (C)  2001 Russell King
+ *            (C)  2003 Venkatesh Pallipadi <venkatesh.pallipadi@intel.com>
+ *                      Jun Nakajima <jun.nakajima@intel.com>
+ *            (C)  2009 Alexander Clouter <alex@digriz.org.uk>
+ *            (C)  2012 Michael Weingaertner <mialwe@googlemail.com>
+ *                      Zane Zaminsky <cyxman@yahoo.com>
+ *                      Jean-Pierre Rasquin <yank555.lu@gmail.com>
+ *                      ffolkes <ffolkes@ffolkes.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * -------------------------------------------------------------------------------------------------------------------------------------------------------
+ * -  Description:																	 -
+ * -------------------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ * 'ZZMoove' governor is based on the modified 'conservative' (original author Alexander Clouter <alex@digriz.org.uk>) 'smoove' governor from Michael
+ * Weingaertner <mialwe@googlemail.com> (source: https://github.com/mialwe/mngb/) ported/modified/optimzed for I9300 since November 2012 and further
+ * improved for exynos and snapdragon platform (but also working on other platforms like OMAP) by ZaneZam,Yank555 and ffolkes in 2013/14/15
+ * CPU Hotplug modifications partially taken from ktoonservative governor from ktoonsez KT747-JB kernel (https://github.com/ktoonsez/KT747-JB)
+ *
+ * --------------------------------------------------------------------------------------------------------------------------------------------------------
+ * -																			  -
+ * --------------------------------------------------------------------------------------------------------------------------------------------------------
+ */
+
+// ZZ: disable kernel power management
+// #define DISABLE_POWER_MANAGEMENT
+
+// AP: use msm8974 lcd status notifier
+// #define USE_LCD_NOTIFIER
+
+#include <linux/cpu.h>
+#ifdef USE_LCD_NOTIFIER
+#include <linux/lcd_notify.h>
+#endif /* USE_LCD_NOTIFIER */
+#include <linux/cpufreq.h>
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)
+#include <linux/earlysuspend.h>
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+#include <linux/exynos4_export_temp.h>		// ZZ: Exynos4 temperatue reading support
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#include <linux/hrtimer.h>
+#include <linux/init.h>
+#include <linux/jiffies.h>
+#include <linux/kernel.h>
+#include <linux/kernel_stat.h>
+#include <linux/ktime.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#if defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)
+#include <linux/powersuspend.h>
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#include <linux/sched.h>
+#include <linux/tick.h>
+#include <linux/version.h>
+
+// #define ENABLE_SNAP_THERMAL_SUPPORT		// ZZ: Snapdragon temperature tripping support
+
+#if defined(CONFIG_THERMAL_TSENS8974) || defined(CONFIG_THERMAL_TSENS8960) && defined(ENABLE_SNAP_THERMAL_SUPPORT) // ZZ: Snapdragon temperature sensor
+#include <linux/msm_tsens.h>
+#endif /* defined(CONFIG_THERMAL_TSENS8974)... */
+
+// #define ENABLE_INPUTBOOSTER			// ZZ: enable/disable inputbooster support
+// #define ENABLE_WORK_RESTARTLOOP		// ZZ: enable/disable restart loop for touchboost (DO NOT ENABLE IN THIS VERSION -> NOT STABLE YET!)
+
+#ifdef ENABLE_INPUTBOOSTER
+#include <linux/slab.h>
+#include <linux/input.h>
+#endif /* ENABLE_INPUTBOOSTER */
+
+// Yank: enable/disable sysfs interface to display current zzmoove version
+#define ZZMOOVE_VERSION "1.0 beta8"
+
+// ZZ: support for 2,4,6 or 8 cores (this will enable/disable hotplug threshold tuneables and limit hotplug max limit tuneable)
+#define MAX_CORES					(4)
+
+// ZZ: enable/disable hotplug support
+#define ENABLE_HOTPLUGGING
+
+// ZZ: enable support for native hotplugging on snapdragon platform
+// #define SNAP_NATIVE_HOTPLUGGING
+
+// ZZ: enable for sources with backported cpufreq implementation of 3.10 kernel
+// #define CPU_IDLE_TIME_IN_CPUFREQ
+
+// ZZ: enable/disable music limits
+#define ENABLE_MUSIC_LIMITS
+
+// ZZ: enable/disable freq auto adjusting
+#define ENABLE_AUTO_ADJUST_FREQ
+
+// ZZ: enable/disable profiles support
+#define ENABLE_PROFILES_SUPPORT
+
+// ZZ: include profiles header file and set name for 'custom' profile (informational for a changed profile value)
+#ifdef ENABLE_PROFILES_SUPPORT
+#include "cpufreq_zzmoove_profiles.h"
+#define DEF_PROFILE_NUMBER				(2)	// ZZ: default profile number (profile = 0 = 'none' = tuneable mode)
+static char custom_profile[20] = "custom";			// ZZ: name to show in sysfs if any profile value has changed
+
+// ff: allows tuneables to be tweaked without reverting to "custom" profile
+#define DEF_PROFILE_STICKY_MODE				(1)
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+// Yank: enable/disable debugging code
+// #define ZZMOOVE_DEBUG
+
+/*
+ * The polling frequency of this governor depends on the capability of
+ * the processor. Default polling frequency is 1000 times the transition
+ * latency of the processor. The governor will work on any processor with
+ * transition latency <= 10mS, using appropriate samplingrate. For CPUs
+ * with transition latency > 10mS (mostly drivers with CPUFREQ_ETERNAL)
+ * this governor will not work. All times here are in uS.
+ */
+#define TRANSITION_LATENCY_LIMIT	    (10 * 1000 * 1000)	// ZZ: default transition latency limit
+#define LATENCY_MULTIPLIER				(1000)	// ZZ: default latency multiplier
+#define MIN_LATENCY_MULTIPLIER				(100)	// ZZ: default min latency multiplier
+#define MIN_SAMPLING_RATE_RATIO				(2)	// ZZ: default min sampling rate ratio
+
+// ZZ: general tuneable defaults
+#define DEF_FREQUENCY_UP_THRESHOLD			(70)	// ZZ: default regular scaling up threshold
+#ifdef ENABLE_HOTPLUGGING
+#define DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG		(68)	// ZZ: default hotplug up threshold for all cpus (cpu0 stays allways on)
+#define DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ		(0)	// Yank: default hotplug up threshold frequency for all cpus (0 = disabled)
+#endif /* ENABLE_HOTPLUGGING */
+#define DEF_SMOOTH_UP					(75)	// ZZ: default cpu load trigger for 'boosting' scaling frequency
+#define DEF_FREQUENCY_DOWN_THRESHOLD			(52)	// ZZ: default regular scaling down threshold
+#ifdef ENABLE_HOTPLUGGING
+#define DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG		(55)	// ZZ: default hotplug down threshold for all cpus (cpu0 stays allways on)
+#define DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ	(0)	// Yank: default hotplug down threshold frequency for all cpus (0 = disabled)
+#endif /* ENABLE_HOTPLUGGING */
+#define DEF_IGNORE_NICE					(0)	// ZZ: default ignore nice load
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+#define DEF_AUTO_ADJUST_FREQ				(0)	// ZZ: default auto adjust frequency thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+
+// ZZ: hotplug-switch, -block, -idle, -limit and scaling-block, -fastdown, -responiveness, -proportional tuneable defaults
+#ifdef ENABLE_HOTPLUGGING
+#define DEF_DISABLE_HOTPLUG				(0)	// ZZ: default hotplug switch
+#define DEF_HOTPLUG_BLOCK_UP_CYCLES			(0)	// ZZ: default hotplug up block cycles
+#define DEF_HOTPLUG_BLOCK_DOWN_CYCLES			(0)	// ZZ: default hotplug down block cycles
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG1		(0)	// ff: default hotplug up block multiplier for core 2
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG2		(0)	// ff: default hotplug up block multiplier for core 3
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG3		(0)	// ff: default hotplug up block multiplier for core 4
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG4		(0)	// ff: default hotplug up block multiplier for core 5
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG5		(0)	// ff: default hotplug up block multiplier for core 6
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG6		(0)	// ff: default hotplug up block multiplier for core 7
+#define DEF_BLOCK_UP_MULTIPLIER_HOTPLUG7		(0)	// ff: default hotplug up block multiplier for core 8
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG1		(0)	// ff: default hotplug down block multiplier for core 2
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG2		(0)	// ff: default hotplug down block multiplier for core 3
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG3		(0)	// ff: default hotplug down block multiplier for core 4
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG4		(0)	// ff: default hotplug down block multiplier for core 5
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG5		(0)	// ff: default hotplug down block multiplier for core 6
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG6		(0)	// ff: default hotplug down block multiplier for core 7
+#define DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG7		(0)	// ff: default hotplug down block multiplier for core 8
+#define DEF_HOTPLUG_STAGGER_UP				(0)	// ff: only bring one core up at a time when hotplug_online_work() called
+#define DEF_HOTPLUG_STAGGER_DOWN			(0)	// ff: only bring one core down at a time when hotplug_offline_work() called
+#define DEF_HOTPLUG_IDLE_THRESHOLD			(0)	// ZZ: default hotplug idle threshold
+#define DEF_HOTPLUG_IDLE_FREQ				(0)	// ZZ: default hotplug idle freq
+#define DEF_HOTPLUG_ENGAGE_FREQ				(0)	// ZZ: default hotplug engage freq. the frequency below which we run on only one core (0 = disabled) (ffolkes)
+#define DEF_HOTPLUG_MAX_LIMIT				(0)	// ff: default for hotplug_max_limit. the number of cores we allow to be online (0 = disabled)
+#define DEF_HOTPLUG_MIN_LIMIT				(0)	// ff: default for hotplug_min_limit. the number of cores we require to be online (0 = disabled)
+#define DEF_HOTPLUG_LOCK				(0)	// ff: default for hotplug_lock. the number of cores we require to be online (0 = disabled)
+#endif /* ENABLE_HOTPLUGGING */
+#define DEF_SCALING_BLOCK_THRESHOLD			(0)	// ZZ: default scaling block threshold
+#define DEF_SCALING_BLOCK_CYCLES			(0)	// ZZ: default scaling block cycles
+#define DEF_SCALING_BLOCK_FREQ				(0)	// ZZ: default scaling block freq
+#define DEF_SCALING_UP_BLOCK_CYCLES			(0)	// ff: default scaling-up block cycles
+#define DEF_SCALING_UP_BLOCK_FREQ			(0)	// ff: default scaling-up block frequency threshold
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+#define DEF_TMU_READ_DELAY				(1000)	// ZZ: delay for cpu temperature reading in ms (tmu driver polling intervall is 10 sec)
+#define DEF_SCALING_BLOCK_TEMP				(0)	// ZZ: default cpu temperature threshold in C
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT				// ff: snapdragon temperature tripping defaults
+#define DEF_SCALING_TRIP_TEMP				(60)	// ff: default trip cpu temp
+#define DEF_TMU_CHECK_DELAY				(2500)	// ZZ: default delay for snapdragon thermal tripping
+#define DEF_TMU_CHECK_DELAY_SLEEP			(10000)	// ZZ: default delay for snapdragon thermal tripping at sleep
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+#define DEF_SCALING_BLOCK_FORCE_DOWN			(2)	// ZZ: default scaling block force down
+#define DEF_SCALING_FASTDOWN_FREQ			(0)	// ZZ: default scaling fastdown freq. the frequency beyond which we apply a different up_threshold (ffolkes)
+#define DEF_SCALING_FASTDOWN_UP_THRESHOLD		(95)	// ZZ: default scaling fastdown up threshold. the up threshold when scaling fastdown freq has been exceeded (ffolkes)
+#define DEF_SCALING_FASTDOWN_DOWN_THRESHOLD		(90)	// ZZ: default scaling fastdown up threshold. the down threshold when scaling fastdown freq has been exceeded (ffolkes)
+#define DEF_SCALING_RESPONSIVENESS_FREQ			(0)	// ZZ: default frequency below which we use a lower up threshold (ffolkes)
+#define DEF_SCALING_RESPONSIVENESS_UP_THRESHOLD		(30)	// ZZ: default up threshold we use when below scaling responsiveness freq (ffolkes)
+#define DEF_SCALING_PROPORTIONAL			(0)	// ZZ: default proportional scaling
+
+// ZZ: sampling rate idle and sampling down momentum tuneable defaults
+#define DEF_SAMPLING_RATE_IDLE_THRESHOLD		(0)	// ZZ: default sampling rate idle threshold
+#define DEF_SAMPLING_RATE_IDLE				(180000)// ZZ: default sampling rate idle (must not be 0!)
+#define DEF_SAMPLING_RATE_IDLE_DELAY			(0)	// ZZ: default sampling rate idle delay
+#define DEF_SAMPLING_DOWN_FACTOR			(1)	// ZZ: default sampling down factor (stratosk default = 4) here disabled by default
+#define MAX_SAMPLING_DOWN_FACTOR			(100000)// ZZ: changed from 10 to 100000 for sampling down momentum implementation
+#define DEF_SAMPLING_DOWN_MOMENTUM			(0)	// ZZ: default sampling down momentum, here disabled by default
+#define DEF_SAMPLING_DOWN_MAX_MOMENTUM			(0)	// ZZ: default sampling down max momentum stratosk default=16, here disabled by default
+#define DEF_SAMPLING_DOWN_MOMENTUM_SENSITIVITY		(50)	// ZZ: default sampling down momentum sensitivity
+#define MAX_SAMPLING_DOWN_MOMENTUM_SENSITIVITY		(1000)	// ZZ: default maximum for sampling down momentum sensitivity
+
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+// ZZ: tuneable defaults for early suspend
+#define MAX_SAMPLING_RATE_SLEEP_MULTIPLIER		(8)	// ZZ: default maximum for sampling rate sleep multiplier
+#define DEF_SAMPLING_RATE_SLEEP_MULTIPLIER		(2)	// ZZ: default sampling rate sleep multiplier
+#define DEF_UP_THRESHOLD_SLEEP				(90)	// ZZ: default up threshold sleep
+#define DEF_DOWN_THRESHOLD_SLEEP			(44)	// ZZ: default down threshold sleep
+#define DEF_SMOOTH_UP_SLEEP				(75)	// ZZ: default smooth up sleep
+#define DEF_EARLY_DEMAND_SLEEP				(1)	// ZZ: default early demand sleep
+#define DEF_GRAD_UP_THRESHOLD_SLEEP			(30)	// ZZ: default grad up sleep
+#define DEF_FAST_SCALING_SLEEP_UP			(0)	// Yank: default fast scaling sleep for upscaling
+#define DEF_FAST_SCALING_SLEEP_DOWN			(0)	// Yank: default fast scaling sleep for downscaling
+#define DEF_FREQ_LIMIT_SLEEP				(0)	// ZZ: default freq limit sleep
+#ifdef ENABLE_HOTPLUGGING
+#define DEF_DISABLE_HOTPLUG_SLEEP			(0)	// ZZ: default hotplug sleep switch
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* ENABLE_HOTPLUGGING */
+
+/*
+ * ZZ: Hotplug Sleep: 0 do not touch hotplug settings at suspend, so all cores will stay online
+ * the value is equivalent to the amount of cores which should be online at suspend
+ */
+#ifdef ENABLE_HOTPLUGGING
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+#define DEF_HOTPLUG_SLEEP				(0)	// ZZ: default hotplug sleep
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+
+// ZZ: tuneable defaults for Early Demand
+#define DEF_GRAD_UP_THRESHOLD				(25)	// ZZ: default grad up threshold
+#define DEF_EARLY_DEMAND				(0)	// ZZ: default early demand, default off
+
+/*
+ * ZZ: Frequency Limit: 0 do not limit frequency and use the full range up to policy->max limit
+ * values policy->min to policy->max in khz
+ */
+#define DEF_FREQ_LIMIT					(0)	// ZZ: default freq limit
+
+/*
+ * ZZ: Fast Scaling: 0 do not activate fast scaling function
+ * values 1-4 to enable fast scaling and 5 for auto fast scaling (insane scaling)
+ */
+#define DEF_FAST_SCALING_UP				(0)	// Yank: default fast scaling for upscaling
+#define DEF_FAST_SCALING_DOWN				(0)	// Yank: default fast scaling for downscaling
+#define DEF_AFS_THRESHOLD1				(25)	// ZZ: default auto fast scaling step one
+#define DEF_AFS_THRESHOLD2				(50)	// ZZ: default auto fast scaling step two
+#define DEF_AFS_THRESHOLD3				(75)	// ZZ: default auto fast scaling step three
+#define DEF_AFS_THRESHOLD4				(90)	// ZZ: default auto fast scaling step four
+
+// ff: Input Booster defaults
+#ifdef ENABLE_INPUTBOOSTER
+#define DEF_INPUTBOOST_CYCLES				(0)	// ff: default number of cycles to boost up/down thresholds
+#define DEF_INPUTBOOST_UP_THRESHOLD			(80)	// ff: default up threshold for inputbooster
+#define DEF_INPUTBOOST_PUNCH_CYCLES			(20)	// ff: default number of cycles to meet or exceed punch freq
+#define DEF_INPUTBOOST_PUNCH_FREQ			(0)	// ff: default frequency to keep cur_freq at or above
+#define DEF_INPUTBOOST_PUNCH_ON_FINGERDOWN		(0)	// ff: default for constant punching (like a touchbooster)
+#define DEF_INPUTBOOST_PUNCH_ON_FINGERMOVE		(0)	// ff: default for constant punching (like a touchbooster)
+#define DEF_INPUTBOOST_PUNCH_ON_EPENMOVE		(0)	// ff: default for constant punching (like a touchbooster)
+#define DEF_INPUTBOOST_ON_TSP				(1)	// ff: default to boost on touchscreen input events
+#define DEF_INPUTBOOST_ON_TSP_HOVER			(1)	// ff: default to boost on touchscreen hovering input events
+#define DEF_INPUTBOOST_ON_GPIO				(1)	// ff: default to boost on gpio (button) input events
+#define DEF_INPUTBOOST_ON_TK				(1)	// ff: default to boost on touchkey input events
+#define DEF_INPUTBOOST_ON_EPEN				(1)	// ff: default to boost on e-pen input events
+#define DEF_INPUTBOOST_TYPINGBOOSTER_UP_THRESHOLD	(40)	// ff: default up threshold for typing booster
+#define DEF_INPUTBOOST_TYPINGBOOSTER_CORES		(3)	// ff: default cores for typing booster
+#endif /* ENABLE_INPUTBOOSTER */
+
+// ff: Music Detection defaults
+#ifdef ENABLE_MUSIC_LIMITS
+#define DEF_MUSIC_MAX_FREQ				(0)	// ff: default maximum freq to maintain while music is on
+#define DEF_MUSIC_MIN_FREQ				(0)	// ff: default minimum freq to maintain while music is on
+#ifdef ENABLE_HOTPLUGGING
+#define DEF_MUSIC_MIN_CORES				(2)	// ZZ: default minimum cores online while music is on
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* ENABLE_MUSIC_LIMITS */
+
+// ZZ: Sampling Down Momentum variables
+static unsigned int min_sampling_rate;				// ZZ: minimal possible sampling rate
+static unsigned int orig_sampling_down_factor;			// ZZ: for saving previously set sampling down factor
+static unsigned int zz_sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;		// ff: actual use variable, so dbs_tuner_ins version stays constant
+static unsigned int orig_sampling_down_max_mom;			// ZZ: for saving previously set smapling down max momentum
+static unsigned int zz_sampling_down_max_mom;			// ff: actual use variable, so dbs_tuner_ins version stays constant
+
+// ZZ: search limit for frequencies in scaling table, variables for scaling modes and state flag for suspend detection
+static struct cpufreq_frequency_table *system_freq_table;	// ZZ: static system frequency table
+static int scaling_mode_up;					// ZZ: fast scaling up mode holding up value during runtime
+static int scaling_mode_down;					// ZZ: fast scaling down mode holding down value during runtime
+static bool freq_table_desc = false;				// ZZ: true for descending order, false for ascending order
+static int freq_init_count = 0;					// ZZ: flag for executing freq table order and limit optimization code at gov start
+static unsigned int max_scaling_freq_soft = 0;			// ZZ: init value for 'soft' scaling limit, 0 = full range
+static unsigned int max_scaling_freq_hard = 0;			// ZZ: init value for 'hard' scaling limit, 0 = full range
+static unsigned int min_scaling_freq_soft = 0;			// ZZ: init value for 'soft' scaling limit, 0 = full range
+static unsigned int min_scaling_freq_hard = 0;			// ZZ: init value for 'hard' scaling limit, 0 = full range
+static unsigned int system_table_end = CPUFREQ_TABLE_END;	// ZZ: system freq table end for order detection, table size calculation and freq validations
+static unsigned int limit_table_end = CPUFREQ_TABLE_END;	// ZZ: initial (full range) search end limit for frequency table in descending ordered table
+static unsigned int limit_table_start = 0;			// ZZ: search start limit for frequency table in ascending order
+static unsigned int freq_table_size = 0;			// Yank: upper index limit of frequency table
+static unsigned int min_scaling_freq = 0;			// Yank: lowest frequency index in global frequency table
+static bool suspend_flag = false;				// ZZ: flag for suspend status, true = in early suspend
+
+// ZZ: hotplug-, scaling-block, scaling fastdown vars and sampling rate idle counters. flags for scaling, setting profile, cpu temp reading and hotplugging
+#ifdef ENABLE_HOTPLUGGING
+static int possible_cpus = 0;					// ZZ: for holding the maximal amount of cores for hotplugging
+static unsigned int hplg_down_block_cycles = 0;			// ZZ: delay cycles counter for hotplug down blocking
+static unsigned int hplg_up_block_cycles = 0;			// ZZ: delay cycles counter for hotplug up blocking
+static unsigned int num_online_cpus_last = 0;			// ff: how many cores were online last cycle
+static unsigned int zz_hotplug_block_up_cycles = 0;
+static unsigned int zz_hotplug_block_down_cycles = 0;
+#endif /* ENABLE_HOTPLUGGING */
+static unsigned int scaling_block_cycles_count = 0;		// ZZ: scaling block cycles counter
+static unsigned int sampling_rate_step_up_delay = 0;		// ZZ: sampling rate idle up delay cycles
+static unsigned int sampling_rate_step_down_delay = 0;		// ZZ: sampling rate idle down delay cycles
+static unsigned int scaling_up_threshold = 0;			// ZZ: scaling up threshold for fastdown/responsiveness functionality
+static unsigned int scaling_down_threshold = 0;			// ZZ: scaling down threshold for fastdown functionality
+#ifdef ENABLE_HOTPLUGGING
+static bool hotplug_idle_flag = false;				// ZZ: flag for hotplug idle mode
+static int __refdata enable_cores = 0;				// ZZ: mode for enabling offline cores for various functions in the governor
+static int __refdata disable_cores = 0;				// ZZ: mode for disabling online cores for various functions in the governor
+static bool hotplug_up_in_progress;				// ZZ: flag for hotplug up function call - block if hotplugging is in progress
+static bool hotplug_down_in_progress;				// ZZ: flag for hotplug down function call - block if hotplugging is in progress
+static bool boost_hotplug = false;				// ZZ: early demand boost hotplug flag
+#endif /* ENABLE_HOTPLUGGING */
+static bool boost_freq = false;					// ZZ: early demand boost freq flag
+static bool force_down_scaling = false;				// ZZ: force down scaling flag
+static bool cancel_up_scaling = false;				// ZZ: cancel up scaling flag
+#ifdef ENABLE_PROFILES_SUPPORT
+static bool set_profile_active = false;				// ZZ: flag to avoid changing of any tuneables during profile apply
+#endif
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+#ifdef ENABLE_HOTPLUGGING
+static bool hotplug_up_temp_block;				// ZZ: flag for blocking up hotplug work during temp freq blocking
+#endif /* ENABLE_HOTPLUGGING */
+static bool cancel_temp_reading = false;			// ZZ: flag for starting temp reading work
+static bool temp_reading_started = false;			// ZZ: flag for canceling temp reading work
+
+// ZZ: Exynos CPU temp reading work
+static void tmu_read_temperature(struct work_struct * tmu_read_work);	// ZZ: prepare temp reading work
+static DECLARE_DELAYED_WORK(tmu_read_work, tmu_read_temperature);	// ZZ: declare delayed work for temp reading
+static unsigned int cpu_temp;						// ZZ: static var for holding current cpu temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+
+// ZZ: current load & frequency for hotplugging work and scaling. max/min frequency for proportional scaling and auto freq threshold adjustment
+static unsigned int cur_load = 0;				// ZZ: current load for hotplugging functions
+static unsigned int cur_freq = 0;				// ZZ: current frequency for hotplugging functions
+static unsigned int pol_max = 0;				// ZZ: current max freq for proportional scaling and auto adjustment of freq thresholds
+static unsigned int pol_min = 0;				// ZZ: current min freq for auto adjustment of freq thresholds
+
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+static unsigned int old_pol_max = 0;				// ZZ: previous max freq for auto adjustment of freq thresholds
+static unsigned int pol_step = 0;				// ZZ: policy change step for auto adjustment of freq thresholds
+
+// ZZ: temp variables and flags to hold offset values for auto adjustment of freq thresholds
+#ifdef ENABLE_HOTPLUGGING
+static unsigned int temp_hotplug_engage_freq = 0;
+static bool temp_hotplug_engage_freq_flag = false;
+static unsigned int temp_hotplug_idle_freq = 0;
+static bool temp_hotplug_idle_freq_flag = false;
+#endif /* ENABLE_HOTPLUGGING */
+static unsigned int temp_scaling_block_freq = 0;
+static bool temp_scaling_block_freq_flag = false;
+static unsigned int temp_scaling_fastdown_freq = 0;
+static bool temp_scaling_fastdown_freq_flag = false;
+static unsigned int temp_scaling_responsiveness_freq = 0;
+static bool temp_scaling_responsiveness_freq_flag = false;
+#ifdef ENABLE_MUSIC_LIMITS
+static unsigned int temp_music_min_freq = 0;
+static bool temp_music_min_freq_flag = false;
+static unsigned int temp_music_max_freq = 0;
+static bool temp_music_max_freq_flag = false;
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ENABLE_HOTPLUGGING
+static unsigned int temp_up_threshold_hotplug_freq1 = 0;
+static bool temp_up_threshold_hotplug_freq1_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq1 = 0;
+static bool temp_down_threshold_hotplug_freq1_flag = false;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+static unsigned int temp_up_threshold_hotplug_freq2 = 0;
+static bool temp_up_threshold_hotplug_freq2_flag = false;
+static unsigned int temp_up_threshold_hotplug_freq3 = 0;
+static bool temp_up_threshold_hotplug_freq3_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq2 = 0;
+static bool temp_down_threshold_hotplug_freq2_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq3 = 0;
+static bool temp_down_threshold_hotplug_freq3_flag = false;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+static unsigned int temp_up_threshold_hotplug_freq4 = 0;
+static bool temp_up_threshold_hotplug_freq4_flag = false;
+static unsigned int temp_up_threshold_hotplug_freq5 = 0;
+static bool temp_up_threshold_hotplug_freq5_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq4 = 0;
+static bool temp_down_threshold_hotplug_freq4_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq5 = 0;
+static bool temp_down_threshold_hotplug_freq5_flag = false;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+static unsigned int temp_up_threshold_hotplug_freq6 = 0;
+static bool temp_up_threshold_hotplug_freq6_flag = false;
+static unsigned int temp_up_threshold_hotplug_freq7 = 0;
+static bool temp_up_threshold_hotplug_freq7_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq6 = 0;
+static bool temp_down_threshold_hotplug_freq6_flag = false;
+static unsigned int temp_down_threshold_hotplug_freq7 = 0;
+static bool temp_down_threshold_hotplug_freq7_flag = false;
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#ifdef ENABLE_INPUTBOOSTER
+static unsigned int temp_inputboost_punch_freq = 0;
+static bool temp_inputboost_punch_freq_flag = false;
+#endif /* ENABLE_INPUTBOOSTER */
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+
+#ifdef ENABLE_HOTPLUGGING
+// ZZ: hotplug load thresholds array
+static int hotplug_thresholds[2][8] = {
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 }
+    };
+
+// ZZ: hotplug frequencies thresholds array
+static int hotplug_thresholds_freq[2][8] = {
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 }
+    };
+
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+// ZZ: hotplug frequencies out of range array
+static int hotplug_freq_threshold_out_of_range[2][8] = {
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 },
+    { 0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 }
+    };
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#endif /* ENABLE_HOTPLUGGING */
+
+// ZZ: core on which we currently run
+static unsigned int on_cpu = 0;
+
+// ZZ: Early Suspend variables
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static unsigned int sampling_rate_awake;			// ZZ: for saving sampling rate awake value
+static unsigned int up_threshold_awake;				// ZZ: for saving up threshold awake value
+static unsigned int down_threshold_awake;			// ZZ: for saving down threshold awake value
+static unsigned int smooth_up_awake;				// ZZ: for saving smooth up awake value
+static unsigned int freq_limit_awake;				// ZZ: for saving frequency limit awake value
+static unsigned int fast_scaling_up_awake;			// Yank: for saving fast scaling awake value for upscaling
+static unsigned int fast_scaling_down_awake;			// Yank: for saving fast scaling awake value for downscaling
+#ifdef ENABLE_HOTPLUGGING
+static unsigned int disable_hotplug_awake;			// ZZ: for saving hotplug switch
+static unsigned int hotplug1_awake;				// ZZ: for saving hotplug1 threshold awake value
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+static unsigned int hotplug2_awake;				// ZZ: for saving hotplug2 threshold awake value
+static unsigned int hotplug3_awake;				// ZZ: for saving hotplug3 threshold awake value
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+static unsigned int hotplug4_awake;				// ZZ: for saving hotplug4 threshold awake value
+static unsigned int hotplug5_awake;				// ZZ: for saving hotplug5 threshold awake value
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+static unsigned int hotplug6_awake;				// ZZ: for saving hotplug6 threshold awake value
+static unsigned int hotplug7_awake;				// ZZ: for saving hotplug7 threshold awake value
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+static unsigned int sampling_rate_asleep;			// ZZ: for setting sampling rate value at early suspend
+static unsigned int up_threshold_asleep;			// ZZ: for setting up threshold value at early suspend
+static unsigned int down_threshold_asleep;			// ZZ: for setting down threshold value at early suspend
+static unsigned int smooth_up_asleep;				// ZZ: for setting smooth scaling value at early suspend
+static unsigned int freq_limit_asleep;				// ZZ: for setting frequency limit value at early suspend
+static unsigned int fast_scaling_up_asleep;			// Yank: for setting fast scaling value at early suspend for upscaling
+static unsigned int fast_scaling_down_asleep;			// Yank: for setting fast scaling value at early suspend for downscaling
+#ifdef ENABLE_HOTPLUGGING
+static unsigned int disable_hotplug_asleep;			// ZZ: for setting hotplug on/off at early suspend
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+#if defined(USE_LCD_NOTIFIER) && !defined(CONFIG_POWERSUSPEND)
+static struct notifier_block zzmoove_lcd_notif;
+#endif /* defined(USE_LCD_NOTIFIER)... */
+
+#ifdef ENABLE_INPUTBOOSTER
+// ff: Input Booster variables
+static unsigned int boost_on_tsp = DEF_INPUTBOOST_ON_TSP;	// ff: hardcoded since it'd be silly not to use it
+static unsigned int boost_on_tsp_hover = DEF_INPUTBOOST_ON_TSP_HOVER;
+static unsigned int boost_on_gpio = DEF_INPUTBOOST_ON_GPIO;	// ff: hardcoded since it'd be silly not to use it
+static unsigned int boost_on_tk = DEF_INPUTBOOST_ON_TK;		// ff: hardcoded since it'd be silly not to use it
+static unsigned int boost_on_epen = DEF_INPUTBOOST_ON_EPEN;	// ff: hardcoded since it'd be silly not to use it
+static unsigned int inputboost_last_type = 0;
+static unsigned int inputboost_last_code = 0;
+static unsigned int inputboost_last_value = 0;
+static int inputboost_report_btn_touch = -1;
+static int inputboost_report_btn_toolfinger = -1;
+static int inputboost_report_mt_trackingid = 0;
+static bool flg_inputboost_report_mt_touchmajor = false;
+static bool flg_inputboost_report_abs_xy = false;
+int flg_ctr_cpuboost = 0;
+static int flg_ctr_inputboost = 0;
+static int flg_ctr_inputboost_punch = 0;
+static int flg_ctr_inputbooster_typingbooster = 0;
+static int ctr_inputboost_typingbooster_taps = 0;
+static struct timeval time_typingbooster_lasttapped;
+#ifdef ZZMOOVE_DEBUG
+static struct timeval time_touchbooster_lastrun;
+static unsigned int time_since_touchbooster_lastrun = 0;
+#endif /* ZZMOOVE_DEBUG */
+#endif /* ENABLE_INPUTBOOSTER */
+
+// ff: other variables
+static int scaling_up_block_cycles_count = 0;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+#ifdef ENABLE_MUSIC_LIMITS
+static int music_max_freq_step = 0;
+#endif /* ENABLE_MUSIC_LIMITS */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+#ifdef ENABLE_WORK_RESTARTLOOP
+struct work_struct work_restartloop;
+static bool work_restartloop_in_progress = false;		// ZZ: flag to avoid loop restart to frequently
+#endif /* ENABLE_WORK_RESTARTLOOP */
+
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+static void tmu_check_work(struct work_struct * work_tmu_check);
+static DECLARE_DELAYED_WORK(work_tmu_check, tmu_check_work);
+static int tmu_temp_cpu = 0;
+static int tmu_temp_cpu_last = 0;
+static int flg_ctr_tmu_overheating = 0;
+static int tmu_throttle_steps = 0;
+static int ctr_tmu_neutral = 0;
+static int ctr_tmu_falling = 0;
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+
+#ifdef ENABLE_HOTPLUGGING
+struct work_struct hotplug_offline_work;			// ZZ: hotplugging down work
+struct work_struct hotplug_online_work;				// ZZ: hotplugging up work
+#endif /* ENABLE_HOTPLUGGING */
+
+static void do_dbs_timer(struct work_struct *work);
+
+struct cpu_dbs_info_s {
+	u64 time_in_idle;					// ZZ: for exit time handling
+	u64 idle_exit_time;					// ZZ: for exit time handling
+	u64 prev_cpu_idle;
+	u64 prev_cpu_wall;
+	u64 prev_cpu_nice;
+	struct cpufreq_policy *cur_policy;
+	struct delayed_work work;
+	unsigned int down_skip;					// ZZ: Sampling Down reactivated
+	unsigned int requested_freq;
+	unsigned int rate_mult;					// ZZ: Sampling Down Momentum - sampling rate multiplier
+	unsigned int momentum_adder;				// ZZ: Sampling Down Momentum - adder
+	int cpu;
+	unsigned int enable:1;
+	unsigned int prev_load;					// ZZ: Early Demand - for previous load
+
+	/*
+	 * percpu mutex that serializes governor limit change with
+	 * do_dbs_timer invocation. We do not want do_dbs_timer to run
+	 * when user is changing the governor or limits.
+	 */
+	struct mutex timer_mutex;
+};
+
+static bool dbs_info_enabled = false;
+static DEFINE_PER_CPU(struct cpu_dbs_info_s, cs_cpu_dbs_info);
+static unsigned int dbs_enable;					// number of CPUs using this policy
+static DEFINE_MUTEX(dbs_mutex);					// dbs_mutex protects dbs_enable in governor start/stop.
+static struct workqueue_struct *dbs_wq;
+#ifdef ENABLE_WORK_RESTARTLOOP
+static struct workqueue_struct *dbs_aux_wq;
+#endif /* ENABLE_WORK_RESTARTLOOP */
+static struct dbs_tuners {
+#ifdef ENABLE_PROFILES_SUPPORT
+	char profile[20];					// ZZ: profile tuneable
+	unsigned int profile_number;				// ZZ: profile number tuneable
+	unsigned int profile_sticky_mode;			// ff: sticky profile mode
+#endif /* ENABLE_PROFILES_SUPPORT */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+	unsigned int auto_adjust_freq_thresholds;		// ZZ: auto adjust freq thresholds tuneable
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+	unsigned int sampling_rate;				// ZZ: normal sampling rate tuneable
+	unsigned int sampling_rate_current;			// ZZ: currently active sampling rate tuneable
+	unsigned int sampling_rate_idle;			// ZZ: sampling rate at idle tuneable
+	unsigned int sampling_rate_idle_threshold;		// ZZ: sampling rate switching threshold tuneable
+	unsigned int sampling_rate_idle_delay;			// ZZ: sampling rate switching delay tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int sampling_rate_sleep_multiplier;		// ZZ: sampling rate sleep multiplier tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int sampling_down_factor;			// ZZ: sampling down factor tuneable (reactivated)
+	unsigned int sampling_down_momentum;			// ZZ: sampling down momentum tuneable
+	unsigned int sampling_down_max_mom;			// ZZ: sampling down momentum max tuneable
+	unsigned int sampling_down_mom_sens;			// ZZ: sampling down momentum sensitivity tuneable
+	unsigned int up_threshold;				// ZZ: scaling up threshold tuneable
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int up_threshold_hotplug1;			// ZZ: up threshold hotplug tuneable for core1
+	unsigned int up_threshold_hotplug_freq1;		// Yank: up threshold hotplug freq tuneable for core1
+	unsigned int block_up_multiplier_hotplug1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug2;			// ZZ: up threshold hotplug tuneable for core2
+	unsigned int up_threshold_hotplug_freq2;		// Yank: up threshold hotplug freq tuneable for core2
+	unsigned int block_up_multiplier_hotplug2;
+	unsigned int up_threshold_hotplug3;			// ZZ: up threshold hotplug tuneable for core3
+	unsigned int up_threshold_hotplug_freq3;		// Yank: up threshold hotplug freq tuneable for core3
+	unsigned int block_up_multiplier_hotplug3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug4;			// ZZ: up threshold hotplug tuneable for core4
+	unsigned int up_threshold_hotplug_freq4;		// Yank: up threshold hotplug freq tuneable for core4
+	unsigned int block_up_multiplier_hotplug4;
+	unsigned int up_threshold_hotplug5;			// ZZ: up threshold hotplug tuneable for core5
+	unsigned int up_threshold_hotplug_freq5;		// Yank: up threshold hotplug freq tuneable for core5
+	unsigned int block_up_multiplier_hotplug5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int up_threshold_hotplug6;			// ZZ: up threshold hotplug tuneable for core6
+	unsigned int up_threshold_hotplug_freq6;		// Yank: up threshold hotplug freq tuneable  for core6
+	unsigned int block_up_multiplier_hotplug6;
+	unsigned int up_threshold_hotplug7;			// ZZ: up threshold hotplug tuneable for core7
+	unsigned int up_threshold_hotplug_freq7;		// Yank: up threshold hotplug freq tuneable for core7
+	unsigned int block_up_multiplier_hotplug7;
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+	unsigned int up_threshold_sleep;			// ZZ: up threshold sleep tuneable for early suspend
+	unsigned int down_threshold;				// ZZ: down threshold tuneable
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int down_threshold_hotplug1;			// ZZ: down threshold hotplug tuneable for core1
+	unsigned int down_threshold_hotplug_freq1;		// Yank: down threshold hotplug freq tuneable for core1
+	unsigned int block_down_multiplier_hotplug1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug2;			// ZZ: down threshold hotplug tuneable for core2
+	unsigned int down_threshold_hotplug_freq2;		// Yank: down threshold hotplug freq tuneable for core2
+	unsigned int block_down_multiplier_hotplug2;
+	unsigned int down_threshold_hotplug3;			// ZZ: down threshold hotplug tuneable for core3
+	unsigned int down_threshold_hotplug_freq3;		// Yank: down threshold hotplug freq tuneable for core3
+	unsigned int block_down_multiplier_hotplug3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug4;			// ZZ: down threshold hotplug tuneable for core4
+	unsigned int down_threshold_hotplug_freq4;		// Yank: down threshold hotplug freq tuneable for core4
+	unsigned int block_down_multiplier_hotplug4;
+	unsigned int down_threshold_hotplug5;			// ZZ: down threshold hotplug tuneable for core5
+	unsigned int down_threshold_hotplug_freq5;		// Yank: down threshold hotplug_freq tuneable for core5
+	unsigned int block_down_multiplier_hotplug5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int down_threshold_hotplug6;			// ZZ: down threshold hotplug tuneable for core6
+	unsigned int down_threshold_hotplug_freq6;		// Yank: down threshold hotplug freq tuneable for core6
+	unsigned int block_down_multiplier_hotplug6;
+	unsigned int down_threshold_hotplug7;			// ZZ: down threshold hotplug tuneable for core7
+	unsigned int down_threshold_hotplug_freq7;		// Yank: down threshold hotplug freq tuneable for core7
+	unsigned int block_down_multiplier_hotplug7;
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int down_threshold_sleep;			// ZZ: down threshold sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int ignore_nice;				// ZZ: ignore nice load tuneable
+	unsigned int smooth_up;					// ZZ: smooth up tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int smooth_up_sleep;				// ZZ: smooth up sleep tuneable for early suspend
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int hotplug_sleep;				// ZZ: hotplug sleep tuneable for early suspend
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int freq_limit;				// ZZ: freq limit tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int freq_limit_sleep;				// ZZ: freq limit sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int fast_scaling_up;				// Yank: fast scaling tuneable for upscaling
+	unsigned int fast_scaling_down;				// Yank: fast scaling tuneable for downscaling
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int fast_scaling_sleep_up;			// Yank: fast scaling sleep tuneable for early suspend for upscaling
+	unsigned int fast_scaling_sleep_down;			// Yank: fast scaling sleep tuneable for early suspend for downscaling
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int afs_threshold1;				// ZZ: auto fast scaling step one threshold
+	unsigned int afs_threshold2;				// ZZ: auto fast scaling step two threshold
+	unsigned int afs_threshold3;				// ZZ: auto fast scaling step three threshold
+	unsigned int afs_threshold4;				// ZZ: auto fast scaling step four threshold
+	unsigned int grad_up_threshold;				// ZZ: early demand grad up threshold tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int grad_up_threshold_sleep;			// ZZ: early demand grad up threshold tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int early_demand;				// ZZ: early demand master switch tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int early_demand_sleep;			// ZZ: early demand master switch tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int disable_hotplug;				// ZZ: hotplug switch tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	unsigned int disable_hotplug_sleep;			// ZZ: hotplug switch for sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int hotplug_block_up_cycles;			// ZZ: hotplug up block cycles tuneable
+	unsigned int hotplug_block_down_cycles;			// ZZ: hotplug down block cycles tuneable
+	unsigned int hotplug_stagger_up;			// ff: hotplug stagger up tuneable
+	unsigned int hotplug_stagger_down;			// ff: hotplug stagger down tuneable
+	unsigned int hotplug_idle_threshold;			// ZZ: hotplug idle threshold tuneable
+	unsigned int hotplug_idle_freq;				// ZZ: hotplug idle freq tuneable
+	unsigned int hotplug_engage_freq;			// ZZ: frequency below which we run on only one core (ffolkes)
+	unsigned int hotplug_max_limit;				// ff: the number of cores we allow to be online
+	unsigned int hotplug_min_limit;				// ff: the number of cores we require to be online
+	unsigned int hotplug_min_limit_saved;			// ff: the number of cores we require to be online
+	unsigned int hotplug_min_limit_touchbooster;		// ff: the number of cores we require to be online
+	unsigned int hotplug_lock;				// ff: the number of cores we allow to be online
+#endif /* ENABLE_HOTPLUGGING */
+	unsigned int scaling_block_threshold;			// ZZ: scaling block threshold tuneable
+	unsigned int scaling_block_cycles;			// ZZ: scaling block cycles tuneable
+	unsigned int scaling_up_block_cycles;			// ff: scaling-up block cycles tuneable
+	unsigned int scaling_up_block_freq;			// ff: scaling-up block freq threshold tuneable
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	unsigned int scaling_block_temp;			// ZZ: scaling block temp tuneable
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	unsigned int scaling_trip_temp;				// ff: snapdragon temperature tripping
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	unsigned int scaling_block_freq;			// ZZ: scaling block freq tuneable
+	unsigned int scaling_block_force_down;			// ZZ: scaling block force down tuneable
+	unsigned int scaling_fastdown_freq;			// ZZ: frequency beyond which we apply a different up threshold (ffolkes)
+	unsigned int scaling_fastdown_up_threshold;		// ZZ: up threshold when scaling fastdown freq exceeded (ffolkes)
+	unsigned int scaling_fastdown_down_threshold;		// ZZ: down threshold when scaling fastdown freq exceeded (ffolkes)
+	unsigned int scaling_responsiveness_freq;		// ZZ: frequency below which we use a lower up threshold (ffolkes)
+	unsigned int scaling_responsiveness_up_threshold;	// ZZ: up threshold we use when below scaling responsiveness freq (ffolkes)
+	unsigned int scaling_proportional;			// ZZ: proportional to load scaling
+#ifdef ENABLE_INPUTBOOSTER
+	// ff: input booster
+	unsigned int inputboost_cycles;				// ff: default number of cycles to boost up/down thresholds
+	unsigned int inputboost_up_threshold;			// ff: default up threshold for inputbooster
+	unsigned int inputboost_punch_cycles;			// ff: default number of cycles to meet or exceed punch freq
+	unsigned int inputboost_punch_freq;			// ff: default frequency to keep cur_freq at or above
+	unsigned int inputboost_punch_on_fingerdown;
+	unsigned int inputboost_punch_on_fingermove;
+	unsigned int inputboost_punch_on_epenmove;
+	unsigned int inputboost_typingbooster_up_threshold;
+	unsigned int inputboost_typingbooster_cores;
+#endif /* ENABLE_INPUTBOOSTER */
+
+#ifdef ENABLE_MUSIC_LIMITS
+	// ff: Music Detection
+	unsigned int music_max_freq;				// ff: music max freq
+	unsigned int music_min_freq;				// ff: music min freq
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int music_min_cores;				// ff: music min freq
+#endif /* ENABLE_HOTPLUGGING */
+	unsigned int music_state;				// ff: music state
+#endif /* ENABLE_MUSIC_LIMITS */
+
+// ZZ: set tuneable default values
+} dbs_tuners_ins = {
+#ifdef ENABLE_PROFILES_SUPPORT
+	.profile = "none",
+	.profile_number = DEF_PROFILE_NUMBER,
+	.profile_sticky_mode = DEF_PROFILE_STICKY_MODE,
+#endif /* ENABLE_PROFILES_SUPPORT */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+	.auto_adjust_freq_thresholds = DEF_AUTO_ADJUST_FREQ,
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+	.sampling_rate_idle = DEF_SAMPLING_RATE_IDLE,
+	.sampling_rate_idle_threshold = DEF_SAMPLING_RATE_IDLE_THRESHOLD,
+	.sampling_rate_idle_delay = DEF_SAMPLING_RATE_IDLE_DELAY,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.sampling_rate_sleep_multiplier = DEF_SAMPLING_RATE_SLEEP_MULTIPLIER,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR,
+	.sampling_down_momentum = DEF_SAMPLING_DOWN_MOMENTUM,
+	.sampling_down_max_mom = DEF_SAMPLING_DOWN_MAX_MOMENTUM,
+	.sampling_down_mom_sens = DEF_SAMPLING_DOWN_MOMENTUM_SENSITIVITY,
+	.up_threshold = DEF_FREQUENCY_UP_THRESHOLD,
+#ifdef ENABLE_HOTPLUGGING
+	.up_threshold_hotplug1 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq1 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug1 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG1,
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	.up_threshold_hotplug2 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq2 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug2 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG2,
+	.up_threshold_hotplug3 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq3 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug3 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG3,
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	.up_threshold_hotplug4 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq4 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug4 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG4,
+	.up_threshold_hotplug5 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq5 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug5 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG5,
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	.up_threshold_hotplug6 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq6 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug6 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG6,
+	.up_threshold_hotplug7 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG,
+	.up_threshold_hotplug_freq7 = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG_FREQ,
+	.block_up_multiplier_hotplug7 = DEF_BLOCK_UP_MULTIPLIER_HOTPLUG7,
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.up_threshold_sleep = DEF_UP_THRESHOLD_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.down_threshold = DEF_FREQUENCY_DOWN_THRESHOLD,
+#ifdef ENABLE_HOTPLUGGING
+	.down_threshold_hotplug1 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq1 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug1 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG1,
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	.down_threshold_hotplug2 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq2 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug2 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG2,
+	.down_threshold_hotplug3 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq3 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug3 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG3,
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	.down_threshold_hotplug4 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq4 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug4 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG4,
+	.down_threshold_hotplug5 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq5 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug5 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG5,
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	.down_threshold_hotplug6 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq6 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug6 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG6,
+	.down_threshold_hotplug7 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG,
+	.down_threshold_hotplug_freq7 = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG_FREQ,
+	.block_down_multiplier_hotplug7 = DEF_BLOCK_DOWN_MULTIPLIER_HOTPLUG7,
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.down_threshold_sleep = DEF_DOWN_THRESHOLD_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.ignore_nice = DEF_IGNORE_NICE,
+	.smooth_up = DEF_SMOOTH_UP,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.smooth_up_sleep = DEF_SMOOTH_UP_SLEEP,
+#ifdef ENABLE_HOTPLUGGING
+	.hotplug_sleep = DEF_HOTPLUG_SLEEP,
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.freq_limit = DEF_FREQ_LIMIT,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.freq_limit_sleep = DEF_FREQ_LIMIT_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.fast_scaling_up = DEF_FAST_SCALING_UP,
+	.fast_scaling_down = DEF_FAST_SCALING_DOWN,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.fast_scaling_sleep_up = DEF_FAST_SCALING_SLEEP_UP,
+	.fast_scaling_sleep_down = DEF_FAST_SCALING_SLEEP_DOWN,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.afs_threshold1 = DEF_AFS_THRESHOLD1,
+	.afs_threshold2 = DEF_AFS_THRESHOLD2,
+	.afs_threshold3 = DEF_AFS_THRESHOLD3,
+	.afs_threshold4 = DEF_AFS_THRESHOLD4,
+	.grad_up_threshold = DEF_GRAD_UP_THRESHOLD,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.grad_up_threshold_sleep = DEF_GRAD_UP_THRESHOLD_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.early_demand = DEF_EARLY_DEMAND,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.early_demand_sleep = DEF_EARLY_DEMAND_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+	.disable_hotplug = DEF_DISABLE_HOTPLUG,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	.disable_hotplug_sleep = DEF_DISABLE_HOTPLUG_SLEEP,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	.hotplug_block_up_cycles = DEF_HOTPLUG_BLOCK_UP_CYCLES,
+	.hotplug_block_down_cycles = DEF_HOTPLUG_BLOCK_DOWN_CYCLES,
+	.hotplug_stagger_up = DEF_HOTPLUG_STAGGER_UP,
+	.hotplug_stagger_down = DEF_HOTPLUG_STAGGER_DOWN,
+	.hotplug_idle_threshold = DEF_HOTPLUG_IDLE_THRESHOLD,
+	.hotplug_idle_freq = DEF_HOTPLUG_IDLE_FREQ,
+	.hotplug_engage_freq = DEF_HOTPLUG_ENGAGE_FREQ,
+	.hotplug_max_limit = DEF_HOTPLUG_MAX_LIMIT,
+	.hotplug_min_limit = DEF_HOTPLUG_MIN_LIMIT,
+	.hotplug_min_limit_saved = DEF_HOTPLUG_MIN_LIMIT,
+	.hotplug_min_limit_touchbooster = 0,
+	.hotplug_lock = DEF_HOTPLUG_LOCK,
+#endif /* ENABLE_HOTPLUGGING */
+	.scaling_block_threshold = DEF_SCALING_BLOCK_THRESHOLD,
+	.scaling_block_cycles = DEF_SCALING_BLOCK_CYCLES,
+	.scaling_up_block_cycles = DEF_SCALING_UP_BLOCK_CYCLES,
+	.scaling_up_block_freq = DEF_SCALING_UP_BLOCK_FREQ,
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	.scaling_block_temp = DEF_SCALING_BLOCK_TEMP,
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	.scaling_trip_temp = DEF_SCALING_TRIP_TEMP,
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	.scaling_block_freq = DEF_SCALING_BLOCK_FREQ,
+	.scaling_block_force_down = DEF_SCALING_BLOCK_FORCE_DOWN,
+	.scaling_fastdown_freq = DEF_SCALING_FASTDOWN_FREQ,
+	.scaling_fastdown_up_threshold = DEF_SCALING_FASTDOWN_UP_THRESHOLD,
+	.scaling_fastdown_down_threshold = DEF_SCALING_FASTDOWN_DOWN_THRESHOLD,
+	.scaling_responsiveness_freq = DEF_SCALING_RESPONSIVENESS_FREQ,
+	.scaling_responsiveness_up_threshold = DEF_SCALING_RESPONSIVENESS_UP_THRESHOLD,
+	.scaling_proportional = DEF_SCALING_PROPORTIONAL,
+#ifdef ENABLE_INPUTBOOSTER
+	// ff: Input Booster
+	.inputboost_cycles = DEF_INPUTBOOST_CYCLES,
+	.inputboost_up_threshold = DEF_INPUTBOOST_UP_THRESHOLD,
+	.inputboost_punch_cycles = DEF_INPUTBOOST_PUNCH_CYCLES,
+	.inputboost_punch_freq = DEF_INPUTBOOST_PUNCH_FREQ,
+	.inputboost_punch_on_fingerdown = DEF_INPUTBOOST_PUNCH_ON_FINGERDOWN,
+	.inputboost_punch_on_fingermove = DEF_INPUTBOOST_PUNCH_ON_FINGERMOVE,
+	.inputboost_punch_on_epenmove = DEF_INPUTBOOST_PUNCH_ON_EPENMOVE,
+	.inputboost_typingbooster_up_threshold = DEF_INPUTBOOST_TYPINGBOOSTER_UP_THRESHOLD,
+	.inputboost_typingbooster_cores = DEF_INPUTBOOST_TYPINGBOOSTER_CORES,
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+	.music_max_freq = DEF_MUSIC_MAX_FREQ,
+	.music_min_freq = DEF_MUSIC_MIN_FREQ,
+#ifdef ENABLE_HOTPLUGGING
+	.music_min_cores = DEF_MUSIC_MIN_CORES,
+#endif /* ENABLE_HOTPLUGGING */
+	.music_state = 0,
+#endif /* ENABLE_MUSIC_LIMITS */
+};
+
+#ifdef ENABLE_INPUTBOOSTER
+// ff: Input Booster
+static void interactive_input_event(struct input_handle *handle, unsigned int type, unsigned int code, int value)
+{
+	unsigned int time_since_typingbooster_lasttapped = 0;
+	unsigned int flg_do_punch_id = 0;
+	struct timeval time_now;
+	bool flg_inputboost_mt_touchmajor = false;
+	bool flg_inputboost_abs_xy = false;
+	bool flg_force_punch = false;
+	int inputboost_btn_toolfinger = -1;
+	int inputboost_btn_touch = -1;
+	int inputboost_mt_trackingid = 0;
+	int tmp_flg_ctr_inputboost_punch = 0;
+
+	// ff: don't do any boosting when overheating
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	if (tmu_throttle_steps > 0)
+		return;
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	/*
+	 * ff: ignore events if inputboost isn't enabled (we shouldn't ever be here in that case)
+	 *     or screen-off (but allow power press)
+	 */
+	if (!dbs_tuners_ins.inputboost_cycles
+		|| (suspend_flag && inputboost_last_code != 116))
+		return;
+
+	if (type == EV_SYN && code == SYN_REPORT) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove] syn input event. device: %s, saw_touchmajor: %d, saw_xy: %d, toolfinger: %d, touch: %d, trackingid: %d\n",
+				handle->dev->name, flg_inputboost_report_mt_touchmajor, flg_inputboost_report_abs_xy, inputboost_report_btn_toolfinger, inputboost_report_btn_touch, inputboost_report_mt_trackingid);
+#endif /* ZZMOOVE_DEBUG */
+		if (strstr(handle->dev->name, "touchscreen") || strstr(handle->dev->name, "synaptics")) {
+
+			// ff: don't boost if not enabled, or while sleeping
+			if (!boost_on_tsp || suspend_flag)
+				return;
+
+			// ff: save the event's data flags
+			flg_inputboost_mt_touchmajor = flg_inputboost_report_mt_touchmajor;
+			flg_inputboost_abs_xy = flg_inputboost_report_abs_xy;
+			inputboost_btn_toolfinger = inputboost_report_btn_toolfinger;
+			inputboost_btn_touch = inputboost_report_btn_touch;
+			inputboost_mt_trackingid = inputboost_report_mt_trackingid;
+
+			// ff: reset the event's data flags
+			flg_inputboost_report_mt_touchmajor = false;
+			flg_inputboost_report_abs_xy = false;
+			inputboost_report_btn_toolfinger = -1;
+			inputboost_report_btn_touch = -1;
+			inputboost_report_mt_trackingid = 0;
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove] syn input event. device: %s, saw_touchmajor: %d, saw_xy: %d, toolfinger: %d, touch: %d, trackingid: %d\n",
+					handle->dev->name, flg_inputboost_mt_touchmajor, flg_inputboost_abs_xy, inputboost_btn_toolfinger, inputboost_btn_touch, inputboost_mt_trackingid);
+#endif /* ZZMOOVE_DEBUG */
+			// ff: try to determine what kind of event we just saw
+			if (!flg_inputboost_mt_touchmajor
+				&& (flg_inputboost_abs_xy || inputboost_mt_trackingid < 0)
+				&& inputboost_btn_touch < 0) {
+				/*
+				 * ff: assume hovering since:
+				 *     no width was reported, and btn_touch isn't set, and (xy coords were included or trackingid is -1 meaning hover-up)
+				 */
+
+				 // ff: don't boost if not enabled
+				if (!boost_on_tsp_hover)
+					return;
+#ifdef ZZMOOVE_DEBUG
+				// ff: hover is hardcoded to only punch on first hover, otherwise it'd be punching constantly
+				if (inputboost_mt_trackingid > 0) {
+
+					pr_info("[zzmoove] touch - first hover btn_touch: %d\n", inputboost_btn_touch);
+					/*// ff: unused, but kept for future use
+					flg_do_punch_id = 4;
+					flg_force_punch = false;*/
+				} else if (inputboost_mt_trackingid < 0) {
+
+					pr_info("[zzmoove] touch - end hover btn_touch: %d\n", inputboost_btn_touch);
+					/*// ff: don't boost if not enabled, or while sleeping
+					flg_ctr_inputboost_punch = 0;
+					flg_ctr_inputboost = 0;*/
+				} else {
+					pr_info("[zzmoove] touch - update hover btn_touch: %d\n", inputboost_btn_touch);
+				}
+#endif /* ZZMOOVE_DEBUG */
+			} else if (inputboost_mt_trackingid > 0) {
+				// ff: new finger detected event
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove] touch - first touch\n");
+#endif /* ZZMOOVE_DEBUG */
+				flg_do_punch_id = 2;
+
+				// ff: should we boost on every finger down event?
+				if (dbs_tuners_ins.inputboost_punch_on_fingerdown)
+					flg_force_punch = true;
+
+				// ff: typing booster. detects rapid taps, and if found, boosts core count and up_threshold
+				if (dbs_tuners_ins.inputboost_typingbooster_up_threshold) {
+
+					// ff: save current time
+					do_gettimeofday(&time_now);
+
+					// ff: get time difference
+					time_since_typingbooster_lasttapped = (time_now.tv_sec - time_typingbooster_lasttapped.tv_sec) * MSEC_PER_SEC +
+										(time_now.tv_usec - time_typingbooster_lasttapped.tv_usec) / USEC_PER_MSEC;
+
+					// ff: was that typing or just a doubletap?
+					if (time_since_typingbooster_lasttapped < 250) {
+
+						// ff: tap is probably typing
+						ctr_inputboost_typingbooster_taps++;
+#ifdef ZZMOOVE_DEBUG
+						pr_info("[zzmoove] inputboost - typing booster - valid tap: %d\n", ctr_inputboost_typingbooster_taps);
+#endif /* ZZMOOVE_DEBUG */
+					} else {
+						// ff: tap too quick, probably a doubletap, ignore
+						ctr_inputboost_typingbooster_taps = 0;
+#ifdef ZZMOOVE_DEBUG
+						pr_info("[zzmoove] inputboost - typing booster - invalid tap: %d (age: %d)\n", ctr_inputboost_typingbooster_taps, time_since_typingbooster_lasttapped);
+#endif /* ZZMOOVE_DEBUG */
+					}
+
+					if ((flg_ctr_inputbooster_typingbooster < 1 && ctr_inputboost_typingbooster_taps > 1)			// ff: if booster wasn't on, require 3 taps
+						|| (flg_ctr_inputbooster_typingbooster > 0 && ctr_inputboost_typingbooster_taps > 0)) {		// ff: otherwise, refill with only 2
+#ifdef ZZMOOVE_DEBUG
+						// ff: probably typing, so start the typing booster
+						if (flg_ctr_inputbooster_typingbooster < 1)
+						    pr_info("[zzmoove] inputboost - typing booster on!\n");
+#endif /* ZZMOOVE_DEBUG */
+						// ff: set typing booster up_threshold counter
+						flg_ctr_inputbooster_typingbooster = 15;
+
+						// ff: request a punch
+						flg_do_punch_id = 12;
+
+						/*
+						 * ff: forcing this will effectively turn this into a touchbooster,
+						 *     as it will keep applying the punch freq until the typing (taps) stops
+						 */
+						flg_force_punch = true;
+
+#ifdef ZZMOOVE_DEBUG
+					} else {
+						pr_info("[zzmoove] inputboost - typing booster - tapctr: %d, flgctr: %d\n", ctr_inputboost_typingbooster_taps, flg_ctr_inputbooster_typingbooster);
+#endif /* ZZMOOVE_DEBUG */
+					}
+					// ff: and finally, set the time so we can compare to it on the next tap
+					do_gettimeofday(&time_typingbooster_lasttapped);
+				}
+
+#ifdef ZZMOOVE_DEBUG
+			} else if (inputboost_mt_trackingid < 0) {
+				// ff: finger-lifted event. do nothing
+				pr_info("[zzmoove] touch - end touch\n");
+#endif /* ZZMOOVE_DEBUG */
+			} else if (flg_inputboost_mt_touchmajor) {
+				// ff: width was reported, assume regular tap
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove] touch - update touch\n");
+#endif /* ZZMOOVE_DEBUG */
+				// ff: should we treat this like a touchbooster and always punch on movement?
+				if (dbs_tuners_ins.inputboost_punch_on_fingermove) {
+					flg_do_punch_id = 3;
+					flg_force_punch = true;
+				}
+
+			} else {
+				// ff: unknown event. do nothing
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove] touch - unknown\n");
+#endif /* ZZMOOVE_DEBUG */
+				return;
+			}
+
+		} else if (strstr(handle->dev->name, "gpio")) {
+
+			// ff: don't boost if not enabled, or while sleeping
+			if (!boost_on_gpio || suspend_flag)
+				return;
+
+			// ff: check for home button
+			if (inputboost_last_code == 172) {
+				if (suspend_flag) {
+					// ff: home press while suspended shouldn't boost as hard
+					flg_ctr_cpuboost = 2;
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove] inputboost - gpio punched freq immediately!\n");
+#endif /* ZZMOOVE_DEBUG */
+				} else {
+					// ff: home press while screen on should boost
+					flg_ctr_cpuboost = 10;
+#ifdef ENABLE_WORK_RESTARTLOOP
+					queue_work_on(0, dbs_aux_wq, &work_restartloop);
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove] inputboost - gpio punched freq immediately!\n");
+#endif /* ZZMOOVE_DEBUG */
+					// ff: don't punch, since we just did manually
+#endif /* ENABLE_WORK_RESTARTLOOP */
+				}
+			} else {
+				/*
+				 * ff: other press (aka vol up on note4)
+				 *     treat it as a normal button press
+				 */
+				flg_do_punch_id = 7;
+				flg_force_punch = true;
+			}
+
+		} else if (strstr(handle->dev->name, "touchkey")) {
+
+			// ff: don't boost if not enabled, or while sleeping
+			if (!boost_on_tk || suspend_flag)
+				return;
+
+			// ff: check for recents button
+			if (inputboost_last_code == 254) {
+				/*
+				 * ff: recents press. do more than punch,
+				 *     and set the max-boost and max-core counters, too
+				 */
+				flg_ctr_cpuboost = 20;
+			} else {
+				// ff: anything else (ie. back press)
+				flg_ctr_cpuboost = 3;
+			}
+
+			// ff: always manually punch for touchkeys
+#ifdef ENABLE_WORK_RESTARTLOOP
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove] inputboost - tk punched freq immediately!\n");
+#endif /* ZZMOOVE_DEBUG */
+			queue_work_on(0, dbs_aux_wq, &work_restartloop);
+#endif /* ENABLE_WORK_RESTARTLOOP */
+			// ff: don't punch, since we just did manually
+
+		} else if (strstr(handle->dev->name, "e-pen")) {
+			// ff: s-pen is hovering or writing
+
+			// ff: don't boost if not enabled, or while sleeping
+			if (!boost_on_epen || suspend_flag)
+				return;
+
+			// ff: request a punch
+			flg_do_punch_id = 11;
+
+			// ff: should we treat this like a touchbooster and always punch on movement?
+			if (dbs_tuners_ins.inputboost_punch_on_epenmove)
+				flg_force_punch = true;
+
+		} else if (strstr(handle->dev->name, "qpnp_pon")) {
+			// ff: on the note4/opo, this is the power key and volume down
+
+			/*
+			 * ff: only boost if power is press while screen-off
+			 *     let it still apply a normal boost on screen-on to speed up going into suspend
+			 */
+			if (inputboost_last_code == 116 && suspend_flag) {
+				// disabled since we're still boosting in the pon driver
+				/*flg_ctr_cpuboost = 25;
+				flg_ctr_inputboost = 100;
+				queue_work_on(0, dbs_aux_wq, &work_restartloop);
+				pr_info("[zzmoove] inputboost - gpio/powerkey punched freq immediately and skipped the rest\n");*/
+
+				// ff: not only don't punch, but don't even start the booster, since we just did both with zzmoove_boost() externally
+				return;
+			} else {
+				// ff: even though it's coming from a different device, treat this if it was a gpio event anyway
+				flg_do_punch_id = 7;
+				flg_force_punch = true;
+			}
+		}
+
+		if (flg_do_punch_id						// ff: punch is requested
+			&& dbs_tuners_ins.inputboost_punch_cycles		// ff: punch is enabled
+			&& dbs_tuners_ins.inputboost_punch_freq			// ff: punch is enabled
+			&& (flg_ctr_inputboost < 1 || flg_force_punch)) {	// ff: this is the first event since the inputbooster ran out, or it is forced
+										//     a punch length and frequency is set, so boost!
+			// ff: but only do so if it hasn't been punched yet, or if it hasn't been punched by a touch yet
+			// ff: save the punch counter state so we can avoid redundantly flushing the punch
+			tmp_flg_ctr_inputboost_punch = flg_ctr_inputboost_punch;
+
+			// ff: refill the punch counter. remember, flg_ctr_inputboost_punch is decremented before it is used, so add 1
+			flg_ctr_inputboost_punch = dbs_tuners_ins.inputboost_punch_cycles + 1;
+
+			// ff: don't immediately apply the punch if we're already boosted or punched
+#ifdef ENABLE_WORK_RESTARTLOOP
+			if (flg_ctr_cpuboost < 5 && tmp_flg_ctr_inputboost_punch < 1) {
+				queue_work_on(0, dbs_aux_wq, &work_restartloop);
+#endif /* ENABLE_WORK_RESTARTLOOP */
+#ifdef ZZMOOVE_DEBUG
+				do_gettimeofday(&time_touchbooster_lastrun);
+				pr_info("[zzmoove] inputboost - punched freq immediately for: %d\n", flg_do_punch_id);
+#endif /* ZZMOOVE_DEBUG */
+#ifdef ENABLE_WORK_RESTARTLOOP
+			}
+#endif /* ENABLE_WORK_RESTARTLOOP */
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove] inputboost - punch set to %d mhz for %d cycles (punched by: %d, forced: %d)\n",
+					dbs_tuners_ins.inputboost_punch_freq, dbs_tuners_ins.inputboost_punch_cycles, flg_do_punch_id, flg_force_punch);
+#endif /* ZZMOOVE_DEBUG */
+		}
+
+		// ff: refill the inputboost counter to apply the up_threshold
+		flg_ctr_inputboost = dbs_tuners_ins.inputboost_cycles;
+
+	} else {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove] ev input event. name: %s, type: %d, code: %d, value: %d\n", handle->dev->name, type, code, value);
+#endif /* ZZMOOVE_DEBUG */
+		// ff: we need to keep track of the data sent in this report
+		if (strstr(handle->dev->name, "touchscreen") || strstr(handle->dev->name, "synaptics")) {
+			if (code == BTN_TOOL_FINGER) {
+				// ff: 0 = nothing at all, 1 - touch OR hover starting
+				inputboost_report_btn_toolfinger = value;
+
+			} else if (code == BTN_TOUCH) {
+				// ff: 0 = up/hovering, 1 - touch starting
+				inputboost_report_btn_touch = value;
+
+			} else if (code == ABS_MT_TRACKING_ID) {
+				// ff: -1 = finger-up, >1 = finger-down
+				inputboost_report_mt_trackingid = value;
+#ifdef ABS_MT_SUMSIZE
+			} else if (code == ABS_MT_TOUCH_MAJOR || code == ABS_MT_SUMSIZE) {
+#else
+			} else if (code == ABS_MT_TOUCH_MAJOR) {
+#endif /* ABS_MT_SUMSIZE */
+				// ff: this is a touch report
+				flg_inputboost_report_mt_touchmajor = true;
+
+			} else if (code == ABS_MT_POSITION_X || code == ABS_MT_POSITION_Y) {
+				// ff: this is a hover report, maybe
+				flg_inputboost_report_abs_xy = true;
+			}
+		} else {
+			// ff: a simple saving of the last event is sufficent for non-tsp events
+			inputboost_last_type = type;
+			inputboost_last_code = code;
+			inputboost_last_value = value;
+		}
+	}
+}
+
+static int input_dev_filter(const char *input_dev_name)
+{
+	if (strstr(input_dev_name, "sec_touchscreen") ||
+		strstr(input_dev_name, "sec_e-pen") ||
+		strstr(input_dev_name, "gpio-keys") ||
+		strstr(input_dev_name, "sec_touchkey") ||
+		strstr(input_dev_name, "s2s_pwrkey") ||						// ZZ: opo power key?
+		strstr(input_dev_name, "msm8974-taiko-mtp-snd-card Button Jack") ||		// ZZ: opo sound button?
+		strstr(input_dev_name, "msm8974-taiko-mtp-snd-card Headset Jack") ||		// ZZ: opo headset jack
+		strstr(input_dev_name, "synaptics-rmi-ts") ||					// ZZ: opo touchscreen
+		strstr(input_dev_name, "qpnp_pon")						// ff: note4/opo power and volume-down key
+		//strstr(input_dev_name, "es705")						// ff: note4 always-on audio monitoring, but no input events are sent, so it's pointless
+		) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove] inputboost - monitoring input device: %s\n", input_dev_name);
+#endif /* ZZMOOVE_DEBUG */
+		return 0;
+
+	} else {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove] inputboost - ignored input device: %s\n", input_dev_name);
+#endif /* ZZMOOVE_DEBUG */
+		return 1;
+	}
+}
+
+static int interactive_input_connect(struct input_handler *handler, struct input_dev *dev, const struct input_device_id *id)
+{
+	struct input_handle *handle;
+	int error;
+
+	if (input_dev_filter(dev->name))
+		return -ENODEV;
+
+	handle = kzalloc(sizeof(struct input_handle), GFP_KERNEL);
+	if (!handle)
+		return -ENOMEM;
+
+	handle->dev = dev;
+	handle->handler = handler;
+	handle->name = "cpufreq";
+
+	error = input_register_handle(handle);
+	if (error)
+		goto err2;
+
+	error = input_open_device(handle);
+	if (error)
+		goto err1;
+
+	return 0;
+
+err1:
+	input_unregister_handle(handle);
+err2:
+	kfree(handle);
+	return error;
+}
+
+static void interactive_input_disconnect(struct input_handle *handle)
+{
+	// ff: reset counters
+	flg_ctr_inputboost = 0;
+	flg_ctr_inputboost_punch = 0;
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/interactive_input_disconnect] inputbooster - unregistering\n");
+#endif /* ZZMOOVE_DEBUG */
+	input_close_device(handle);
+	input_unregister_handle(handle);
+	kfree(handle);
+}
+
+static const struct input_device_id interactive_ids[] = {
+	{ .driver_info = 1 },
+	{ },
+};
+
+static struct input_handler interactive_input_handler = {
+	.event = interactive_input_event,
+	.connect = interactive_input_connect,
+	.disconnect = interactive_input_disconnect,
+	.name = "zzmoove",
+	.id_table = interactive_ids,
+};
+#endif /* ENABLE_INPUTBOOSTER */
+
+// Yank: return a valid value between min and max
+static int validate_min_max(int val, int min, int max)
+{
+	return min(max(val, min), max);
+}
+
+// ZZ: system table scaling mode with freq search optimizations and proportional freq option
+static inline int zz_get_next_freq(unsigned int curfreq, unsigned int updown, unsigned int load)
+{
+	int i = 0;
+	unsigned int prop_target = 0, zz_target = 0, dead_band_freq = 0;	// ZZ: proportional freq, system table freq, dead band freq
+	int smooth_up_steps = 0;						// Yank: smooth up steps
+	static int tmp_limit_table_start = 7;					// ff: give an arbitrary level
+	static int tmp_max_scaling_freq_soft = 7;
+
+	if (dbs_tuners_ins.scaling_proportional != 0)				// ZZ: if proportional scaling is enabled
+	    prop_target = pol_min + load * (pol_max - pol_min) / 100;		// ZZ: prepare proportional target freq whitout deadband (directly mapped to min->max load)
+
+	if (dbs_tuners_ins.scaling_proportional == 2)				// ZZ: mode '2' use proportional target frequencies only
+	    return prop_target;
+
+	if (dbs_tuners_ins.scaling_proportional == 3) {				// ZZ: mode '3' use proportional target frequencies only and switch to pol_min in deadband range
+	    dead_band_freq = pol_max / 100 * load;				// ZZ: use old calculation to get deadband frequencies (=lower than pol_min)
+	    if (dead_band_freq > pol_min)					// ZZ: the load usually is too unsteady so we rarely would reach pol_min when load is low
+		return prop_target;						// ZZ: in fact it only will happen when load=0, so only return proportional frequencies if they
+	    else								//     are out of deadband range and if we are in deadband range return min freq
+		return pol_min;							//     (thats a similar behaving as with old propotional freq calculation)
+	}
+
+	if (load <= dbs_tuners_ins.smooth_up)					// Yank: consider smooth up
+	    smooth_up_steps = 0;						// Yank: load not reached, move by one step
+	else
+	    smooth_up_steps = 1;						// Yank: load reached, move by two steps
+
+	tmp_limit_table_start = limit_table_start;
+	tmp_max_scaling_freq_soft = max_scaling_freq_soft;
+
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+#ifdef ENABLE_MUSIC_LIMITS
+	// ff: check to see if we need to override the screen-off limit with the music one
+	if (suspend_flag && dbs_tuners_ins.freq_limit_sleep
+	    && dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.music_max_freq
+	    && dbs_tuners_ins.music_state) {
+		tmp_limit_table_start = music_max_freq_step;
+		tmp_max_scaling_freq_soft = music_max_freq_step;
+	}
+#endif /* ENABLE_MUSIC_LIMITS */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+	// ZZ: feq search loop with optimization
+	if (freq_table_desc) {
+	    for (i = tmp_limit_table_start; (likely(system_freq_table[i].frequency != limit_table_end)); i++) {
+		if (unlikely(curfreq == system_freq_table[i].frequency)) {	// Yank: we found where we currently are (i)
+		    if (updown == 1) {						// Yank: scale up, but don't go above softlimit
+			zz_target = min(system_freq_table[tmp_max_scaling_freq_soft].frequency,
+		        system_freq_table[validate_min_max(i - 1 - smooth_up_steps - scaling_mode_up, 0, freq_table_size)].frequency);
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/zz_get_next_freq] desc - UP - val1: %d - val2: %d [steps: %d, smooth_up: %d, scaling_mode_up: %d]\n",
+				system_freq_table[tmp_max_scaling_freq_soft].frequency, system_freq_table[validate_min_max(i - 1 - smooth_up_steps - scaling_mode_up,
+				0, freq_table_size)].frequency, (1 + smooth_up_steps + scaling_mode_up), smooth_up_steps, scaling_mode_up);
+#endif /* ZZMOOVE_DEBUG */
+			if (dbs_tuners_ins.scaling_proportional == 1)		// ZZ: if proportional scaling is enabled
+			    return min(zz_target, prop_target);			// ZZ: check which freq is lower and return it
+			else
+			    return zz_target;					// ZZ: or return the found system table freq as usual
+		    } else {							// Yank: scale down, but don't go below min. freq.
+			zz_target = max(system_freq_table[min_scaling_freq].frequency,
+		        system_freq_table[validate_min_max(i + 1 + scaling_mode_down, 0, freq_table_size)].frequency);
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/zz_get_next_freq] desc - DOWN - val1: %d - val2: %d [steps: %d, scaling_mode_down: %d]\n",
+				system_freq_table[tmp_max_scaling_freq_soft].frequency, system_freq_table[validate_min_max(i + 1 + scaling_mode_down,
+				0, freq_table_size)].frequency, (1 + scaling_mode_down), scaling_mode_down);
+#endif /* ZZMOOVE_DEBUG */
+			if (dbs_tuners_ins.scaling_proportional == 1)		// ZZ: if proportional scaling is enabled
+			    return min(zz_target, prop_target);			// ZZ: check which freq is lower and return it
+			else
+			    return zz_target;					// ZZ: or return the found system table freq as usual
+		    }
+		    return prop_target;						// ZZ: this shouldn't happen but if the freq is not found in system table
+		}								//     fall back to proportional freq target to avoid stuck at current freq
+	    }
+	    return prop_target;							// ZZ: freq not found fallback to proportional freq target
+	} else {
+	    for (i = tmp_limit_table_start; (likely(system_freq_table[i].frequency <= limit_table_end)); i++) {
+		if (unlikely(curfreq == system_freq_table[i].frequency)) {	// Yank: we found where we currently are (i)
+		    if (updown == 1) {						// Yank: scale up, but don't go above softlimit
+			zz_target = min(system_freq_table[tmp_max_scaling_freq_soft].frequency,
+			system_freq_table[validate_min_max(i + 1 + smooth_up_steps + scaling_mode_up, 0, freq_table_size)].frequency);
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/zz_get_next_freq] asc - UP - val1: %d - val2: %d [steps: %d, smooth_up: %d, scaling_mode_up: %d]\n",
+				system_freq_table[tmp_max_scaling_freq_soft].frequency, system_freq_table[validate_min_max(i + 1 + smooth_up_steps + scaling_mode_up,
+				0, freq_table_size)].frequency, (1 + smooth_up_steps + scaling_mode_up), smooth_up_steps, scaling_mode_up);
+#endif /* ZZMOOVE_DEBUG */
+			if (dbs_tuners_ins.scaling_proportional == 1)		// ZZ: if proportional scaling is enabled
+			    return min(zz_target, prop_target);			// ZZ: check which freq is lower and return it
+			else
+			    return zz_target;					// ZZ: or return the found system table freq as usual
+		    } else {							// Yank: scale down, but don't go below min. freq.
+			zz_target = max(system_freq_table[min_scaling_freq].frequency,
+			system_freq_table[validate_min_max(i - 1 - scaling_mode_down, 0, freq_table_size)].frequency);
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/zz_get_next_freq] asc - DOWN - val1: %d - val2: %d [steps: %d, scaling_mode_down: %d]\n",
+				system_freq_table[min_scaling_freq].frequency, system_freq_table[validate_min_max(i - 1 - scaling_mode_down,
+				0, freq_table_size)].frequency, (1 + scaling_mode_down), scaling_mode_down);
+#endif /* ZZMOOVE_DEBUG */
+			if (dbs_tuners_ins.scaling_proportional == 1)		// ZZ: if proportional scaling is enabled
+			    return min(zz_target, prop_target);			// ZZ: check which freq is lower and return it
+			else
+			    return zz_target;					// ZZ: or return the found system table freq as usual
+		    }
+		    return prop_target;						// ZZ: this shouldn't happen but if the freq is not found in system table
+		}								//     fall back to proportional freq target to avoid stuck at current freq
+	    }
+	    return prop_target;							// ZZ: freq not found fallback to proportional freq target
+	}
+}
+
+#ifdef ENABLE_HOTPLUGGING
+// ZZ: function for enabling/disabling cores from offline/online state
+static inline void __cpuinit enable_disable_cores(void)
+{
+	int i = 0;
+
+	if (enable_cores == 1) {							// ZZ: no limit, all cores
+
+		for (i = 1; i < possible_cpus; i++) {					// ZZ: enable all offline cores
+		    if (!cpu_online(i))
+		    cpu_up(i);
+		}
+		enable_cores = 0;							// ZZ: reset enable flag again
+	}
+
+	if (enable_cores == 2) {							// ZZ: limit min cores
+		for (i = 1; i < num_possible_cpus(); i++) {
+#ifdef ENABLE_MUSIC_LIMITS
+		    if (!cpu_online(i) && (i < dbs_tuners_ins.hotplug_min_limit || (dbs_tuners_ins.music_state && i < dbs_tuners_ins.music_min_cores))
+#else
+		    if (!cpu_online(i) && (i < dbs_tuners_ins.hotplug_min_limit)
+#endif /* ENABLE_MUSIC_LIMITS */
+		    && (!dbs_tuners_ins.hotplug_max_limit || i < dbs_tuners_ins.hotplug_max_limit)) {
+			    // ff: this core is below the minimum, so bring it up
+			    cpu_up(i);
+#ifdef ZZMOOVE_DEBUG
+			    pr_info("[zzmoove] hotplug_min_limit: CPU%d forced up\n", i);
+#endif /* ZZMOOVE_DEBUG */
+		    }
+		}
+		enable_cores = 0;							// ZZ: reset disable flag again
+	}
+
+	if (disable_cores == 1) {							// ZZ: limit max cores
+		for (i = num_possible_cpus() - 1; i >= 1; i--) {
+		    if (cpu_online(i) && i >= dbs_tuners_ins.hotplug_max_limit && (!dbs_tuners_ins.hotplug_min_limit
+#ifdef ENABLE_MUSIC_LIMITS
+		    || i >= dbs_tuners_ins.hotplug_min_limit || (dbs_tuners_ins.music_state && (!dbs_tuners_ins.music_min_cores || i >= dbs_tuners_ins.music_min_cores)))) {
+#else
+		    || i >= dbs_tuners_ins.hotplug_min_limit)) {
+#endif /* ENABLE_MUSIC_LIMITS */
+			    // ff: this core is more than the limit, so turn it off, but don't go below hotplug_min_limit or music_min_cores
+			    cpu_down(i);
+#ifdef ZZMOOVE_DEBUG
+			    pr_info("[zzmoove] hotplug_max_limit: CPU%d forced down\n", i);
+#endif /* ZZMOOVE_DEBUG */
+		    }
+		}
+		disable_cores = 0;							// ZZ: reset disable flag again
+	}
+
+	if (disable_cores == 2) {							// ZZ: lock current cores
+		for (i = 1; i < num_possible_cpus(); i++) {
+			if (!cpu_online(i) && i < dbs_tuners_ins.hotplug_lock) {
+			    // ff: this core is less than the lock, so bring it up
+			    cpu_up(i);
+#ifdef ZZMOOVE_DEBUG
+			    pr_info("[zzmoove] hotplug_lock: CPU%d forced up\n", i);
+#endif /* ZZMOOVE_DEBUG */
+			} else if (cpu_online(i) && i >= dbs_tuners_ins.hotplug_lock) {
+			    // ff: this core is more than the lock, so turn it off
+			    cpu_down(i);
+#ifdef ZZMOOVE_DEBUG
+			    pr_info("[zzmoove] hotplug_lock: CPU%d forced down\n", i);
+#endif /* ZZMOOVE_DEBUG */
+			}
+		}
+		disable_cores = 0;							// ZZ: reset disable flag again
+	}
+}
+#endif /* ENABLE_HOTPLUGGING */
+
+#ifdef ENABLE_PROFILES_SUPPORT
+// ZZ: function for checking/adapting frequency values in tuneables
+static inline unsigned int check_frequency(unsigned int input_freq)
+{
+	int i, f;
+	unsigned int profile_relation = 0, system_min_freq = 0,
+	mid_freq = 0, found_freq = 0, adapted_freq = 0, calc_freq = 0,
+	system_max_freq = 0, next_freq = 0, max_freq_index = 0;
+
+	// ZZ: return if we have nothing to check
+	if (input_freq == 0)
+	    return 0;
+
+	// ZZ: normal checking if given frequency is already in system freq table
+	for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input_freq))
+		    found_freq = system_freq_table[i].frequency;
+	}
+
+	// ZZ: max freq index in table
+	max_freq_index = i - 1;
+
+	// ZZ: return if we already found a freq
+	if (found_freq != 0) {
+#ifdef ZZMOOVE_DEBUG
+	    pr_info("[zzmoove] check_freq: freq %d diretly found!\n", found_freq);
+#endif /* ZZMOOVE_DEBUG */
+	    return found_freq;
+	}
+
+	// ZZ: get highest/lowest freq in system table
+	if (!freq_table_desc) {
+	    system_max_freq = system_freq_table[max_freq_index].frequency;			// ZZ: ascending order so last freq is the max freq
+	    for (f = 0; (likely(system_freq_table[f].frequency != system_table_end)); f++) {	// ZZ: descending order so use the first available one as min freq
+		if (likely(system_freq_table[f].frequency != 0)) {
+		    system_min_freq = system_freq_table[f].frequency;
+#ifdef ZZMOOVE_DEBUG
+	    pr_info("[zzmoove] check_freq: minimal possible freq %d\n", system_min_freq);
+#endif /* ZZMOOVE_DEBUG */
+		    break;
+		}
+	    }
+	} else {
+	    system_min_freq = system_freq_table[max_freq_index].frequency;			// ZZ: ascending order so last freq is the min freq
+	    for (f = 0; (likely(system_freq_table[f].frequency != system_table_end)); f++) {	// ZZ: descending order so use the first available one as max freq
+		if (likely(system_freq_table[f].frequency != 0)) {
+		    system_max_freq = system_freq_table[f].frequency;
+#ifdef ZZMOOVE_DEBUG
+	    pr_info("[zzmoove] check_freq: maximal possible freq %d\n", system_max_freq);
+#endif /* ZZMOOVE_DEBUG */
+		    break;
+		}
+	    }
+	}
+
+	// ZZ: if we exceed limits return the max/min possible freq
+	if (input_freq > system_max_freq) {
+#ifdef ZZMOOVE_DEBUG
+	    pr_info("[zzmoove] check_freq: input freq too high switching to %d\n", system_max_freq);
+#endif /* ZZMOOVE_DEBUG */
+	    return system_max_freq;
+	} else if (input_freq < system_min_freq) {
+#ifdef ZZMOOVE_DEBUG
+	    pr_info("[zzmoove] check_freq: input freq too low switching to %d\n", system_min_freq);
+#endif /* ZZMOOVE_DEBUG */
+	    return system_min_freq;
+	}
+
+	// ZZ: if not found try to adapt frequency by using a per mille relation
+	// first reduce input value for calculation below
+	calc_freq = input_freq / 100;
+
+	/*
+	 * ZZ: calcualte relation in per mille to the max freq given in profile
+	 * and apply it on current system freq range, this gives some calculated freq
+	 */
+	profile_relation = ((calc_freq * 1000) / (PROFILE_MAX_FREQ / 100));
+	calc_freq = ((system_max_freq) / 1000) * profile_relation;
+
+	// ZZ: start searching in current system table
+	for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+
+		// ZZ: set where next freq is (table order)
+		if (!freq_table_desc) {
+		    next_freq = i + 1;
+		} else {
+		    next_freq = i - 1;
+		}
+
+		// ZZ: if the calculated freq is already a valid one, use it
+		if (system_freq_table[i].frequency == calc_freq || system_freq_table[next_freq].frequency == calc_freq)
+		    return calc_freq;
+
+		// ZZ: if not go on with adaptation
+		if (system_max_freq == PROFILE_MAX_FREQ) {				// ZZ: if we are in the same freq range
+											// ZZ: use input freq and if the given freq is between an existing freq pair
+			if (system_freq_table[i].frequency < input_freq && system_freq_table[next_freq].frequency > input_freq) {
+			    mid_freq = (system_freq_table[i].frequency + system_freq_table[next_freq].frequency) / 2;	// ZZ: calcualte the mid freq of that pair
+			    if (input_freq > mid_freq)					// ZZ: and decide if lower or higher value will be used
+				adapted_freq = system_freq_table[next_freq].frequency;	// ZZ: adapt freq to max in range
+			    else
+				adapted_freq = system_freq_table[i].frequency;		// ZZ: adapt freq to min in range
+			break;
+			}
+		} else {								// ZZ: we are on a different freq range so use calc freq
+			if (system_freq_table[i].frequency < calc_freq && system_freq_table[next_freq].frequency > calc_freq) {
+			    mid_freq = (system_freq_table[i].frequency + system_freq_table[next_freq].frequency) / 2;	// ZZ: calcualte the mid freq of that pair
+			    if (calc_freq > mid_freq)					// ZZ: and decide if lower or higher value will be used
+				adapted_freq = system_freq_table[next_freq].frequency;	// ZZ: adapt freq to max in range
+			    else
+				adapted_freq = system_freq_table[i].frequency;		// ZZ: adapt freq to min in range
+			break;
+			}
+		}
+	}
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove] check_freq: input freq was %d\n", input_freq);
+	pr_info("[zzmoove] check_freq: calculated freq is %d\n", calc_freq);
+	pr_info("[zzmoove] check_freq: relation to profile in per mille %d\n", profile_relation);
+	pr_info("[zzmoove] check_freq: lower freq %d on index %d", system_freq_table[i].frequency, i);
+	pr_info("[zzmoove] check_freq: higher freq %d on index %d", system_freq_table[next_freq].frequency, next_freq);
+	pr_info("[zzmoove] check_freq: found freq %d / mid freq %d / adapted freq %d\n", found_freq, mid_freq, adapted_freq);
+#endif /* ZZMOOVE_DEBUG */
+	if (adapted_freq != 0)								// ZZ: if freq was adapted
+	    return adapted_freq;							// ZZ: return adapted
+
+return 0;										// ZZ: freq not found = input out of range
+}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+// ZZ: function for frequency table order detection and limit optimization
+static inline void evaluate_scaling_order_limit_range(bool start, bool limit, bool suspend, unsigned int min_freq, unsigned int max_freq)
+{
+	int i = 0;
+	int calc_index = 0;
+	system_freq_table = cpufreq_frequency_get_table(0);			// ZZ: update static system frequency table
+
+	/*
+	 * ZZ: execute at start and at limit case and in combination with limit case 3 times
+	 * to catch all scaling max/min changes at/after gov start
+	 */
+	if (start || (limit && freq_init_count <= 1)) {
+
+	    // ZZ: initialisation of freq search in scaling table
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(max_freq == system_freq_table[i].frequency))
+		    max_scaling_freq_hard = max_scaling_freq_soft = i;		// ZZ: init soft and hard max value
+		if (unlikely(min_freq == system_freq_table[i].frequency))
+		    min_scaling_freq_hard = min_scaling_freq_soft = i;		// ZZ: init soft and hard min value
+		    // Yank: continue looping until table end is reached, we need this to set the table size limit below
+	    }
+
+	    freq_table_size = i - 1;						// Yank: upper index limit of freq. table
+
+	    /*
+	     * ZZ: we have to take care about where we are in the frequency table. when using kernel sources without OC capability
+	     * it might be that the first few indexes are containg no frequencies so a save index start point is needed.
+	     */
+	    calc_index = freq_table_size - max_scaling_freq_hard;		// ZZ: calculate the difference and use it as start point
+	    if (calc_index == freq_table_size)					// ZZ: if we are at the end of the table
+		calc_index = calc_index - 1;					// ZZ: shift in range for order calculation below
+
+	    // Yank: assert if CPU freq. table is in ascending or descending order
+	    if (system_freq_table[calc_index].frequency > system_freq_table[calc_index+1].frequency) {
+		freq_table_desc = true;						// Yank: table is in descending order as expected, lowest freq at the bottom of the table
+		min_scaling_freq = i - 1;					// Yank: last valid frequency step (lowest frequency)
+		limit_table_start = max_scaling_freq_soft;			// ZZ: we should use the actual max scaling soft limit value as search start point
+	    } else {
+		freq_table_desc = false;					// Yank: table is in ascending order, lowest freq at the top of the table
+		min_scaling_freq = 0;						// Yank: first valid frequency step (lowest frequency)
+		limit_table_start = min_scaling_freq_soft;			// ZZ: we should use the actual min scaling soft limit value as search start point
+		limit_table_end = system_freq_table[freq_table_size].frequency;	// ZZ: end searching at highest frequency limit
+	    }
+	}
+
+	// ZZ: execute at limit case but not at suspend and in combination with start case 3 times at/after gov start
+	if ((limit && !suspend) || (limit && freq_init_count <= 1)) {
+
+	    /*
+	     * ZZ: obviously the 'limit case' will be executed multiple times at suspend for 'sanity' checks or boosts
+	     * but we have already a early suspend code to handle scaling search limits so we have to differentiate
+	     * to avoid double execution at suspend!
+	     */
+	    if (max_freq != system_freq_table[max_scaling_freq_hard].frequency) {	// Yank: if policy->max has changed...
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		    if (unlikely(max_freq == system_freq_table[i].frequency)) {
+			max_scaling_freq_hard = i;					// ZZ: ...set new freq scaling index
+			break;
+		    }
+		}
+	    }
+
+	    if (!freq_table_desc) {							// ZZ: if ascending ordered table is used
+		if (min_freq != system_freq_table[min_scaling_freq_hard].frequency) {	// ZZ: and policy->min has changed...
+		    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+			if (unlikely(min_freq == system_freq_table[i].frequency)) {
+			    min_scaling_freq_hard = limit_table_start = i;		// ZZ: ...set new freq scaling index
+			    if (min_scaling_freq_soft && (max_scaling_freq_hard < min_scaling_freq_soft))	// ZZ: if max hard limit is lower than min soft limit
+				limit_table_start = 0;					// ZZ: reset min index
+			    if (min_scaling_freq_soft && (min_scaling_freq_hard > min_scaling_freq_soft)) {	// ZZ: if min hard limit is higher than min soft limit
+				limit_table_start = min_scaling_freq_hard;		// ZZ: use min hard index
+			    } else if (min_scaling_freq_soft && (min_scaling_freq_hard < min_scaling_freq_soft)) {
+				limit_table_start = min_scaling_freq_soft;		// ZZ: use min soft index
+			    }
+			break;
+			}
+		    }
+		}
+	    }
+
+	    if (dbs_tuners_ins.freq_limit == 0 ||					// Yank: if there is no awake freq. limit
+		dbs_tuners_ins.freq_limit > system_freq_table[max_scaling_freq_hard].frequency) {	// Yank: or it is higher than hard max frequency
+		max_scaling_freq_soft = max_scaling_freq_hard;				// Yank: use hard max frequency
+		if (freq_table_desc)							// ZZ: if descending ordered table is used
+		    limit_table_start = max_scaling_freq_soft;				// ZZ: we should use the actual scaling soft limit value as search start point
+		else
+		    limit_table_end = system_freq_table[freq_table_size].frequency;	// ZZ: set search end point to max frequency when using ascending table
+	    } else {
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		    if (unlikely(dbs_tuners_ins.freq_limit == system_freq_table[i].frequency)) {	// Yank: else lookup awake max. frequency index
+			max_scaling_freq_soft = i;
+			if (freq_table_desc)						// ZZ: if descending ordered table is used
+			    limit_table_start = max_scaling_freq_soft;			// ZZ: we should use the actual scaling soft limit value as search start point
+			else
+			    limit_table_end = system_freq_table[i].frequency;		// ZZ: set search end point to soft freq limit when using ascending table
+		    break;
+		    }
+		}
+	    }
+	    if (freq_init_count < 2)							// ZZ: execute start and limit part together 3 times to catch a possible setting of
+	    freq_init_count++;								// ZZ: hard freq limit after gov start - after that skip 'start' part during
+	}										// ZZ: normal operation and use only limit part to adjust limit optimizations
+
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	// ZZ: execute only at suspend but not at limit case
+	if (suspend && !limit) {							// ZZ: only if we are at suspend
+	    if (freq_limit_asleep == 0 ||						// Yank: if there is no sleep frequency limit
+		freq_limit_asleep > system_freq_table[max_scaling_freq_hard].frequency) {	// Yank: or it is higher than hard max frequency
+		max_scaling_freq_soft = max_scaling_freq_hard;				// Yank: use hard max frequency
+		if (freq_table_desc)							// ZZ: if descending ordered table is used
+		    limit_table_start = max_scaling_freq_soft;				// ZZ: we should use the actual scaling soft limit value as search start point
+		else
+		    limit_table_end = system_freq_table[freq_table_size].frequency;	// ZZ: set search end point to max freq when using ascending table
+	    } else {
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		    if (unlikely(freq_limit_asleep == system_freq_table[i].frequency)) {	// Yank: else lookup sleep max. frequency index
+			max_scaling_freq_soft = i;
+			if (freq_table_desc)						// ZZ: if descending ordered table is used
+			    limit_table_start = max_scaling_freq_soft;			// ZZ: we should use the actual scaling soft limit value as search start point
+			else
+			    limit_table_end = system_freq_table[i].frequency;		// ZZ: set search end point to max frequency when using ascending table
+		    break;
+		    }
+		}
+	    }
+	}
+
+	// ZZ: execute only at resume but not at limit or start case
+	if (!suspend && !limit && !start) {						// ZZ: only if we are not at suspend
+	    if (freq_limit_awake == 0 ||						// Yank: if there is no awake frequency limit
+		freq_limit_awake > system_freq_table[max_scaling_freq_hard].frequency) {	// Yank: or it is higher than hard max frequency
+		max_scaling_freq_soft = max_scaling_freq_hard;				// Yank: use hard max frequency
+		if (freq_table_desc)							// ZZ: if descending ordered table is used
+		    limit_table_start = max_scaling_freq_soft;				// ZZ: we should use the actual scaling soft limit value as search start point
+		else
+		    limit_table_end = system_freq_table[freq_table_size].frequency;	// ZZ: set search end point to max freq when using ascending table
+	    } else {
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		    if (unlikely(freq_limit_awake == system_freq_table[i].frequency)) {		// Yank: else lookup awake max. frequency index
+			max_scaling_freq_soft = i;
+			if (freq_table_desc)						// ZZ: if descending ordered table is used
+			    limit_table_start = max_scaling_freq_soft;			// ZZ: we should use the actual scaling soft limit value as search start point
+			else
+			    limit_table_end = system_freq_table[i].frequency;		// ZZ: set search end point to soft freq limit when using ascending table
+		    break;
+		    }
+		}
+	    }
+	}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+}
+
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+// ZZ: function for auto adjusting frequency thresholds if max policy has changed
+static inline void adjust_freq_thresholds(unsigned int step)
+{
+	if (dbs_tuners_ins.auto_adjust_freq_thresholds != 0 && step != 0 && freq_init_count > 0) {	// ZZ: start adjusting if enabled and after freq search is ready initialized
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: adjust hotplug engage freq
+		if (dbs_tuners_ins.hotplug_engage_freq != 0) {						// ZZ: adjust only if tuneable is set
+		    if ((dbs_tuners_ins.hotplug_engage_freq + step < pol_min
+			|| dbs_tuners_ins.hotplug_engage_freq + step > pol_max)
+			&& !temp_hotplug_engage_freq_flag) {						// ZZ: check if we would go under/over limits
+			temp_hotplug_engage_freq = dbs_tuners_ins.hotplug_engage_freq + step;		// ZZ: if so do it temporary but do not save tuneable yet
+			temp_hotplug_engage_freq_flag = true;						// ZZ: set temp saving flag
+		    } else if (temp_hotplug_engage_freq_flag) {						// ZZ: last time we were under/over limits
+			if (temp_hotplug_engage_freq + step < pol_min
+			    || temp_hotplug_engage_freq + step > pol_max) {				// ZZ: and if we are still there
+			    temp_hotplug_engage_freq = temp_hotplug_engage_freq + step;			// ZZ: add step to temp var instead of tuneable var
+			} else {
+			    dbs_tuners_ins.hotplug_engage_freq = temp_hotplug_engage_freq + step;	// ZZ: else use it as offset for next step and finally save it in tuneable
+			    temp_hotplug_engage_freq = 0;						// ZZ: reset temp var
+			    temp_hotplug_engage_freq_flag = false;					// ZZ: reset temp flag
+			}
+		    } else {
+			dbs_tuners_ins.hotplug_engage_freq += step;					// ZZ: or change it directly in the tuneable if we are in good range
+		    }
+		}
+
+		// ZZ: adjust hotplug idle freq
+		if (dbs_tuners_ins.hotplug_idle_freq != 0) {
+		    if ((dbs_tuners_ins.hotplug_idle_freq + step < pol_min
+			|| dbs_tuners_ins.hotplug_idle_freq + step > pol_max)
+			&& !temp_hotplug_idle_freq_flag) {
+			temp_hotplug_idle_freq = dbs_tuners_ins.hotplug_idle_freq + step;
+			temp_hotplug_idle_freq_flag = true;
+		    } else if (temp_hotplug_idle_freq_flag) {
+			if (temp_hotplug_idle_freq + step < pol_min
+			    || temp_hotplug_idle_freq + step > pol_max) {
+			    temp_hotplug_idle_freq = temp_hotplug_idle_freq + step;
+			} else {
+			    dbs_tuners_ins.hotplug_idle_freq = temp_hotplug_idle_freq + step;
+			    temp_hotplug_idle_freq = 0;
+			    temp_hotplug_idle_freq_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.hotplug_idle_freq += step;
+		    }
+		}
+#endif /* ENABLE_HOTPLUGGING */
+#ifdef ENABLE_INPUTBOOSTER
+		// ZZ: adjust inputboost punch freq
+		if (dbs_tuners_ins.inputboost_punch_freq != 0) {
+		    if ((dbs_tuners_ins.inputboost_punch_freq + step < pol_min
+			|| dbs_tuners_ins.inputboost_punch_freq + step > pol_max)
+			&& !temp_inputboost_punch_freq_flag) {
+			temp_inputboost_punch_freq = dbs_tuners_ins.inputboost_punch_freq + step;
+			temp_inputboost_punch_freq_flag = true;
+		    } else if (temp_inputboost_punch_freq_flag) {
+			if (temp_inputboost_punch_freq + step < pol_min
+			    || temp_inputboost_punch_freq + step > pol_max) {
+			    temp_inputboost_punch_freq = temp_inputboost_punch_freq + step;
+			} else {
+			    dbs_tuners_ins.inputboost_punch_freq = temp_inputboost_punch_freq + step;
+			    temp_inputboost_punch_freq = 0;
+			    temp_inputboost_punch_freq = false;
+			}
+		    } else {
+			dbs_tuners_ins.inputboost_punch_freq += step;
+		    }
+		}
+#endif /* ENABLE_INPUTBOOSTER */
+		// ZZ: adjust scaling block freq
+		if (dbs_tuners_ins.scaling_block_freq != 0) {
+		    if ((dbs_tuners_ins.scaling_block_freq + step < pol_min
+			|| dbs_tuners_ins.scaling_block_freq + step > pol_max)
+			&& !temp_scaling_block_freq_flag) {
+			temp_scaling_block_freq = dbs_tuners_ins.scaling_block_freq + step;
+			temp_scaling_block_freq_flag = true;
+		    } else if (temp_scaling_block_freq_flag) {
+			if (temp_scaling_block_freq + step < pol_min
+			    || temp_scaling_block_freq + step > pol_max) {
+			    temp_scaling_block_freq = temp_scaling_block_freq + step;
+			} else {
+			    dbs_tuners_ins.scaling_block_freq = temp_scaling_block_freq + step;
+			    temp_scaling_block_freq = 0;
+			    temp_scaling_block_freq_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.scaling_block_freq += step;
+		    }
+		}
+
+		// ZZ: adjust scaling fastdown freq
+		if (dbs_tuners_ins.scaling_fastdown_freq != 0) {
+		    if ((dbs_tuners_ins.scaling_fastdown_freq + step < pol_min
+			|| dbs_tuners_ins.scaling_fastdown_freq + step > pol_max)
+			&& !temp_scaling_fastdown_freq_flag) {
+			temp_scaling_fastdown_freq = dbs_tuners_ins.scaling_fastdown_freq + step;
+			temp_scaling_fastdown_freq_flag = true;
+		    } else if (temp_scaling_fastdown_freq_flag) {
+			if (temp_scaling_fastdown_freq + step < pol_min
+			    || temp_scaling_fastdown_freq + step > pol_max) {
+			    temp_scaling_fastdown_freq = temp_scaling_fastdown_freq + step;
+			} else {
+			    dbs_tuners_ins.scaling_fastdown_freq = temp_scaling_fastdown_freq + step;
+			    temp_scaling_fastdown_freq = 0;
+			    temp_scaling_fastdown_freq_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.scaling_fastdown_freq += step;
+		    }
+		}
+
+		// ZZ: adjust scaling responsiveness freq
+		if (dbs_tuners_ins.scaling_responsiveness_freq != 0) {
+		    if ((dbs_tuners_ins.scaling_responsiveness_freq + step < pol_min
+			|| dbs_tuners_ins.scaling_responsiveness_freq + step > pol_max)
+			&& !temp_scaling_responsiveness_freq_flag) {
+			temp_scaling_responsiveness_freq = dbs_tuners_ins.scaling_responsiveness_freq + step;
+			temp_scaling_responsiveness_freq_flag = true;
+		    } else if (temp_scaling_responsiveness_freq_flag) {
+			if (temp_scaling_responsiveness_freq + step < pol_min
+			    || temp_scaling_responsiveness_freq + step > pol_max) {
+			    temp_scaling_responsiveness_freq = temp_scaling_responsiveness_freq + step;
+			} else {
+			    dbs_tuners_ins.scaling_responsiveness_freq = temp_scaling_responsiveness_freq + step;
+			    temp_scaling_responsiveness_freq = 0;
+			    temp_scaling_responsiveness_freq_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.scaling_responsiveness_freq += step;
+		    }
+		}
+#ifdef ENABLE_MUSIC_LIMITS
+		// ZZ: adjust music min freq
+		if (dbs_tuners_ins.music_min_freq != 0) {
+		    if ((dbs_tuners_ins.music_min_freq + step < pol_min
+			|| dbs_tuners_ins.music_min_freq + step > pol_max)
+			&& !temp_music_min_freq_flag) {
+			temp_music_min_freq = dbs_tuners_ins.music_min_freq + step;
+			temp_music_min_freq_flag = true;
+		    } else if (temp_music_min_freq_flag) {
+			if (temp_music_min_freq + step < pol_min
+			    || temp_music_min_freq + step > pol_max) {
+			    temp_music_min_freq = temp_music_min_freq + step;
+			} else {
+			    dbs_tuners_ins.music_min_freq = temp_music_min_freq + step;
+			    temp_music_min_freq = 0;
+			    temp_music_min_freq = false;
+			}
+		    } else {
+			dbs_tuners_ins.music_min_freq += step;
+		    }
+		}
+
+		// ZZ: adjust music max freq
+		if (dbs_tuners_ins.music_max_freq != 0) {
+		    if ((dbs_tuners_ins.music_max_freq + step < pol_min
+			|| dbs_tuners_ins.music_max_freq + step > pol_max)
+			&& !temp_music_max_freq_flag) {
+			temp_music_max_freq = dbs_tuners_ins.music_max_freq + step;
+			temp_music_max_freq_flag = true;
+		    } else if (temp_music_max_freq_flag) {
+			if (temp_music_max_freq + step < pol_min
+			    || temp_music_max_freq + step > pol_max) {
+			    temp_music_max_freq = temp_music_max_freq + step;
+			} else {
+			    dbs_tuners_ins.music_max_freq = temp_music_max_freq + step;
+			    temp_music_max_freq = 0;
+			    temp_music_max_freq = false;
+			}
+		    } else {
+			dbs_tuners_ins.music_max_freq += step;
+		    }
+		}
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: adjust up threshold hotplug freq1
+		if (dbs_tuners_ins.up_threshold_hotplug_freq1 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq1 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq1 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq1_flag) {
+			temp_up_threshold_hotplug_freq1 = dbs_tuners_ins.up_threshold_hotplug_freq1 + step;
+			temp_up_threshold_hotplug_freq1_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq1_flag) {
+			if (temp_up_threshold_hotplug_freq1 + step < pol_min
+			    || temp_up_threshold_hotplug_freq1 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq1 = temp_up_threshold_hotplug_freq1 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq1 = temp_up_threshold_hotplug_freq1 + step;
+			    temp_up_threshold_hotplug_freq1 = 0;
+			    temp_up_threshold_hotplug_freq1_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq1 += step;
+		    }
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: adjust up threshold hotplug freq2
+		if (dbs_tuners_ins.up_threshold_hotplug_freq2 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq2 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq2 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq2_flag) {
+			temp_up_threshold_hotplug_freq2 = dbs_tuners_ins.up_threshold_hotplug_freq2 + step;
+			temp_up_threshold_hotplug_freq2_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq2_flag) {
+			if (temp_up_threshold_hotplug_freq2 + step < pol_min
+			    || temp_up_threshold_hotplug_freq2 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq2 = temp_up_threshold_hotplug_freq2 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq2 = temp_up_threshold_hotplug_freq2 + step;
+			    temp_up_threshold_hotplug_freq2 = 0;
+			    temp_up_threshold_hotplug_freq2_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq2 += step;
+		    }
+		}
+
+		// ZZ: adjust up threshold hotplug freq3
+		if (dbs_tuners_ins.up_threshold_hotplug_freq3 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq3 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq3 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq3_flag) {
+			temp_up_threshold_hotplug_freq3 = dbs_tuners_ins.up_threshold_hotplug_freq3 + step;
+			temp_up_threshold_hotplug_freq3_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq3_flag) {
+			if (temp_up_threshold_hotplug_freq3 + step < pol_min
+			    || temp_up_threshold_hotplug_freq3 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq3 = temp_up_threshold_hotplug_freq3 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq3 = temp_up_threshold_hotplug_freq3 + step;
+			    temp_up_threshold_hotplug_freq3 = 0;
+			    temp_up_threshold_hotplug_freq3_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq3 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: adjust up threshold hotplug freq4
+		if (dbs_tuners_ins.up_threshold_hotplug_freq4 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq4 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq4 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq4_flag) {
+			temp_up_threshold_hotplug_freq4 = dbs_tuners_ins.up_threshold_hotplug_freq4 + step;
+			temp_up_threshold_hotplug_freq4_flag = true;
+		    } else if (!temp_up_threshold_hotplug_freq4) {
+			if (temp_up_threshold_hotplug_freq4 + step < pol_min
+			    || temp_up_threshold_hotplug_freq4 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq4 = temp_up_threshold_hotplug_freq4 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq4 = temp_up_threshold_hotplug_freq4 + step;
+			    temp_up_threshold_hotplug_freq4 = 0;
+			    temp_up_threshold_hotplug_freq4_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq4 += step;
+		    }
+		}
+
+		// ZZ: adjust up threshold hotplug freq5
+		if (dbs_tuners_ins.up_threshold_hotplug_freq5 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq5 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq5 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq5_flag) {
+			temp_up_threshold_hotplug_freq5 = dbs_tuners_ins.up_threshold_hotplug_freq5 + step;
+			temp_up_threshold_hotplug_freq5_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq5_flag) {
+			if (temp_up_threshold_hotplug_freq5 + step < pol_min
+			    || temp_up_threshold_hotplug_freq5 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq5 = temp_up_threshold_hotplug_freq5 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq5 = temp_up_threshold_hotplug_freq5 + step;
+			    temp_up_threshold_hotplug_freq5 = 0;
+			    temp_up_threshold_hotplug_freq5_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq5 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ZZ: adjust up threshold hotplug freq6
+		if (dbs_tuners_ins.up_threshold_hotplug_freq6 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq6 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq6 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq6_flag) {
+			temp_up_threshold_hotplug_freq6 = dbs_tuners_ins.up_threshold_hotplug_freq6 + step;
+			temp_up_threshold_hotplug_freq6_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq6_flag) {
+			if (temp_up_threshold_hotplug_freq6 + step < pol_min
+			    || temp_up_threshold_hotplug_freq6 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq6 = temp_up_threshold_hotplug_freq6 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq6 = temp_up_threshold_hotplug_freq6 + step;
+			    temp_up_threshold_hotplug_freq6 = 0;
+			    temp_up_threshold_hotplug_freq6_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq6 += step;
+		    }
+		}
+
+		// ZZ: adjust up threshold hotplug freq7
+		if (dbs_tuners_ins.up_threshold_hotplug_freq7 != 0) {
+		    if ((dbs_tuners_ins.up_threshold_hotplug_freq7 + step < pol_min
+			|| dbs_tuners_ins.up_threshold_hotplug_freq7 + step > pol_max)
+			&& !temp_up_threshold_hotplug_freq7_flag) {
+			temp_up_threshold_hotplug_freq7 = dbs_tuners_ins.up_threshold_hotplug_freq7 + step;
+			temp_up_threshold_hotplug_freq7_flag = true;
+		    } else if (temp_up_threshold_hotplug_freq7_flag) {
+			if (temp_up_threshold_hotplug_freq7 + step < pol_min
+			    || temp_up_threshold_hotplug_freq7 + step > pol_max) {
+			    temp_up_threshold_hotplug_freq7 = temp_up_threshold_hotplug_freq7 + step;
+			} else {
+			    dbs_tuners_ins.up_threshold_hotplug_freq7 = temp_up_threshold_hotplug_freq7 + step;
+			    temp_up_threshold_hotplug_freq7 = 0;
+			    temp_up_threshold_hotplug_freq7_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.up_threshold_hotplug_freq7 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 8) */
+		// ZZ: adjust down threshold hotplug freq1
+		if (dbs_tuners_ins.down_threshold_hotplug_freq1 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq1 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq1 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq1_flag) {
+			temp_down_threshold_hotplug_freq1 = dbs_tuners_ins.down_threshold_hotplug_freq1 + step;
+			temp_down_threshold_hotplug_freq1_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq1_flag) {
+			if (temp_down_threshold_hotplug_freq1 + step < pol_min
+			    || temp_down_threshold_hotplug_freq1 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq1 = temp_down_threshold_hotplug_freq1 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq1 = temp_down_threshold_hotplug_freq1 + step;
+			    temp_down_threshold_hotplug_freq1 = 0;
+			    temp_down_threshold_hotplug_freq1_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq1 += step;
+		    }
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: adjust down threshold hotplug freq2
+		if (dbs_tuners_ins.down_threshold_hotplug_freq2 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq2 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq2 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq2_flag) {
+			temp_down_threshold_hotplug_freq2 = dbs_tuners_ins.down_threshold_hotplug_freq2 + step;
+			temp_down_threshold_hotplug_freq2_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq2_flag) {
+			if (temp_down_threshold_hotplug_freq2 + step < pol_min
+			    || temp_down_threshold_hotplug_freq2 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq2 = temp_down_threshold_hotplug_freq2 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq2 = temp_down_threshold_hotplug_freq2 + step;
+			    temp_down_threshold_hotplug_freq2 = 0;
+			    temp_down_threshold_hotplug_freq2_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq2 += step;
+		    }
+		}
+
+		// ZZ: adjust down threshold hotplug freq3
+		if (dbs_tuners_ins.down_threshold_hotplug_freq3 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq3 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq3 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq3_flag) {
+			temp_down_threshold_hotplug_freq3 = dbs_tuners_ins.down_threshold_hotplug_freq3 + step;
+			temp_down_threshold_hotplug_freq3_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq3_flag) {
+			if (temp_down_threshold_hotplug_freq3 + step < pol_min
+			    || temp_down_threshold_hotplug_freq3 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq3 = temp_down_threshold_hotplug_freq3 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq3 = temp_down_threshold_hotplug_freq3 + step;
+			    temp_down_threshold_hotplug_freq3 = 0;
+			    temp_down_threshold_hotplug_freq3_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq3 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: adjust down threshold hotplug freq4
+		if (dbs_tuners_ins.down_threshold_hotplug_freq4 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq4 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq4 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq4_flag) {
+			temp_down_threshold_hotplug_freq4 = dbs_tuners_ins.down_threshold_hotplug_freq4 + step;
+			temp_down_threshold_hotplug_freq4_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq4_flag) {
+			if (temp_down_threshold_hotplug_freq4 + step < pol_min
+			    || temp_down_threshold_hotplug_freq4 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq4 = temp_down_threshold_hotplug_freq4 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq4 = temp_down_threshold_hotplug_freq4 + step;
+			    temp_down_threshold_hotplug_freq4 = 0;
+			    temp_down_threshold_hotplug_freq4_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq4 += step;
+		    }
+		}
+
+		// ZZ: adjust down threshold hotplug freq5
+		if (dbs_tuners_ins.down_threshold_hotplug_freq5 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq5 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq5 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq5_flag) {
+			temp_down_threshold_hotplug_freq5 = dbs_tuners_ins.down_threshold_hotplug_freq5 + step;
+			temp_down_threshold_hotplug_freq5_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq5_flag) {
+			if (temp_down_threshold_hotplug_freq5 + step < pol_min
+			    || temp_down_threshold_hotplug_freq5 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq5 = temp_down_threshold_hotplug_freq5 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq5 = temp_down_threshold_hotplug_freq5 + step;
+			    temp_down_threshold_hotplug_freq5 = 0;
+			    temp_down_threshold_hotplug_freq5_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq5 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ZZ: adjust down threshold hotplug freq6
+		if (dbs_tuners_ins.down_threshold_hotplug_freq6 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq6 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq6 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq6_flag) {
+			temp_down_threshold_hotplug_freq6 = dbs_tuners_ins.down_threshold_hotplug_freq6 + step;
+			temp_down_threshold_hotplug_freq6_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq6_flag) {
+			if (temp_down_threshold_hotplug_freq6 + step < pol_min
+			    || temp_down_threshold_hotplug_freq6 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq6 = temp_down_threshold_hotplug_freq6 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq6 = temp_down_threshold_hotplug_freq6 + step;
+			    temp_down_threshold_hotplug_freq6 = 0;
+			    temp_down_threshold_hotplug_freq6_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq6 += step;
+		    }
+		}
+
+		// ZZ: adjust down threshold hotplug freq7
+		if (dbs_tuners_ins.down_threshold_hotplug_freq7 != 0) {
+		    if ((dbs_tuners_ins.down_threshold_hotplug_freq7 + step < pol_min
+			|| dbs_tuners_ins.down_threshold_hotplug_freq7 + step > pol_max)
+			&& !temp_down_threshold_hotplug_freq7_flag) {
+			temp_down_threshold_hotplug_freq7 = dbs_tuners_ins.down_threshold_hotplug_freq7 + step;
+			temp_down_threshold_hotplug_freq7_flag = true;
+		    } else if (temp_down_threshold_hotplug_freq7_flag) {
+			if (temp_down_threshold_hotplug_freq7 + step < pol_min
+			    || temp_down_threshold_hotplug_freq7 + step > pol_max) {
+			    temp_down_threshold_hotplug_freq7 = temp_down_threshold_hotplug_freq7 + step;
+			} else {
+			    dbs_tuners_ins.down_threshold_hotplug_freq7 = temp_down_threshold_hotplug_freq7 + step;
+			    temp_down_threshold_hotplug_freq7 = 0;
+			    temp_down_threshold_hotplug_freq7_flag = false;
+			}
+		    } else {
+			dbs_tuners_ins.down_threshold_hotplug_freq7 += step;
+		    }
+		}
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+	}
+#ifdef ENABLE_HOTPLUGGING
+		/*
+		 * ZZ: check if maximal/min freq is lower/higher than any hotplug freq thresholds,
+		 * if so mark the affected freq threshold as out of range via a flag and fall back
+		 * to the corresponding load threshold - this keeps hotplugging working properly
+		 */
+		if (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq1
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq1
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq1
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq1
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq1)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][0] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][0] = 0;
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq2
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq2
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq2
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq2
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq2)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][1] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][1] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq3
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq3
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq3
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq3
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq3)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][2] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][2] = 0;
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq4
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq4
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq4
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq4
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq4)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][3] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][3] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq5
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq5
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq5
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq5
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq5)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][4] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][4] = 0;
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq6
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq6
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq6
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq6
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq6)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][5] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][5] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.up_threshold_hotplug_freq7
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.up_threshold_hotplug_freq7
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.up_threshold_hotplug_freq7
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.up_threshold_hotplug_freq7
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.up_threshold_hotplug_freq7)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[0][6] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[0][6] = 0;
+		}
+#endif /* (MAX_CORES == 8) */
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq1
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq1
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq1
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq1
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq1)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][0] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][0] = 0;
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq2
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq2
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq2
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq2
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq2 )) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][1] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][1] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq3
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq3
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq3
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq3
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq3)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][2] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][2] = 0;
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq4
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq4
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq4
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq4
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq4)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][3] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][3] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq5
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq5
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq5
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq5
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq5)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][4] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][4] = 0;
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq6
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq6
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq6
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq6
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq6)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][5] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][5] = 0;
+		}
+
+		if  (unlikely(pol_max < dbs_tuners_ins.down_threshold_hotplug_freq7
+		    || dbs_tuners_ins.freq_limit < dbs_tuners_ins.down_threshold_hotplug_freq7
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    || dbs_tuners_ins.freq_limit_sleep < dbs_tuners_ins.down_threshold_hotplug_freq7
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_MUSIC_LIMITS
+		    || dbs_tuners_ins.music_max_freq < dbs_tuners_ins.down_threshold_hotplug_freq7
+		    || dbs_tuners_ins.music_min_freq > dbs_tuners_ins.down_threshold_hotplug_freq7)) {
+#else
+		    )) {
+#endif /* ENABLE_MUSIC_LIMITS */
+		    hotplug_freq_threshold_out_of_range[1][6] = 1;
+		} else {
+		    hotplug_freq_threshold_out_of_range[1][6] = 0;
+		}
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+}
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+
+// ZZ: compatibility with kernel version lower than 3.4
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,4,0)
+static inline u64 get_cpu_idle_time_jiffy(unsigned int cpu, u64 *wall)
+{
+	u64 idle_time;
+	u64 cur_wall_time;
+	u64 busy_time;
+
+	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+	busy_time = cputime64_add(kstat_cpu(cpu).cpustat.user,
+			kstat_cpu(cpu).cpustat.system);
+
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.irq);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.softirq);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.steal);
+	busy_time = cputime64_add(busy_time, kstat_cpu(cpu).cpustat.nice);
+
+	idle_time = cputime64_sub(cur_wall_time, busy_time);
+	if (wall)
+	    *wall = (u64)jiffies_to_usecs(cur_wall_time);
+
+	return (u64)jiffies_to_usecs(idle_time);
+}
+#endif /* LINUX_VERSION_CODE... */
+
+// ZZ: this function is placed here only from kernel version 3.4 to 3.8
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0) && LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0)
+static inline u64 get_cpu_idle_time_jiffy(unsigned int cpu, u64 *wall)
+{
+	u64 idle_time;
+	u64 cur_wall_time;
+	u64 busy_time;
+	cur_wall_time = jiffies64_to_cputime64(get_jiffies_64());
+	busy_time  = kcpustat_cpu(cpu).cpustat[CPUTIME_USER];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SYSTEM];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_IRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_SOFTIRQ];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_STEAL];
+	busy_time += kcpustat_cpu(cpu).cpustat[CPUTIME_NICE];
+
+	idle_time = cur_wall_time - busy_time;
+	if (wall)
+	*wall = jiffies_to_usecs(cur_wall_time);
+	return jiffies_to_usecs(idle_time);
+}
+#endif /* LINUX_VERSION_CODE... */
+
+/*
+ * ZZ: function has been moved out of governor since kernel version 3.8 and finally moved to cpufreq.c in kernel version 3.11
+ *     overruling macro CPU_IDLE_TIME_IN_CPUFREQ included for sources with backported cpufreq implementation
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,8,0) && !defined(CPU_IDLE_TIME_IN_CPUFREQ)
+static inline u64 get_cpu_idle_time(unsigned int cpu, u64 *wall)
+{
+	u64 idle_time = get_cpu_idle_time_us(cpu, NULL);
+
+	if (idle_time == -1ULL)
+		return get_cpu_idle_time_jiffy(cpu, wall);
+	else
+		idle_time += get_cpu_iowait_time_us(cpu, wall);
+
+	return idle_time;
+}
+#endif /* LINUX_VERSION_CODE... */
+
+// keep track of frequency transitions
+static int dbs_cpufreq_notifier(struct notifier_block *nb, unsigned long val, void *data)
+{
+	struct cpufreq_freqs *freq = data;
+	struct cpu_dbs_info_s *this_dbs_info = &per_cpu(cs_cpu_dbs_info,
+							freq->cpu);
+	struct cpufreq_policy *policy;
+
+	if (!this_dbs_info->enable)
+	    return 0;
+
+	policy = this_dbs_info->cur_policy;
+
+	/*
+	 * we only care if our internally tracked freq moves outside
+	 * the 'valid' ranges of frequency available to us otherwise
+	 * we do not change it
+	 */
+	if (unlikely(this_dbs_info->requested_freq > policy->max
+	    || this_dbs_info->requested_freq < policy->min))
+		this_dbs_info->requested_freq = freq->new;
+	return 0;
+}
+
+static struct notifier_block dbs_cpufreq_notifier_block = {
+	.notifier_call = dbs_cpufreq_notifier
+};
+
+/************************** sysfs interface **************************/
+static ssize_t show_sampling_rate_min(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n", min_sampling_rate);
+}
+
+define_one_global_ro(sampling_rate_min);
+
+// cpufreq_zzmoove governor tunables
+#define show_one(file_name, object)					\
+static ssize_t show_##file_name						\
+(struct kobject *kobj, struct attribute *attr, char *buf)		\
+{									\
+	return sprintf(buf, "%u\n", dbs_tuners_ins.object);		\
+}
+#ifdef ENABLE_PROFILES_SUPPORT
+show_one(profile_number, profile_number);						// ZZ: profile number tuneable
+show_one(profile_sticky_mode, profile_sticky_mode);					// ff: sticky profile mode
+#endif /* ENABLE_PROFILES_SUPPORT */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+show_one(auto_adjust_freq_thresholds, auto_adjust_freq_thresholds);			// ZZ: auto adjust freq thresholds tuneable
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+show_one(sampling_rate, sampling_rate);							// ZZ: normal sampling rate tuneable
+show_one(sampling_rate_current, sampling_rate_current);					// ZZ: tuneable for showing the actual sampling rate
+show_one(sampling_rate_idle_threshold, sampling_rate_idle_threshold);			// ZZ: sampling rate idle threshold tuneable
+show_one(sampling_rate_idle, sampling_rate_idle);					// ZZ: tuneable for sampling rate at idle
+show_one(sampling_rate_idle_delay, sampling_rate_idle_delay);				// ZZ: DSR switching delay tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(sampling_rate_sleep_multiplier, sampling_rate_sleep_multiplier);		// ZZ: sampling rate multiplier tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(sampling_down_factor, sampling_down_factor);					// ZZ: sampling down factor tuneable
+show_one(sampling_down_max_momentum, sampling_down_max_mom);				// ZZ: sampling down momentum tuneable
+show_one(sampling_down_momentum_sensitivity, sampling_down_mom_sens);			// ZZ: sampling down momentum sensitivity tuneable
+show_one(up_threshold, up_threshold);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(up_threshold_sleep, up_threshold_sleep);					// ZZ: up threshold sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+show_one(up_threshold_hotplug1, up_threshold_hotplug1);					// ZZ: up threshold hotplug tuneable for core1
+show_one(up_threshold_hotplug_freq1, up_threshold_hotplug_freq1);			// Yank: up threshold hotplug freq tuneable for core1
+show_one(block_up_multiplier_hotplug1, block_up_multiplier_hotplug1);			// ff: block up multiplier hotplug1 for core1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+show_one(up_threshold_hotplug2, up_threshold_hotplug2);					// ZZ: up threshold hotplug tuneable for core2
+show_one(up_threshold_hotplug_freq2, up_threshold_hotplug_freq2);			// Yank: up threshold hotplug freq tuneable for core2
+show_one(block_up_multiplier_hotplug2, block_up_multiplier_hotplug2);			// ff: block up multiplier hotplug2 for core2
+show_one(up_threshold_hotplug3, up_threshold_hotplug3);					// ZZ: up threshold hotplug tuneable for core3
+show_one(up_threshold_hotplug_freq3, up_threshold_hotplug_freq3);			// Yank: up threshold hotplug freq tuneable for core3
+show_one(block_up_multiplier_hotplug3, block_up_multiplier_hotplug3);			// ff: block up multiplier hotplug3 for core3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+show_one(up_threshold_hotplug4, up_threshold_hotplug4);					// ZZ: up threshold hotplug tuneable for core4
+show_one(up_threshold_hotplug_freq4, up_threshold_hotplug_freq4);			// Yank: up threshold hotplug freq tuneable for core4
+show_one(block_up_multiplier_hotplug4, block_up_multiplier_hotplug4);			// ff: block up multiplier hotplug3 for core4
+show_one(up_threshold_hotplug5, up_threshold_hotplug5);					// ZZ: up threshold hotplug tuneable for core5
+show_one(up_threshold_hotplug_freq5, up_threshold_hotplug_freq5);			// Yank: up threshold hotplug freq tuneable for core5
+show_one(block_up_multiplier_hotplug5, block_up_multiplier_hotplug5);			// ff: block up multiplier hotplug3 for core5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+show_one(up_threshold_hotplug6, up_threshold_hotplug6);					// ZZ: up threshold hotplug tuneable for core6
+show_one(up_threshold_hotplug_freq6, up_threshold_hotplug_freq6);			// Yank: up threshold hotplug freq tuneable for core6
+show_one(block_up_multiplier_hotplug6, block_up_multiplier_hotplug6);			// ff: block up multiplier hotplug3 for core6
+show_one(up_threshold_hotplug7, up_threshold_hotplug7);					// ZZ: up threshold hotplug tuneable for core7
+show_one(up_threshold_hotplug_freq7, up_threshold_hotplug_freq7);			// Yank: up threshold hotplug freq tuneable for core7
+show_one(block_up_multiplier_hotplug7, block_up_multiplier_hotplug7);			// ff: block up multiplier hotplug3 for core7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+show_one(down_threshold, down_threshold);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(down_threshold_sleep, down_threshold_sleep);					// ZZ: down threshold sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+show_one(down_threshold_hotplug1, down_threshold_hotplug1);				// ZZ: down threshold hotplug tuneable for core1
+show_one(down_threshold_hotplug_freq1, down_threshold_hotplug_freq1);			// Yank: down threshold hotplug freq tuneable for core1
+show_one(block_down_multiplier_hotplug1, block_down_multiplier_hotplug1);		// ff: block down multiplier hotplug1 for core1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+show_one(down_threshold_hotplug2, down_threshold_hotplug2);				// ZZ: down threshold hotplug tuneable for core2
+show_one(down_threshold_hotplug_freq2, down_threshold_hotplug_freq2);			// Yank: down threshold hotplug freq tuneable for core2
+show_one(block_down_multiplier_hotplug2, block_down_multiplier_hotplug2);		// ff: block down multiplier hotplug2 for core 2
+show_one(down_threshold_hotplug3, down_threshold_hotplug3);				// ZZ: down threshold hotplug tuneable for core3
+show_one(down_threshold_hotplug_freq3, down_threshold_hotplug_freq3);			// Yank: down threshold hotplug freq tuneable for core3
+show_one(block_down_multiplier_hotplug3, block_down_multiplier_hotplug3);		// ff: block down multiplier hotplug3 for core3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+show_one(down_threshold_hotplug4, down_threshold_hotplug4);				// ZZ: down threshold hotplug tuneable for core4
+show_one(down_threshold_hotplug_freq4, down_threshold_hotplug_freq4);			// Yank: down threshold hotplug freq tuneable for core4
+show_one(block_down_multiplier_hotplug4, block_down_multiplier_hotplug4);		// ff: block down multiplier hotplug1 for core4
+show_one(down_threshold_hotplug5, down_threshold_hotplug5);				// ZZ: down threshold hotplug tuneable for core5
+show_one(down_threshold_hotplug_freq5, down_threshold_hotplug_freq5);			// Yank: down threshold hotplug freq tuneable for core5
+show_one(block_down_multiplier_hotplug5, block_down_multiplier_hotplug5);		// ff: block down multiplier hotplug1 for core5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+show_one(down_threshold_hotplug6, down_threshold_hotplug6);				// ZZ: down threshold hotplug tuneable for core6
+show_one(down_threshold_hotplug_freq6, down_threshold_hotplug_freq6);			// Yank: down threshold hotplug freq tuneable for core6
+show_one(block_down_multiplier_hotplug6, block_down_multiplier_hotplug6);		// ff: block down multiplier hotplug1 for core6
+show_one(down_threshold_hotplug7, down_threshold_hotplug7);				// ZZ: down threshold hotplug  tuneable for core7
+show_one(down_threshold_hotplug_freq7, down_threshold_hotplug_freq7);			// Yank: down threshold hotplug freq tuneable for core7
+show_one(block_down_multiplier_hotplug7, block_down_multiplier_hotplug7);		// ff: block down multiplier hotplug1 for core7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+show_one(ignore_nice_load, ignore_nice);						// ZZ: ignore nice load tuneable
+show_one(smooth_up, smooth_up);								// ZZ: smooth up tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(smooth_up_sleep, smooth_up_sleep);						// ZZ: smooth up sleep tuneable for early suspend
+#ifdef ENABLE_HOTPLUGGING
+show_one(hotplug_sleep, hotplug_sleep);							// ZZ: hotplug sleep tuneable for early suspend
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(freq_limit, freq_limit);							// ZZ: freq limit tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(freq_limit_sleep, freq_limit_sleep);						// ZZ: freq limit sleep tuneable for early suspend
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(fast_scaling_up, fast_scaling_up);						// Yank: fast scaling tuneable for upscaling
+show_one(fast_scaling_down, fast_scaling_down);						// Yank: fast scaling tuneable for downscaling
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(fast_scaling_sleep_up, fast_scaling_sleep_up);					// Yank: fast scaling sleep tuneable for early suspend for upscaling
+show_one(fast_scaling_sleep_down, fast_scaling_sleep_down);				// Yank: fast scaling sleep tuneable for early suspend for downscaling
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(afs_threshold1, afs_threshold1);						// ZZ: auto fast scaling step one threshold
+show_one(afs_threshold2, afs_threshold2);						// ZZ: auto fast scaling step two threshold
+show_one(afs_threshold3, afs_threshold3);						// ZZ: auto fast scaling step three threshold
+show_one(afs_threshold4, afs_threshold4);						// ZZ: auto fast scaling step four threshold
+show_one(grad_up_threshold, grad_up_threshold);						// ZZ: early demand tuneable grad up threshold
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(grad_up_threshold_sleep, grad_up_threshold_sleep);				// ZZ: early demand sleep tuneable grad up threshold
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(early_demand, early_demand);							// ZZ: early demand tuneable master switch
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(early_demand_sleep, early_demand_sleep);					// ZZ: early demand sleep tuneable master switch
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+show_one(disable_hotplug, disable_hotplug);						// ZZ: hotplug switch tuneable
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+show_one(disable_hotplug_sleep, disable_hotplug_sleep);					// ZZ: hotplug switch tuneable for sleep
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+show_one(hotplug_block_up_cycles, hotplug_block_up_cycles);				// ZZ: hotplug up block cycles tuneable
+show_one(hotplug_block_down_cycles, hotplug_block_down_cycles);				// ZZ: hotplug down block cycles tuneable
+show_one(hotplug_stagger_up, hotplug_stagger_up);					// ff: hotplug stagger up tuneable
+show_one(hotplug_stagger_down, hotplug_stagger_down);					// ff: hotplug stagger down tuneable
+show_one(hotplug_idle_threshold, hotplug_idle_threshold);				// ZZ: hotplug idle threshold tuneable
+show_one(hotplug_idle_freq, hotplug_idle_freq);						// ZZ: hotplug idle freq tuneable
+show_one(hotplug_engage_freq, hotplug_engage_freq);					// ZZ: hotplug engage freq tuneable (ffolkes)
+show_one(hotplug_max_limit, hotplug_max_limit);						// ZZ: hotplug max limit tunable (ffolkes)
+show_one(hotplug_min_limit, hotplug_min_limit);						// ff: the number of cores we require to be online
+show_one(hotplug_lock, hotplug_lock);							// ff: the number of cores we require to be online
+#endif /* ENABLE_HOTPLUGGING */
+show_one(scaling_block_threshold, scaling_block_threshold);				// ZZ: scaling block threshold tuneable
+show_one(scaling_block_cycles, scaling_block_cycles);					// ZZ: scaling block cycles tuneable
+show_one(scaling_up_block_cycles, scaling_up_block_cycles);				// ff: scaling-up block cycles tuneable
+show_one(scaling_up_block_freq, scaling_up_block_freq);					// ff: scaling-up block freq threshold tuneable
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+show_one(scaling_block_temp, scaling_block_temp);					// ZZ: scaling block temp tuneable
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+show_one(scaling_trip_temp, scaling_trip_temp);						// ff: snapdragon thermal tripping temperature
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+show_one(scaling_block_freq, scaling_block_freq);					// ZZ: scaling block freq tuneable
+show_one(scaling_block_force_down, scaling_block_force_down);				// ZZ: scaling block force down tuneable
+show_one(scaling_fastdown_freq, scaling_fastdown_freq);					// ZZ: scaling fastdown freq tuneable (ffolkes)
+show_one(scaling_fastdown_up_threshold, scaling_fastdown_up_threshold);			// ZZ: scaling fastdown up threshold tuneable (ffolkes)
+show_one(scaling_fastdown_down_threshold, scaling_fastdown_down_threshold);		// ZZ: scaling fastdown down threshold tuneable (ffolkes-ZaneZam)
+show_one(scaling_responsiveness_freq, scaling_responsiveness_freq);			// ZZ: scaling responsiveness freq tuneable (ffolkes)
+show_one(scaling_responsiveness_up_threshold, scaling_responsiveness_up_threshold);	// ZZ: scaling responsiveness up threshold tuneable (ffolkes)
+show_one(scaling_proportional, scaling_proportional);					// ZZ: scaling proportional tuneable
+#ifdef ENABLE_INPUTBOOSTER
+show_one(inputboost_cycles, inputboost_cycles);						// ff: inputbooster duration
+show_one(inputboost_up_threshold, inputboost_up_threshold);				// ff: inputbooster up threshold
+show_one(inputboost_punch_cycles, inputboost_punch_cycles);				// ff: inputbooster punch cycles
+show_one(inputboost_punch_freq, inputboost_punch_freq);					// ff: inputbooster punch freq
+show_one(inputboost_punch_on_fingerdown, inputboost_punch_on_fingerdown);		// ff: inputbooster punch on finger down
+show_one(inputboost_punch_on_fingermove, inputboost_punch_on_fingermove);		// ff: inputbooster punch on finger move
+show_one(inputboost_punch_on_epenmove, inputboost_punch_on_epenmove);			// ff: inputbooster punch on epen move
+show_one(inputboost_typingbooster_up_threshold, inputboost_typingbooster_up_threshold); // ff: typingbooster up threshold
+show_one(inputboost_typingbooster_cores, inputboost_typingbooster_cores);		// ff: typingbooster boost cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+show_one(music_max_freq, music_max_freq);						// ff: music max frequency
+show_one(music_min_freq, music_min_freq);						// ff: music min frequency
+#ifdef ENABLE_HOTPLUGGING
+show_one(music_min_cores, music_min_cores);						// ZZ: music min online cores
+#endif /* ENABLE_HOTPLUGGING */
+show_one(music_state, music_state);							// ff: music state
+#endif /* ENABLE_MUSIC_LIMITS */
+
+#ifdef ENABLE_PROFILES_SUPPORT
+// ZZ: tuneable for showing the currently active governor settings profile
+static ssize_t show_profile(struct kobject *kobj, struct attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", dbs_tuners_ins.profile);
+}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+// ZZ: tuneable -> possible values: 0 (disable) to MAX_SAMPLING_DOWN_FACTOR, if not set default is 0
+static ssize_t store_sampling_down_max_momentum(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input, j;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR -
+	    dbs_tuners_ins.sampling_down_factor || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_down_max_mom != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_down_max_mom = zz_sampling_down_max_mom = input;
+
+	orig_sampling_down_max_mom = dbs_tuners_ins.sampling_down_max_mom;
+
+	// ZZ: reset sampling down factor to default if momentum was disabled
+	if (dbs_tuners_ins.sampling_down_max_mom == 0)
+	    zz_sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;
+
+	// ZZ: reset momentum_adder and reset down sampling multiplier in case momentum was disabled
+	for_each_online_cpu(j) {
+	    struct cpu_dbs_info_s *dbs_info;
+	    dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+	    dbs_info->momentum_adder = 0;
+	    if (dbs_tuners_ins.sampling_down_max_mom == 0)
+		dbs_info->rate_mult = 1;
+	}
+	return count;
+}
+
+// ZZ: tuneable -> possible values: 1 to MAX_SAMPLING_DOWN_MOMENTUM_SENSITIVITY, if not set default is 50
+static ssize_t store_sampling_down_momentum_sensitivity(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input, j;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_SAMPLING_DOWN_MOMENTUM_SENSITIVITY
+	    || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	// ff: do this so synapse can set 0.
+	if (!input)
+	    input = 1;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_down_mom_sens != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_down_mom_sens = input;
+
+	// ZZ: reset momentum_adder
+	for_each_online_cpu(j) {
+	    struct cpu_dbs_info_s *dbs_info;
+	    dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+	    dbs_info->momentum_adder = 0;
+	}
+	return count;
+}
+/*
+ * ZZ: tunable for sampling down factor (reactivated function) added reset loop for momentum functionality
+ * -> possible values: 1 (disabled) to MAX_SAMPLING_DOWN_FACTOR, if not set default is 1
+ */
+static ssize_t store_sampling_down_factor(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input, j;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_SAMPLING_DOWN_FACTOR
+	    || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_down_factor != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_down_factor = zz_sampling_down_factor = input;
+
+	// ZZ: reset down sampling multiplier in case it was active
+	for_each_online_cpu(j) {
+	    struct cpu_dbs_info_s *dbs_info;
+	    dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+	    dbs_info->rate_mult = 1;
+	}
+	return count;
+}
+
+static ssize_t store_sampling_rate(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_rate != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_rate = dbs_tuners_ins.sampling_rate_current
+	= max(input, min_sampling_rate); // ZZ: set it to new value
+
+	return count;
+}
+
+/*
+ * ZZ: tuneable -> possible values: 0 disable whole functionality and same as 'sampling_rate' any value
+ * above min_sampling_rate, if not set default is 180000
+ */
+static ssize_t store_sampling_rate_idle(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_rate_idle != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input == 0)
+	    dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate_idle
+	    = dbs_tuners_ins.sampling_rate;	// ZZ: set current and idle rate to normal = disable feature
+	else
+	    dbs_tuners_ins.sampling_rate_idle = max(input, min_sampling_rate);	// ZZ: set idle rate to new value
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: 0 disable threshold, any value under 100, if not set default is 0
+static ssize_t store_sampling_rate_idle_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_rate_idle_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_rate_idle_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_sampling_rate_idle_delay(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0)
+	    sampling_rate_step_up_delay = 0;
+	    sampling_rate_step_down_delay = 0;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_rate_idle_delay != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_rate_idle_delay = input;
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: 1 to 8, if not set default is 2
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_sampling_rate_sleep_multiplier(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > MAX_SAMPLING_RATE_SLEEP_MULTIPLIER || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.sampling_rate_sleep_multiplier != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.sampling_rate_sleep_multiplier = input;
+
+	return count;
+}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+static ssize_t store_up_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100
+	    || input <= dbs_tuners_ins.down_threshold
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.up_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: range from above down_threshold_sleep value up to 100, if not set default is 90
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_up_threshold_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100
+	    || input <= dbs_tuners_ins.down_threshold_sleep
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.up_threshold_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.up_threshold_sleep = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+#ifdef ENABLE_HOTPLUGGING
+#ifdef ENABLE_PROFILES_SUPPORT
+// ff: tuneable -> possible values: range from 0 up to 25, if not set default is 1 (disabled)
+#define store_block_up_multiplier_hotplug(name)							\
+static ssize_t store_block_up_multiplier_hotplug##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input < 0 || input > 25 || set_profile_active == true)			\
+		return -EINVAL;									\
+												\
+	if (!dbs_tuners_ins.profile_sticky_mode							\
+	    && dbs_tuners_ins.profile_number != 0						\
+	    && dbs_tuners_ins.block_up_multiplier_hotplug##name != input) {			\
+	    dbs_tuners_ins.profile_number = 0;							\
+	    strncpy(dbs_tuners_ins.profile, custom_profile,					\
+	    sizeof(dbs_tuners_ins.profile));							\
+	}											\
+	dbs_tuners_ins.block_up_multiplier_hotplug##name = input;				\
+												\
+	return count;										\
+}												\
+
+#define store_block_down_multiplier_hotplug(name)						\
+static ssize_t store_block_down_multiplier_hotplug##name					\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input < 0 || input > 25 || set_profile_active == true)			\
+		return -EINVAL;									\
+												\
+	if (!dbs_tuners_ins.profile_sticky_mode							\
+	    && dbs_tuners_ins.profile_number != 0						\
+	    && dbs_tuners_ins.block_down_multiplier_hotplug##name != input) {			\
+	    dbs_tuners_ins.profile_number = 0;							\
+	    strncpy(dbs_tuners_ins.profile, custom_profile,					\
+	    sizeof(dbs_tuners_ins.profile));							\
+	}											\
+	dbs_tuners_ins.block_down_multiplier_hotplug##name = input;				\
+												\
+return count;											\
+}												\
+
+// Yank: also use definitions for other hotplug tunables
+#define store_up_threshold_hotplug(name,core)							\
+static ssize_t store_up_threshold_hotplug##name							\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	    if (ret != 1 || input < 0 || input > 100 || set_profile_active == true)		\
+		return -EINVAL;									\
+												\
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0	\
+		&& dbs_tuners_ins.up_threshold_hotplug##name != input) {			\
+		dbs_tuners_ins.profile_number = 0;						\
+		strncpy(dbs_tuners_ins.profile, custom_profile,					\
+		sizeof(dbs_tuners_ins.profile));						\
+	    }											\
+												\
+	    dbs_tuners_ins.up_threshold_hotplug##name = input;					\
+	    hotplug_thresholds[0][core] = input;						\
+												\
+	return count;										\
+}												\
+
+#define store_down_threshold_hotplug(name,core)							\
+static ssize_t store_down_threshold_hotplug##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	    if (ret != 1 || input < 1 || input > 100 || set_profile_active == true)		\
+		return -EINVAL;									\
+												\
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0	\
+		&& dbs_tuners_ins.down_threshold_hotplug##name != input) {			\
+		dbs_tuners_ins.profile_number = 0;						\
+		strncpy(dbs_tuners_ins.profile, custom_profile,					\
+		sizeof(dbs_tuners_ins.profile));						\
+	    }											\
+												\
+	    dbs_tuners_ins.down_threshold_hotplug##name = input;				\
+	    hotplug_thresholds[1][core] = input;						\
+												\
+	return count;										\
+}												\
+
+/*
+ * ZZ: tuneables -> possible values: 0 to disable core (only in up thresholds), range from appropriate
+ * down threshold value up to 100, if not set default for up threshold is 68 and for down threshold is 55
+ */
+store_up_threshold_hotplug(1,0);
+store_down_threshold_hotplug(1,0);
+store_block_up_multiplier_hotplug(1);
+store_block_down_multiplier_hotplug(1);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug(2,1);
+store_down_threshold_hotplug(2,1);
+store_block_up_multiplier_hotplug(2);
+store_block_down_multiplier_hotplug(2);
+store_up_threshold_hotplug(3,2);
+store_down_threshold_hotplug(3,2);
+store_block_up_multiplier_hotplug(3);
+store_block_down_multiplier_hotplug(3);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug(4,3);
+store_down_threshold_hotplug(4,3);
+store_block_up_multiplier_hotplug(4);
+store_block_down_multiplier_hotplug(4);
+store_up_threshold_hotplug(5,4);
+store_down_threshold_hotplug(5,4);
+store_block_up_multiplier_hotplug(5);
+store_block_down_multiplier_hotplug(5);
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+store_up_threshold_hotplug(6,5);
+store_down_threshold_hotplug(6,5);
+store_block_up_multiplier_hotplug(6);
+store_block_down_multiplier_hotplug(6);
+store_up_threshold_hotplug(7,6);
+store_down_threshold_hotplug(7,6);
+store_block_up_multiplier_hotplug(7);
+store_block_down_multiplier_hotplug(7);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+#ifndef ENABLE_PROFILES_SUPPORT
+// ff: tuneable -> possible values: range from 0 up to 25, if not set default is 1 (disabled)
+#define store_block_up_multiplier_hotplug(name)							\
+static ssize_t store_block_up_multiplier_hotplug##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input < 0 || input > 25)						\
+		return -EINVAL;									\
+												\
+	dbs_tuners_ins.block_up_multiplier_hotplug##name = input;				\
+												\
+	return count;										\
+}												\
+
+#define store_block_down_multiplier_hotplug(name)						\
+static ssize_t store_block_down_multiplier_hotplug##name					\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input < 0 || input > 25)						\
+		return -EINVAL;									\
+												\
+	dbs_tuners_ins.block_down_multiplier_hotplug##name = input;				\
+												\
+return count;											\
+}												\
+
+// Yank: also use definitions for other hotplug tunables
+#define store_up_threshold_hotplug(name,core)							\
+static ssize_t store_up_threshold_hotplug##name							\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	    if (ret != 1 || input < 0 || input > 100)						\
+		return -EINVAL;									\
+												\
+	    dbs_tuners_ins.up_threshold_hotplug##name = input;					\
+	    hotplug_thresholds[0][core] = input;						\
+												\
+	return count;										\
+}												\
+
+#define store_down_threshold_hotplug(name,core)							\
+static ssize_t store_down_threshold_hotplug##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	    if (ret != 1 || input < 1 || input > 100)						\
+		return -EINVAL;									\
+												\
+	    dbs_tuners_ins.down_threshold_hotplug##name = input;				\
+	    hotplug_thresholds[1][core] = input;						\
+												\
+	return count;										\
+}												\
+
+/*
+ * ZZ: tuneables -> possible values: 0 to disable core (only in up thresholds), range from appropriate
+ * down threshold value up to 100, if not set default for up threshold is 68 and for down threshold is 55
+ */
+store_up_threshold_hotplug(1,0);
+store_down_threshold_hotplug(1,0);
+store_block_up_multiplier_hotplug(1);
+store_block_down_multiplier_hotplug(1);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug(2,1);
+store_down_threshold_hotplug(2,1);
+store_block_up_multiplier_hotplug(2);
+store_block_down_multiplier_hotplug(2);
+store_up_threshold_hotplug(3,2);
+store_down_threshold_hotplug(3,2);
+store_block_up_multiplier_hotplug(3);
+store_block_down_multiplier_hotplug(3);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug(4,3);
+store_down_threshold_hotplug(4,3);
+store_block_up_multiplier_hotplug(4);
+store_block_down_multiplier_hotplug(4);
+store_up_threshold_hotplug(5,4);
+store_down_threshold_hotplug(5,4);
+store_block_up_multiplier_hotplug(5);
+store_block_down_multiplier_hotplug(5);
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+store_up_threshold_hotplug(6,5);
+store_down_threshold_hotplug(6,5);
+store_block_up_multiplier_hotplug(6);
+store_block_down_multiplier_hotplug(6);
+store_up_threshold_hotplug(7,6);
+store_down_threshold_hotplug(7,6);
+store_block_up_multiplier_hotplug(7);
+store_block_down_multiplier_hotplug(7);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_PROFILES_SUPPORT */
+#endif /* ENABLE_HOTPLUGGING */
+
+static ssize_t store_down_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	// ZZ: cannot be lower than 11 otherwise freq will not fall (conservative governor)
+	if (ret != 1 || input < 11 || input > 100
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	// ZZ: instead of failing when set too high set it to the highest it can safely go (ffolkes)
+	if (dbs_tuners_ins.up_threshold != 0 && input >= dbs_tuners_ins.up_threshold) {
+	    input = dbs_tuners_ins.up_threshold - 1;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.down_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.down_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: range from 11 to up_threshold_sleep but not up_threshold_sleep, if not set default is 44
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_down_threshold_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	// ZZ: cannot be lower than 11 otherwise freq will not fall (conservative governor)
+	if (ret != 1 || input < 11 || input > 100
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	// ZZ: instead of failing when set too high set it to the highest it can safely go (ffolkes)
+	if (dbs_tuners_ins.up_threshold != 0 && input >= dbs_tuners_ins.up_threshold) {
+	    input = dbs_tuners_ins.up_threshold - 1;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.down_threshold_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.down_threshold_sleep = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+static ssize_t store_ignore_nice_load(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	unsigned int j;
+
+	ret = sscanf(buf, "%u", &input);
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input > 1)
+	    input = 1;
+
+	if (input == dbs_tuners_ins.ignore_nice) {		// ZZ: nothing to do
+	    return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.ignore_nice != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.ignore_nice = input;
+
+	// ZZ: we need to re-evaluate prev_cpu_idle
+	for_each_online_cpu(j) {
+		 struct cpu_dbs_info_s *dbs_info;
+		 dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+		 dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) || defined(CPU_IDLE_TIME_IN_CPUFREQ) /* overrule for sources with backported cpufreq implementation */
+		 &dbs_info->prev_cpu_wall, 0);
+#else
+		 &dbs_info->prev_cpu_wall);
+#endif /* LINUX_VERSION_CODE... */
+		 if (dbs_tuners_ins.ignore_nice)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		     dbs_info->prev_cpu_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];
+#else
+		     dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+#endif /* LINUX_VERSION_CODE... */
+	}
+	return count;
+}
+
+static ssize_t store_smooth_up(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.smooth_up != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.smooth_up = input;
+
+	return count;
+}
+
+// ZZ: tuneable -> possible values: range from 1 to 100, if not set default is 100
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_smooth_up_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.smooth_up_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.smooth_up_sleep = input;
+
+	return count;
+}
+
+/*
+ * ZZ: tuneable -> possible values: 0 do not touch the hotplug values on early suspend,
+ * input value 1 to MAX_CORES -> value equals cores to run at early suspend, if not set default is 0 (= all cores enabled)
+ */
+#ifdef ENABLE_HOTPLUGGING
+static ssize_t store_hotplug_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input >= possible_cpus || (input < 0 && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.hotplug_sleep = input;
+
+	return count;
+}
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+/*
+ * ZZ: tuneable -> possible values: 0 disable, system table freq->min to freq->max in khz -> freqency soft-limit, if not set default is 0
+ * Yank: updated : possible values now depend on the system frequency table only
+ */
+static ssize_t store_freq_limit(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+	    max_scaling_freq_soft = max_scaling_freq_hard;
+	    if (freq_table_desc)							// ZZ: if descending ordered table is used
+		limit_table_start = max_scaling_freq_soft;				// ZZ: we should use the actual scaling soft limit value as search start point
+	    else
+		limit_table_end = system_freq_table[freq_table_size].frequency;		// ZZ: set search end point to max freq when using ascending table
+
+#ifdef ENABLE_PROFILES_SUPPORT
+		// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.freq_limit != input) {
+		    dbs_tuners_ins.profile_number = 0;
+		    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		}
+#endif /* ENABLE_PROFILES_SUPPORT */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		freq_limit_awake = dbs_tuners_ins.freq_limit = input;
+#else
+		dbs_tuners_ins.freq_limit = input;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max limit
+	    return -EINVAL;
+	} else {
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		    if (unlikely(system_freq_table[i].frequency == input)) {
+			max_scaling_freq_soft = i;
+			if (freq_table_desc)						// ZZ: if descending ordered table is used
+			    limit_table_start = max_scaling_freq_soft;			// ZZ: we should use the actual scaling soft limit value as search start point
+			else
+			    limit_table_end = system_freq_table[i].frequency;		// ZZ: set search end point to max soft freq limit when using ascenting table
+#ifdef ENABLE_PROFILES_SUPPORT
+			// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+			if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.freq_limit != input) {
+			    dbs_tuners_ins.profile_number = 0;
+			    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+			}
+#endif /* ENABLE_PROFILES_SUPPORT */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+			freq_limit_awake = dbs_tuners_ins.freq_limit = input;
+#else
+			dbs_tuners_ins.freq_limit = input;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+			return count;
+		    }
+		}
+	}
+	return -EINVAL;
+}
+
+/*
+ * ZZ: tuneable -> possible values: 0 disable, system table freq->min to freq->max in khz -> freqency soft-limit,
+ * if not set default is 0
+ * Yank: updated : possible values now depend on the system frequency table only
+ */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_freq_limit_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.freq_limit_sleep != input) {
+		    dbs_tuners_ins.profile_number = 0;
+		    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		}
+#endif /* ENABLE_PROFILES_SUPPORT */
+		freq_limit_asleep = dbs_tuners_ins.freq_limit_sleep = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);						// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {	// Yank: allow only frequencies below or equal to hard max
+	    return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.freq_limit_sleep != input) {
+			dbs_tuners_ins.profile_number = 0;
+		        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    freq_limit_asleep = dbs_tuners_ins.freq_limit_sleep = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+// Yank: tuneable -> possible values 1-4 to enable fast scaling and 5 for auto fast scaling (insane scaling)
+static ssize_t store_fast_scaling_up(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 5 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.fast_scaling_up != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.fast_scaling_up = input;
+
+	if (input > 4)				// ZZ: auto fast scaling mode
+	    return count;
+
+	scaling_mode_up = input;		// Yank: fast scaling up only
+
+	return count;
+}
+
+// Yank: tuneable -> possible values 1-4 to enable fast scaling and 5 for auto fast scaling (insane scaling)
+static ssize_t store_fast_scaling_down(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 5 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.fast_scaling_down != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.fast_scaling_down = input;
+
+	if (input > 4)				// ZZ: auto fast scaling mode
+	    return count;
+
+	scaling_mode_down = input;		// Yank: fast scaling up only
+
+	return count;
+}
+
+// Yank: tuneable -> possible values 1-4 to enable fast scaling and 5 for auto fast scaling (insane scaling) in early suspend
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_fast_scaling_sleep_up(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 5 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.fast_scaling_sleep_up != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.fast_scaling_sleep_up = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+// Yank: tuneable -> possible values 1-4 to enable fast scaling and 5 for auto fast scaling (insane scaling) in early suspend
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_fast_scaling_sleep_down(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 5 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.fast_scaling_sleep_down != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.fast_scaling_sleep_down = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+#ifdef ENABLE_PROFILES_SUPPORT
+// ZZ: tuneable -> possible values from 0 to 100
+#define store_afs_threshold(name)								\
+static ssize_t store_afs_threshold##name(struct kobject *a, struct attribute *b,		\
+				  const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input > 100 || input < 0 || set_profile_active == true)			\
+		return -EINVAL;									\
+												\
+												\
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0		\
+	&& dbs_tuners_ins.afs_threshold##name != input) {					\
+	    dbs_tuners_ins.profile_number = 0;							\
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));	\
+	}											\
+												\
+	dbs_tuners_ins.afs_threshold##name = input;						\
+												\
+	return count;										\
+}												\
+
+store_afs_threshold(1);
+store_afs_threshold(2);
+store_afs_threshold(3);
+store_afs_threshold(4);
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+#ifndef ENABLE_PROFILES_SUPPORT
+// ZZ: tuneable -> possible values from 0 to 100
+#define store_afs_threshold(name)								\
+static ssize_t store_afs_threshold##name(struct kobject *a, struct attribute *b,		\
+				  const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	ret = sscanf(buf, "%u", &input);							\
+												\
+	if (ret != 1 || input > 100 || input < 0)						\
+		return -EINVAL;									\
+												\
+	dbs_tuners_ins.afs_threshold##name = input;						\
+												\
+	return count;										\
+}												\
+
+store_afs_threshold(1);
+store_afs_threshold(2);
+store_afs_threshold(3);
+store_afs_threshold(4);
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+// ZZ: Early demand - tuneable grad up threshold -> possible values: from 1 to 100, if not set default is 50
+static ssize_t store_grad_up_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.grad_up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.grad_up_threshold = input;
+
+	return count;
+}
+
+// ZZ: Early demand - tuneable grad up threshold sleep -> possible values: from 1 to 100, if not set default is 50
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_grad_up_threshold_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input < 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.grad_up_threshold_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.grad_up_threshold_sleep = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+// ZZ: Early demand - tuneable master switch -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_early_demand(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	input = !!input;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.early_demand != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.early_demand = !!input;
+
+	return count;
+}
+
+// ZZ: Early demand sleep - tuneable master switch -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_early_demand_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	input = !!input;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.early_demand_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.early_demand_sleep = !!input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+#ifdef ENABLE_HOTPLUGGING
+// ZZ: tuneable hotplug switch -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_disable_hotplug(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 2 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.disable_hotplug != input) {
+		dbs_tuners_ins.profile_number = 0;
+		strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.disable_hotplug = input;
+
+	if (input == 1) {
+	    enable_cores = 1;
+	    queue_work_on(0, dbs_wq, &hotplug_online_work);
+	}
+
+	return count;
+}
+
+// ZZ: tuneable hotplug switch for early supend -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+static ssize_t store_disable_hotplug_sleep(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 2 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.disable_hotplug_sleep != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.disable_hotplug_sleep = input;
+
+	return count;
+}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+// ZZ: tuneable hotplug up block cycles -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_hotplug_block_up_cycles(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0)
+	    hplg_up_block_cycles = 0;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_block_up_cycles != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.hotplug_block_up_cycles = input;
+
+	return count;
+}
+
+// ZZ: tuneable hotplug down block cycles -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_hotplug_block_down_cycles(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0)
+	    hplg_down_block_cycles = 0;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_block_down_cycles != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.hotplug_block_down_cycles = input;
+
+	return count;
+}
+
+// ff: tuneable hotplug stagger up -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_hotplug_stagger_up(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	input = !!input;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_stagger_up != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.hotplug_stagger_up = input;
+
+	return count;
+}
+
+// ff: tuneable hotplug stagger down -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_hotplug_stagger_down(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	input = !!input;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_stagger_down != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.hotplug_stagger_down = input;
+
+	return count;
+}
+
+// ZZ: tuneable hotplug idle threshold -> possible values: range from 0 disabled to 100, if not set default is 0
+static ssize_t store_hotplug_idle_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 0 || input > 100) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_idle_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.hotplug_idle_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable hotplug idle frequency -> frequency from where the hotplug idle should begin. possible values: all valid system frequencies
+static ssize_t store_hotplug_idle_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_idle_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.hotplug_idle_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_idle_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.hotplug_idle_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ZZ: tuneable -> possible values: range from 0 (disabled) to policy->max, if not set default is 0 (ffolkes)
+static ssize_t store_hotplug_engage_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_engage_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.hotplug_engage_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_engage_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.hotplug_engage_freq = input;
+		    return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ff: added tuneable hotplug_max_limit -> possible values: range from 0 disabled to 8, if not set default is 0
+static ssize_t store_hotplug_max_limit(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 0 || input > possible_cpus) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_max_limit != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	dbs_tuners_ins.hotplug_max_limit = input;
+
+	if (input > 0) {
+	    disable_cores = 1;
+	    queue_work_on(0, dbs_wq, &hotplug_offline_work);
+	}
+
+	return count;
+}
+
+// ff: added tuneable hotplug_lock -> possible values: range from 0 disabled to 8, if not set default is 0
+static ssize_t store_hotplug_lock(struct kobject *a, struct attribute *b,
+ const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 0 || input > possible_cpus) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_lock != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.hotplug_lock = input;
+
+	if (input > 0) {
+	    disable_cores = 2;
+	    queue_work_on(0, dbs_wq, &hotplug_offline_work);
+	}
+
+	return count;
+}
+
+// ff: added tuneable hotplug_min_limit -> possible values: range from 0 disabled to 8, if not set default is 0
+static ssize_t store_hotplug_min_limit(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 1 || input > possible_cpus) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.hotplug_min_limit != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.hotplug_min_limit = input;
+	dbs_tuners_ins.hotplug_min_limit_saved = input;
+
+	if (input > 1) {
+	    enable_cores = 1;
+	    queue_work_on(0, dbs_wq, &hotplug_online_work);
+	}
+
+	return count;
+}
+#endif /* ENABLE_HOTPLUGGING */
+
+// ZZ: tuneable -> possible values: range from 0 (disabled) to policy->max, if not set default is 0 (ffolkes)
+static ssize_t store_scaling_responsiveness_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_responsiveness_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.scaling_responsiveness_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_responsiveness_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.scaling_responsiveness_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ZZ: tuneable -> possible values: range from 11 to 100, if not set default is 30 (ffolkes)
+static ssize_t store_scaling_responsiveness_up_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input < 11
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_responsiveness_up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_responsiveness_up_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable scaling idle threshold -> possible values: range from 0 disabled to 100, if not set default is 0
+static ssize_t store_scaling_block_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 0 || input > 100) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_block_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable scaling block cycles -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_scaling_block_cycles(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0)
+	    scaling_block_cycles_count = 0;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_cycles != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_block_cycles = input;
+
+	return count;
+}
+
+// ff: tuneable scaling-up block cycles -> possible values: 0 to disable, any value above 0 to enable, if not set default is 0
+static ssize_t store_scaling_up_block_cycles(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0)
+		scaling_up_block_cycles_count = 0;
+
+	dbs_tuners_ins.scaling_up_block_cycles = input;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode
+	if (dbs_tuners_ins.profile_number != 0) {
+		dbs_tuners_ins.profile_number = 0;
+		strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	return count;
+}
+
+// ff: tuneable -> possible values: range from 0 (disabled) to policy->max, if not set default is 0
+static ssize_t store_scaling_up_block_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+		dbs_tuners_ins.scaling_up_block_freq = input;
+#ifdef ENABLE_PROFILES_SUPPORT
+		// ZZ: set profile number to 0 and profile name to custom mode
+		if (dbs_tuners_ins.profile_number != 0) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		}
+#endif /* ENABLE_PROFILES_SUPPORT */
+		return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		return -EINVAL;
+	} else {
+		for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+			if (unlikely(system_freq_table[i].frequency == input)) {
+				dbs_tuners_ins.scaling_up_block_freq = input;
+#ifdef ENABLE_PROFILES_SUPPORT
+				// ZZ: set profile number to 0 and profile name to custom mode
+				if (dbs_tuners_ins.profile_number != 0) {
+					dbs_tuners_ins.profile_number = 0;
+					strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+				}
+#endif /* ENABLE_PROFILES_SUPPORT */
+				return count;
+			}
+		}
+	}
+	return -EINVAL;
+}
+
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+// ZZ: tuneable scaling block temp -> possible values: 0 to disable, values from 30C to 80C, if not set default is 0
+static ssize_t store_scaling_block_temp(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || (input < 30 && input != 0) || input > 80
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_temp != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_block_temp = input;
+
+	return count;
+}
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+
+// ff: added tuneable scaling_trip_temp -> possible values: 0 to disable, range from 40C to 69C if not set default is 0
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+static ssize_t store_scaling_trip_temp(struct kobject *a, struct attribute *b,
+													const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || (input < 40 && input != 0) || input > 69
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_trip_temp != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_trip_temp = input;
+	return count;
+}
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+
+// ZZ: tuneable scaling up idle frequency -> frequency from where the scaling up idle should begin. possible values all valid system frequenies
+static ssize_t store_scaling_block_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.scaling_block_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.scaling_block_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ZZ: tuneable scaling block force down -> possible values: 0 to disable, 2 or any value above 2 to enable, if not set default is 2
+static ssize_t store_scaling_block_force_down(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input == 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_block_force_down != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_block_force_down = input;
+
+	return count;
+}
+
+// ZZ: tuneable scaling_fastdown_freq -> possible values: range from 0 (disabled) to policy->max, if not set default is 0 (ffolkes)
+static ssize_t store_scaling_fastdown_freq(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int i = 0;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_fastdown_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.scaling_fastdown_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_fastdown_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.scaling_fastdown_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ZZ: tuneable scaling_fastdown_up_threshold -> possible values: range from above fastdown up threshold to 100, if not set default is 95 (ffolkes)
+static ssize_t store_scaling_fastdown_up_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input > 100 || input <= dbs_tuners_ins.scaling_fastdown_down_threshold
+#ifdef ENABLE_PROFILES_SUPPORT
+	|| set_profile_active == true)
+#else
+	)
+#endif /* ENABLE_PROFILES_SUPPORT */
+		return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_fastdown_up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_fastdown_up_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable scaling_fastdown_down_threshold -> possible values: range from 11 to 100, if not set default is 90 (ffolkes)
+static ssize_t store_scaling_fastdown_down_threshold(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if ((ret != 1 || input > 100 || (input < 11 && input >= dbs_tuners_ins.scaling_fastdown_up_threshold))
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_fastdown_down_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_fastdown_down_threshold = input;
+
+	return count;
+}
+
+// ZZ: tuneable scaling proportinal -> possible values: 0 to disable, 1 to enable comparision between proportional and optimized freq, 2 to enable propotional freq usage only
+//     3 to enable propotional freq usage only but with dead brand range to avoid not reaching of pol min freq, if not set default is 0
+static ssize_t store_scaling_proportional(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 3
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.scaling_proportional != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.scaling_proportional = input;
+
+	return count;
+}
+
+#ifdef ENABLE_INPUTBOOSTER
+// ff: added tuneable inputboost_cycles -> possible values: range from 0 disabled to 1000, if not set default is 0
+static ssize_t store_inputboost_cycles(struct kobject *a, struct attribute *b,
+									   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	int rc;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 1000
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_cycles != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (!input && dbs_tuners_ins.inputboost_cycles != input) {
+		// input is 0, and it wasn't before.
+		// so remove booster and unregister.
+
+		    input_unregister_handler(&interactive_input_handler);
+
+	} else if (input && dbs_tuners_ins.inputboost_cycles == 0) {
+		// input is something other than 0, and it wasn't before,
+		// so add booster and register.
+
+		    rc = input_register_handler(&interactive_input_handler);
+		    if (!rc)
+			    pr_info("[zzmoove/store_inputboost_cycles] inputbooster - registered\n");
+		    else
+			    pr_info("[zzmoove/store_inputboost_cycles] inputbooster - register FAILED\n");
+	}
+
+	dbs_tuners_ins.inputboost_cycles = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_up_threshold -> possible values: range from 0 disabled (future use) to 100, if not set default is 50
+static ssize_t store_inputboost_up_threshold(struct kobject *a, struct attribute *b,
+											 const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 100
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_up_threshold = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_punch_cycles -> possible values: range from 0 disabled to 500, if not set default is 0
+static ssize_t store_inputboost_punch_cycles(struct kobject *a, struct attribute *b,
+											 const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 500
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_cycles != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (!input) {
+		// reset some stuff.
+		flg_ctr_inputboost = 0;
+		flg_ctr_inputboost_punch = 0;
+	}
+
+	dbs_tuners_ins.inputboost_punch_cycles = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_punch_freq -> possible values: range from 0 disabled to policy->max, if not set default is 0
+static ssize_t store_inputboost_punch_freq(struct kobject *a, struct attribute *b,
+										   const char *buf, size_t count)
+{
+	unsigned int input;
+	unsigned int i;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.inputboost_punch_freq = input;
+	return count;
+	}
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.inputboost_punch_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ff: added tuneable inputboost_punch_on_fingerdown -> possible values: range from 0 disabled to >0 enabled, if not set default is 0
+static ssize_t store_inputboost_punch_on_fingerdown(struct kobject *a, struct attribute *b,
+											 const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_on_fingerdown != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_punch_on_fingerdown = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_punch_on_fingermove -> possible values: range from 0 disabled to >0 enabled, if not set default is 0
+static ssize_t store_inputboost_punch_on_fingermove(struct kobject *a, struct attribute *b,
+											  const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_on_fingermove != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_punch_on_fingermove = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_punch_on_epenmove -> possible values: range from 0 disabled to >0 enabled, if not set default is 0
+static ssize_t store_inputboost_punch_on_epenmove(struct kobject *a, struct attribute *b,
+												  const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input > 1)
+		input = 1;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_punch_on_epenmove != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_punch_on_epenmove = input;
+	return count;
+}
+
+// ff: added tuneable inputboost_typingbooster_up_threshold -> possible values: range from 0 disabled (future use) to 100, if not set default is 50
+static ssize_t store_inputboost_typingbooster_up_threshold(struct kobject *a, struct attribute *b,
+											 const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 100
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_typingbooster_up_threshold != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_typingbooster_up_threshold = input;
+	return count;
+}
+
+#ifdef ENABLE_HOTPLUGGING
+// ff: added tuneable inputboost_typingbooster_cores -> possible values: range from 0 disabled to 4, if not set default is 0
+static ssize_t store_inputboost_typingbooster_cores(struct kobject *a, struct attribute *b,
+														   const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0 || input > 4
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.inputboost_typingbooster_cores != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.inputboost_typingbooster_cores = input;
+	return count;
+}
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* ENABLE_INPUTBOOSTER */
+
+#ifdef ENABLE_MUSIC_LIMITS
+// ff: added tuneable music_max_freq -> possible values: range from 0 disabled to policy->max, if not set default is 0
+static ssize_t store_music_max_freq(struct kobject *a, struct attribute *b,
+									const char *buf, size_t count)
+{
+	unsigned int input;
+	unsigned int i;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.music_max_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	    music_max_freq_step = 0;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	    dbs_tuners_ins.music_max_freq = input;
+	return count;
+	}
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.music_max_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.music_max_freq = input;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    music_max_freq_step = i;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		    return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+// ff: added tuneable music_min_freq -> possible values: range from 0 disabled to policy->max, if not set default is 0
+static ssize_t store_music_min_freq(struct kobject *a, struct attribute *b,
+									const char *buf, size_t count)
+{
+	unsigned int input;
+	unsigned int i;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	if (input == 0) {
+#ifdef ENABLE_PROFILES_SUPPORT
+	    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.music_min_freq != input) {
+	        dbs_tuners_ins.profile_number = 0;
+	        strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    dbs_tuners_ins.music_min_freq = input;
+	return count;
+	}
+#ifdef ENABLE_PROFILES_SUPPORT
+	input = check_frequency(input);							// ZZ: check and adapt given freq if necessary
+#endif /* ENABLE_PROFILES_SUPPORT */
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {		// Yank: allow only frequencies below or equal to hard max
+		   return -EINVAL;
+	} else {
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+		if (unlikely(system_freq_table[i].frequency == input)) {
+#ifdef ENABLE_PROFILES_SUPPORT
+		    // ZZ: set profile number to 0 and profile name to custom mode if value has changed
+		    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.music_min_freq != input) {
+			dbs_tuners_ins.profile_number = 0;
+			strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+		    }
+#endif /* ENABLE_PROFILES_SUPPORT */
+		    dbs_tuners_ins.music_min_freq = input;
+		return count;
+		}
+	    }
+	}
+	return -EINVAL;
+}
+
+#ifdef ENABLE_HOTPLUGGING
+// ZZ: added tuneable music_min_cores -> possible values: range from 0 disabled to 8, if not set default is 0
+static ssize_t store_music_min_cores(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+	ret = sscanf(buf, "%u", &input);
+
+	if (((ret != 1 || input < 1 || input > possible_cpus) && input != 0)
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.music_min_cores != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.music_min_cores = input;
+
+	return count;
+}
+#endif /* ENABLE_HOTPLUGGING */
+
+// ff: added tuneable music_state -> possible values: 0 or 1
+static ssize_t store_music_state(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret, i;
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0)
+	    return -EINVAL;
+
+	if (input > 0) {
+
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: if music min cores are set apply core setting
+		if (dbs_tuners_ins.music_min_cores > 0) {
+			enable_cores = 1;
+			queue_work_on(0, dbs_wq, &hotplug_online_work);
+		}
+#endif /* ENABLE_HOTPLUGGING */
+		// ZZ: if music min limit is set change scaling min limit on ascending ordered table
+		if (dbs_tuners_ins.music_min_freq && !freq_table_desc) {
+		    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {
+			if (unlikely(system_freq_table[i].frequency == dbs_tuners_ins.music_min_freq)) {
+			    min_scaling_freq_soft = limit_table_start = i;
+			}
+		    }
+		}
+
+		dbs_tuners_ins.music_state = 1;
+		return count;
+
+	} else {
+		if (!freq_table_desc) {			// ZZ: only on ascending ordered table
+		    min_scaling_freq_soft = 0;		// ZZ: reset saved freq soft limit
+		    limit_table_start = 0;		// ZZ: reset freq limit start point
+		}
+		dbs_tuners_ins.music_state = 0;		// ZZ: disable music state
+	}
+	return count;
+}
+#endif /* ENABLE_MUSIC_LIMITS */
+
+#ifdef ENABLE_PROFILES_SUPPORT
+// ZZ: function for switching a settings profile either at governor start by macro 'DEF_PROFILE_NUMBER' or later by tuneable 'profile_number'
+static inline int set_profile(int profile_num)
+{
+	int i = 0;					// ZZ: for main profile loop
+	int t = 0;					// ZZ: for sub-loop
+#ifdef ENABLE_INPUTBOOSTER
+	int rc = 0;					// ZZ: for impubooster registering
+#endif /* ENABLE_INPUTBOOSTER */
+	unsigned int j;					// ZZ: for update routines
+
+	set_profile_active = true;			// ZZ: avoid additional setting of tuneables during following loop
+
+	for (i = 0; (unlikely(zzmoove_profiles[i].profile_number != PROFILE_TABLE_END)); i++) {
+	    if (unlikely(zzmoove_profiles[i].profile_number == profile_num)) {
+
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set disable_hotplug value
+		if (zzmoove_profiles[i].disable_hotplug > 0 && zzmoove_profiles[i].disable_hotplug < 2) {
+		    dbs_tuners_ins.disable_hotplug = zzmoove_profiles[i].disable_hotplug;
+
+		    if (zzmoove_profiles[i].disable_hotplug == 1) {
+			enable_cores = 1;
+			queue_work_on(0, dbs_wq, &hotplug_online_work);
+		    }
+		}
+		// ZZ: set disable_hotplug_sleep value
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		if (zzmoove_profiles[i].disable_hotplug_sleep > 0 && zzmoove_profiles[i].disable_hotplug_sleep < 2)
+		    dbs_tuners_ins.disable_hotplug_sleep = zzmoove_profiles[i].disable_hotplug_sleep;
+
+		// ZZ: set hotplug_sleep value
+		if (zzmoove_profiles[i].hotplug_sleep <= possible_cpus && zzmoove_profiles[i].hotplug_sleep >= 0)
+		    dbs_tuners_ins.hotplug_sleep = zzmoove_profiles[i].hotplug_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		// ZZ: set down_threshold value
+		if (zzmoove_profiles[i].down_threshold > 11 && zzmoove_profiles[i].down_threshold <= 100
+		    && zzmoove_profiles[i].down_threshold < zzmoove_profiles[i].up_threshold)
+		    dbs_tuners_ins.down_threshold = zzmoove_profiles[i].down_threshold;
+
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set down_threshold_hotplug1 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug1 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug1 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug1 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug1 = zzmoove_profiles[i].down_threshold_hotplug1;
+		    hotplug_thresholds[1][0] = zzmoove_profiles[i].down_threshold_hotplug1;
+		}
+
+		// ff: set block up multiplier for hotplug1
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug1 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug1 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug1 = zzmoove_profiles[i].block_up_multiplier_hotplug1;
+
+		// ff: set block down multiplier for hotplug1
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug1 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug1 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug1 = zzmoove_profiles[i].block_down_multiplier_hotplug1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set down_threshold_hotplug2 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug2 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug2 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug2 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug2 = zzmoove_profiles[i].down_threshold_hotplug2;
+		    hotplug_thresholds[1][1] = zzmoove_profiles[i].down_threshold_hotplug2;
+		}
+
+		// ff: set block up multiplier for hotplug2
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug2 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug2 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug2 = zzmoove_profiles[i].block_up_multiplier_hotplug2;
+
+		// ff: set block down multiplier for hotplug2
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug2 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug2 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug2 = zzmoove_profiles[i].block_down_multiplier_hotplug2;
+
+		// ZZ: set down_threshold_hotplug3 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug3 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug3 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug3 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug3 = zzmoove_profiles[i].down_threshold_hotplug3;
+		    hotplug_thresholds[1][2] = zzmoove_profiles[i].down_threshold_hotplug3;
+		}
+
+		// ff: set block up multiplier for hotplug3
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug3 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug3 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug3 = zzmoove_profiles[i].block_up_multiplier_hotplug3;
+
+		// ff: set block down multiplier for hotplug3
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug3 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug3 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug3 = zzmoove_profiles[i].block_down_multiplier_hotplug3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set down_threshold_hotplug4 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug4 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug4 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug4 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug4 = zzmoove_profiles[i].down_threshold_hotplug4;
+		    hotplug_thresholds[1][3] = zzmoove_profiles[i].down_threshold_hotplug4;
+		}
+
+		// ff: set block up multiplier for hotplug4
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug4 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug4 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug4 = zzmoove_profiles[i].block_up_multiplier_hotplug4;
+
+		// ff: set block down multiplier for hotplug4
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug4 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug4 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug4 = zzmoove_profiles[i].block_down_multiplier_hotplug4;
+
+		// ZZ: set down_threshold_hotplug5 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug5 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug5 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug5 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug5 = zzmoove_profiles[i].down_threshold_hotplug5;
+		    hotplug_thresholds[1][4] = zzmoove_profiles[i].down_threshold_hotplug5;
+		}
+
+		// ff: set block up multiplier for hotplug5
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug5 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug5 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug5 = zzmoove_profiles[i].block_up_multiplier_hotplug5;
+
+		// ff: set block down multiplier for hotplug5
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug5 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug5 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug5 = zzmoove_profiles[i].block_down_multiplier_hotplug5;
+
+		// ZZ: set down_threshold_hotplug6 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug6 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug6 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug6 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug6 = zzmoove_profiles[i].down_threshold_hotplug6;
+		    hotplug_thresholds[1][5] = zzmoove_profiles[i].down_threshold_hotplug6;
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ff: set block up multiplier for hotplug6
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug6 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug6 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug6 = zzmoove_profiles[i].block_up_multiplier_hotplug6;
+
+		// ff: set block down multiplier for hotplug6
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug6 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug6 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug6 = zzmoove_profiles[i].block_down_multiplier_hotplug6;
+
+		// ZZ: set down_threshold_hotplug7 value
+		if ((zzmoove_profiles[i].down_threshold_hotplug7 <= 100
+		    && zzmoove_profiles[i].down_threshold_hotplug7 >= 1)
+		    || zzmoove_profiles[i].down_threshold_hotplug7 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug7 = zzmoove_profiles[i].down_threshold_hotplug7;
+		    hotplug_thresholds[1][6] = zzmoove_profiles[i].down_threshold_hotplug7;
+		}
+
+		// ff: set block up multiplier for hotplug7
+		if (zzmoove_profiles[i].block_up_multiplier_hotplug7 >= 0 && zzmoove_profiles[i].block_up_multiplier_hotplug7 <= 25)
+		    dbs_tuners_ins.block_up_multiplier_hotplug7 = zzmoove_profiles[i].block_up_multiplier_hotplug7;
+
+		// ff: set block down multiplier for hotplug7
+		if (zzmoove_profiles[i].block_down_multiplier_hotplug7 >= 0 && zzmoove_profiles[i].block_down_multiplier_hotplug7 <= 25)
+		    dbs_tuners_ins.block_down_multiplier_hotplug7 = zzmoove_profiles[i].block_down_multiplier_hotplug7;
+
+#endif /* (MAX_CORES == 8) */
+		// ZZ: set down_threshold_hotplug_freq1 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq1 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq1 = zzmoove_profiles[i].down_threshold_hotplug_freq1;
+		    hotplug_thresholds_freq[1][0] = zzmoove_profiles[i].down_threshold_hotplug_freq1;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq1 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq1);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq1 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq1) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq1 = zzmoove_profiles[i].down_threshold_hotplug_freq1;
+			    hotplug_thresholds_freq[1][0] = zzmoove_profiles[i].down_threshold_hotplug_freq1;
+			}
+		    }
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set down_threshold_hotplug_freq2 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq2 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq2 = zzmoove_profiles[i].down_threshold_hotplug_freq2;
+		    hotplug_thresholds_freq[1][1] = zzmoove_profiles[i].down_threshold_hotplug_freq2;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq2 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq2);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq2 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq2) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq2 = zzmoove_profiles[i].down_threshold_hotplug_freq2;
+			    hotplug_thresholds_freq[1][1] = zzmoove_profiles[i].down_threshold_hotplug_freq2;
+			}
+		    }
+		}
+
+		// ZZ: set down_threshold_hotplug_freq3 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq3 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq3 = zzmoove_profiles[i].down_threshold_hotplug_freq3;
+		    hotplug_thresholds_freq[1][2] = zzmoove_profiles[i].down_threshold_hotplug_freq3;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq3 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq3);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq3 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq3) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq3 = zzmoove_profiles[i].down_threshold_hotplug_freq3;
+			    hotplug_thresholds_freq[1][2] = zzmoove_profiles[i].down_threshold_hotplug_freq3;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set down_threshold_hotplug_freq4 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq4 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq4 = zzmoove_profiles[i].down_threshold_hotplug_freq4;
+		    hotplug_thresholds_freq[1][3] = zzmoove_profiles[i].down_threshold_hotplug_freq4;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq4 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq4);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq4 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq4) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq4 = zzmoove_profiles[i].down_threshold_hotplug_freq4;
+			    hotplug_thresholds_freq[1][3] = zzmoove_profiles[i].down_threshold_hotplug_freq4;
+			}
+		    }
+		}
+
+		// ZZ: set down_threshold_hotplug_freq5 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq5 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq5 = zzmoove_profiles[i].down_threshold_hotplug_freq5;
+		    hotplug_thresholds_freq[1][4] = zzmoove_profiles[i].down_threshold_hotplug_freq5;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq5 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq5);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq5 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq5) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq5 = zzmoove_profiles[i].down_threshold_hotplug_freq5;
+			    hotplug_thresholds_freq[1][4] = zzmoove_profiles[i].down_threshold_hotplug_freq5;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ZZ: set down_threshold_hotplug_freq6 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq6 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq6 = zzmoove_profiles[i].down_threshold_hotplug_freq6;
+		    hotplug_thresholds_freq[1][5] = zzmoove_profiles[i].down_threshold_hotplug_freq6;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq6 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq6);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq6 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq6) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq6 = zzmoove_profiles[i].down_threshold_hotplug_freq6;
+			    hotplug_thresholds_freq[1][5] = zzmoove_profiles[i].down_threshold_hotplug_freq6;
+			}
+		    }
+		}
+
+		// ZZ: set down_threshold_hotplug_freq7 value
+		if (zzmoove_profiles[i].down_threshold_hotplug_freq7 == 0) {
+		    dbs_tuners_ins.down_threshold_hotplug_freq7 = zzmoove_profiles[i].down_threshold_hotplug_freq7;
+		    hotplug_thresholds_freq[1][6] = zzmoove_profiles[i].down_threshold_hotplug_freq7;
+		}
+
+		zzmoove_profiles[i].down_threshold_hotplug_freq7 = check_frequency(zzmoove_profiles[i].down_threshold_hotplug_freq7);
+		if (system_freq_table && zzmoove_profiles[i].down_threshold_hotplug_freq7 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].down_threshold_hotplug_freq7) {
+			    dbs_tuners_ins.down_threshold_hotplug_freq7 = zzmoove_profiles[i].down_threshold_hotplug_freq7;
+			    hotplug_thresholds_freq[1][6] = zzmoove_profiles[i].down_threshold_hotplug_freq7;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set down_threshold_sleep value
+		if (zzmoove_profiles[i].down_threshold_sleep > 11 && zzmoove_profiles[i].down_threshold_sleep <= 100
+		    && zzmoove_profiles[i].down_threshold_sleep < dbs_tuners_ins.up_threshold_sleep)
+		    dbs_tuners_ins.down_threshold_sleep = zzmoove_profiles[i].down_threshold_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// ZZ: set early_demand value
+		dbs_tuners_ins.early_demand = !!zzmoove_profiles[i].early_demand;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		dbs_tuners_ins.early_demand_sleep = !!zzmoove_profiles[i].early_demand_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// Yank: set fast_scaling value
+		if (zzmoove_profiles[i].fast_scaling_up <= 5 && zzmoove_profiles[i].fast_scaling_up >= 0) {
+			dbs_tuners_ins.fast_scaling_up = zzmoove_profiles[i].fast_scaling_up;
+			if (zzmoove_profiles[i].fast_scaling_up > 4)
+				scaling_mode_up = 0;
+			else
+				scaling_mode_up = zzmoove_profiles[i].fast_scaling_up;
+		}
+
+		if (zzmoove_profiles[i].fast_scaling_down <= 5 && zzmoove_profiles[i].fast_scaling_down >= 0) {
+			dbs_tuners_ins.fast_scaling_down = zzmoove_profiles[i].fast_scaling_down;
+			if (zzmoove_profiles[i].fast_scaling_down > 4)
+				scaling_mode_down = 0;
+			else
+				scaling_mode_down = zzmoove_profiles[i].fast_scaling_down;
+		}
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set fast_scaling_sleep value
+		if (zzmoove_profiles[i].fast_scaling_sleep_up <= 5 && zzmoove_profiles[i].fast_scaling_sleep_up >= 0)
+			dbs_tuners_ins.fast_scaling_sleep_up = zzmoove_profiles[i].fast_scaling_sleep_up;
+
+		if (zzmoove_profiles[i].fast_scaling_sleep_down <= 5 && zzmoove_profiles[i].fast_scaling_sleep_down >= 0)
+			dbs_tuners_ins.fast_scaling_sleep_down = zzmoove_profiles[i].fast_scaling_sleep_down;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// ZZ: set afs_threshold1 value
+		if (zzmoove_profiles[i].afs_threshold1 <= 100)
+		    dbs_tuners_ins.afs_threshold1 = zzmoove_profiles[i].afs_threshold1;
+
+		// ZZ: set afs_threshold2 value
+		if (zzmoove_profiles[i].afs_threshold2 <= 100)
+		    dbs_tuners_ins.afs_threshold2 = zzmoove_profiles[i].afs_threshold2;
+
+		// ZZ: set afs_threshold3 value
+		if (zzmoove_profiles[i].afs_threshold3 <= 100)
+		    dbs_tuners_ins.afs_threshold3 = zzmoove_profiles[i].afs_threshold3;
+
+		// ZZ: set afs_threshold4 value
+		if (zzmoove_profiles[i].afs_threshold4 <= 100)
+		    dbs_tuners_ins.afs_threshold4 = zzmoove_profiles[i].afs_threshold4;
+
+		// ZZ: set freq_limit value
+		if (system_freq_table && zzmoove_profiles[i].freq_limit == 0) {
+		    max_scaling_freq_soft = max_scaling_freq_hard;
+
+		    if (freq_table_desc)
+			limit_table_start = max_scaling_freq_soft;
+		    else
+			limit_table_end = system_freq_table[freq_table_size].frequency;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    freq_limit_awake = dbs_tuners_ins.freq_limit = zzmoove_profiles[i].freq_limit;
+#else
+		    dbs_tuners_ins.freq_limit = zzmoove_profiles[i].freq_limit;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		} else if (system_freq_table && zzmoove_profiles[i].freq_limit <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].freq_limit = check_frequency(zzmoove_profiles[i].freq_limit);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].freq_limit) {
+			    max_scaling_freq_soft = t;
+			    if (freq_table_desc)
+				limit_table_start = max_scaling_freq_soft;
+			    else
+				limit_table_end = system_freq_table[t].frequency;
+			}
+		    }
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		    freq_limit_awake = dbs_tuners_ins.freq_limit = zzmoove_profiles[i].freq_limit;
+#else
+		    dbs_tuners_ins.freq_limit = zzmoove_profiles[i].freq_limit;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		}
+
+		// ZZ: set freq_limit_sleep value
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		if (system_freq_table && zzmoove_profiles[i].freq_limit_sleep == 0) {
+		    freq_limit_asleep = dbs_tuners_ins.freq_limit_sleep = zzmoove_profiles[i].freq_limit_sleep;
+
+		} else if (system_freq_table && zzmoove_profiles[i].freq_limit_sleep <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].freq_limit_sleep = check_frequency(zzmoove_profiles[i].freq_limit_sleep);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].freq_limit_sleep)
+			    freq_limit_asleep = dbs_tuners_ins.freq_limit_sleep = zzmoove_profiles[i].freq_limit_sleep;
+		    }
+		}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// ZZ: set grad_up_threshold value
+		if (zzmoove_profiles[i].grad_up_threshold < 100 && zzmoove_profiles[i].grad_up_threshold > 1)
+		    dbs_tuners_ins.grad_up_threshold = zzmoove_profiles[i].grad_up_threshold;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set grad_up_threshold sleep value
+		if (zzmoove_profiles[i].grad_up_threshold_sleep < 100 && zzmoove_profiles[i].grad_up_threshold_sleep > 1)
+		    dbs_tuners_ins.grad_up_threshold_sleep = zzmoove_profiles[i].grad_up_threshold_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set hotplug_block_up_cycles value
+		if (zzmoove_profiles[i].hotplug_block_up_cycles >= 0)
+		    dbs_tuners_ins.hotplug_block_up_cycles = zzmoove_profiles[i].hotplug_block_up_cycles;
+
+		// ZZ: set hotplug_block_down_cycles value
+		if (zzmoove_profiles[i].hotplug_block_down_cycles >= 0)
+		    dbs_tuners_ins.hotplug_block_down_cycles = zzmoove_profiles[i].hotplug_block_down_cycles;
+
+		// ff: set hotplug_stagger_up value
+		if (zzmoove_profiles[i].hotplug_stagger_up >= 0)
+		    dbs_tuners_ins.hotplug_stagger_up = zzmoove_profiles[i].hotplug_stagger_up;
+
+		// ff: set hotplug_stagger_down value
+		if (zzmoove_profiles[i].hotplug_stagger_down >= 0)
+		    dbs_tuners_ins.hotplug_stagger_down = zzmoove_profiles[i].hotplug_stagger_down;
+
+		// ZZ: set hotplug_idle_threshold value
+		if (zzmoove_profiles[i].hotplug_idle_threshold >= 0 && zzmoove_profiles[i].hotplug_idle_threshold < 100)
+		    dbs_tuners_ins.hotplug_idle_threshold = zzmoove_profiles[i].hotplug_idle_threshold;
+
+		// ZZ: set hotplug_idle_freq value
+		if (zzmoove_profiles[i].hotplug_idle_freq == 0) {
+		    dbs_tuners_ins.hotplug_idle_freq = zzmoove_profiles[i].hotplug_idle_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].hotplug_idle_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].hotplug_idle_freq = check_frequency(zzmoove_profiles[i].hotplug_idle_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].hotplug_idle_freq) {
+			    dbs_tuners_ins.hotplug_idle_freq = zzmoove_profiles[i].hotplug_idle_freq;
+			}
+		    }
+		}
+
+		// ZZ: set hotplug_engage_freq value
+		if (zzmoove_profiles[i].hotplug_engage_freq == 0) {
+		    dbs_tuners_ins.hotplug_engage_freq = zzmoove_profiles[i].hotplug_engage_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].hotplug_engage_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].hotplug_engage_freq = check_frequency(zzmoove_profiles[i].hotplug_engage_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].hotplug_engage_freq) {
+			    dbs_tuners_ins.hotplug_engage_freq = zzmoove_profiles[i].hotplug_engage_freq;
+			}
+		    }
+		}
+
+		// ff: set hotplug_max_limit value
+		if (zzmoove_profiles[i].hotplug_max_limit >= 0 && zzmoove_profiles[i].hotplug_max_limit < MAX_CORES)
+		    dbs_tuners_ins.hotplug_max_limit = zzmoove_profiles[i].hotplug_max_limit;
+
+		// ff: set hotplug_min_limit value
+		if (zzmoove_profiles[i].hotplug_min_limit >= 0 && zzmoove_profiles[i].hotplug_min_limit < MAX_CORES)
+		    dbs_tuners_ins.hotplug_min_limit = zzmoove_profiles[i].hotplug_min_limit;
+
+		// ff: set hotplug_lock value
+		if (zzmoove_profiles[i].hotplug_lock >= 0 && zzmoove_profiles[i].hotplug_lock < MAX_CORES)
+		    dbs_tuners_ins.hotplug_lock = zzmoove_profiles[i].hotplug_lock;
+#endif /* ENABLE_HOTPLUGGING */
+#ifdef ENABLE_MUSIC_LIMITS
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set music min cores value
+		if (zzmoove_profiles[i].music_min_cores >= 0 && zzmoove_profiles[i].music_min_cores < MAX_CORES)
+		    dbs_tuners_ins.music_min_cores = zzmoove_profiles[i].music_min_cores;
+#endif /* ENABLE_HOTPLUGGING */
+
+		// ZZ: set music min freq value
+		if (zzmoove_profiles[i].music_min_freq == 0) {
+		    dbs_tuners_ins.music_min_freq = zzmoove_profiles[i].music_min_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].music_min_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].music_min_freq = check_frequency(zzmoove_profiles[i].music_min_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].music_min_freq) {
+			    dbs_tuners_ins.music_min_freq = zzmoove_profiles[i].music_min_freq;
+			}
+		    }
+		}
+
+		// ZZ: set music max freq value
+		if (zzmoove_profiles[i].music_max_freq == 0) {
+		    dbs_tuners_ins.music_max_freq = zzmoove_profiles[i].music_max_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].music_max_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].music_max_freq = check_frequency(zzmoove_profiles[i].music_max_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].music_max_freq) {
+			    dbs_tuners_ins.music_max_freq = zzmoove_profiles[i].music_max_freq;
+			}
+		    }
+		}
+#endif /* ENABLE_MUSIC_LIMITS */
+		// ZZ: set scaling_responsiveness_freq value
+		if (zzmoove_profiles[i].scaling_responsiveness_freq == 0) {
+		    dbs_tuners_ins.scaling_responsiveness_freq = zzmoove_profiles[i].scaling_responsiveness_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].scaling_responsiveness_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].scaling_responsiveness_freq = check_frequency(zzmoove_profiles[i].scaling_responsiveness_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].scaling_responsiveness_freq) {
+			    dbs_tuners_ins.scaling_responsiveness_freq = zzmoove_profiles[i].scaling_responsiveness_freq;
+			}
+		    }
+		}
+
+		// ZZ: set scaling_proportional value
+		if (zzmoove_profiles[i].scaling_proportional > 3) {
+		    dbs_tuners_ins.scaling_proportional = 3;
+		} else if (zzmoove_profiles[i].scaling_proportional < 0) {
+			dbs_tuners_ins.scaling_proportional = 1;
+		} else {
+			dbs_tuners_ins.scaling_proportional = zzmoove_profiles[i].scaling_proportional;
+		}
+#ifdef ENABLE_INPUTBOOSTER
+		// ZZ: set inputboost cycles value
+		if (zzmoove_profiles[i].inputboost_cycles >= 0 && zzmoove_profiles[i].inputboost_cycles <= 1000) {
+			if (!zzmoove_profiles[i].inputboost_cycles && dbs_tuners_ins.inputboost_cycles != zzmoove_profiles[i].inputboost_cycles) {
+			    // ff: input is 0, and it wasn't before.
+			    // ff: so remove booster and unregister.
+			    input_unregister_handler(&interactive_input_handler);
+			} else if (zzmoove_profiles[i].inputboost_cycles && dbs_tuners_ins.inputboost_cycles == 0) {
+			    // ff: input is something other than 0, and it wasn't before,
+			    // ff: so add booster and register.
+			    rc = input_register_handler(&interactive_input_handler);
+			    if (!rc)
+				pr_info("[zzmoove/store_inputboost_cycles] inputbooster - registered\n");
+			    else
+				pr_info("[zzmoove/store_inputboost_cycles] inputbooster - register FAILED\n");
+			}
+		dbs_tuners_ins.inputboost_cycles = zzmoove_profiles[i].inputboost_cycles;
+		}
+
+		// ZZ: set inputboost up threshold value
+		if (zzmoove_profiles[i].inputboost_up_threshold <= 100)
+		    dbs_tuners_ins.inputboost_up_threshold = zzmoove_profiles[i].inputboost_up_threshold;
+
+		// ZZ: set inputboost punch cycles value
+		if (zzmoove_profiles[i].inputboost_punch_cycles >= 0)
+		    dbs_tuners_ins.inputboost_punch_cycles = zzmoove_profiles[i].inputboost_punch_cycles;
+
+		// ZZ: set inputboost freq value
+		if (zzmoove_profiles[i].inputboost_punch_freq == 0) {
+		    dbs_tuners_ins.inputboost_punch_freq = zzmoove_profiles[i].inputboost_punch_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].inputboost_punch_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].inputboost_punch_freq = check_frequency(zzmoove_profiles[i].inputboost_punch_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].inputboost_punch_freq) {
+			    dbs_tuners_ins.inputboost_punch_freq = zzmoove_profiles[i].inputboost_punch_freq;
+			}
+		    }
+		}
+
+		// ZZ: set inputboost punch punch on finger down value
+		if (zzmoove_profiles[i].inputboost_punch_on_fingerdown >= 0)
+		    dbs_tuners_ins.inputboost_punch_on_fingerdown = zzmoove_profiles[i].inputboost_punch_on_fingerdown;
+
+		// ZZ: set inputboost punch punch on finger move value
+		if (zzmoove_profiles[i].inputboost_punch_on_fingermove >= 0)
+		    dbs_tuners_ins.inputboost_punch_on_fingermove = zzmoove_profiles[i].inputboost_punch_on_fingermove;
+
+		// ZZ: set inputboost punch punch on epen move value
+		if (zzmoove_profiles[i].inputboost_punch_on_epenmove >= 0)
+		    dbs_tuners_ins.inputboost_punch_on_epenmove = zzmoove_profiles[i].inputboost_punch_on_epenmove;
+
+		// ZZ: set inputboost up threshold value
+		if (zzmoove_profiles[i].inputboost_typingbooster_up_threshold <= 100)
+		    dbs_tuners_ins.inputboost_typingbooster_up_threshold = zzmoove_profiles[i].inputboost_typingbooster_up_threshold;
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set inputboost cores value
+		if (zzmoove_profiles[i].inputboost_typingbooster_cores >= 0 && zzmoove_profiles[i].inputboost_typingbooster_cores < MAX_CORES)
+		    dbs_tuners_ins.inputboost_typingbooster_cores = zzmoove_profiles[i].inputboost_typingbooster_cores;
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* ENABLE_INPUTBOOSTER */
+
+		// ZZ: set scaling_responsiveness_up_threshold value
+		if (zzmoove_profiles[i].scaling_responsiveness_up_threshold <= 100 && zzmoove_profiles[i].scaling_responsiveness_up_threshold >= 11)
+		    dbs_tuners_ins.scaling_responsiveness_up_threshold = zzmoove_profiles[i].scaling_responsiveness_up_threshold;
+
+		// ZZ: set ignore_nice_load value
+		if (zzmoove_profiles[i].ignore_nice_load > 1)
+		    zzmoove_profiles[i].ignore_nice_load = 1;
+
+		dbs_tuners_ins.ignore_nice = zzmoove_profiles[i].ignore_nice_load;
+
+		// we need to re-evaluate prev_cpu_idle
+		for_each_online_cpu(j) {
+		     struct cpu_dbs_info_s *dbs_info;
+		     dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+		     dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) || defined(CPU_IDLE_TIME_IN_CPUFREQ) /* overrule for sources with backported cpufreq implementation */
+		 &dbs_info->prev_cpu_wall, 0);
+#else
+		 &dbs_info->prev_cpu_wall);
+#endif /* LINUX_VERSION_CODE... */
+		 if (dbs_tuners_ins.ignore_nice)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		     dbs_info->prev_cpu_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];
+#else
+		     dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+#endif /* LINUX_VERSION_CODE... */
+		}
+
+		// ZZ: set sampling_down_factor value
+		if (zzmoove_profiles[i].sampling_down_factor <= MAX_SAMPLING_DOWN_FACTOR
+		    && zzmoove_profiles[i].sampling_down_factor >= 1)
+		    dbs_tuners_ins.sampling_down_factor = zz_sampling_down_factor = zzmoove_profiles[i].sampling_down_factor;
+
+		    // ZZ: Reset down sampling multiplier in case it was active
+		    for_each_online_cpu(j) {
+			struct cpu_dbs_info_s *dbs_info;
+			dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+			dbs_info->rate_mult = 1;
+		    }
+
+		// ZZ: set sampling_down_max_momentum value
+		if (zzmoove_profiles[i].sampling_down_max_momentum <= MAX_SAMPLING_DOWN_FACTOR - dbs_tuners_ins.sampling_down_factor
+		    && zzmoove_profiles[i].sampling_down_max_momentum >= 0) {
+		    dbs_tuners_ins.sampling_down_max_mom = zz_sampling_down_max_mom = zzmoove_profiles[i].sampling_down_max_momentum;
+		    orig_sampling_down_max_mom = dbs_tuners_ins.sampling_down_max_mom;
+		}
+
+		// ZZ: Reset sampling down factor to default if momentum was disabled
+		if (dbs_tuners_ins.sampling_down_max_mom == 0)
+		    zz_sampling_down_factor = DEF_SAMPLING_DOWN_FACTOR;
+
+		    // ZZ: Reset momentum_adder and reset down sampling multiplier in case momentum was disabled
+		    for_each_online_cpu(j) {
+			struct cpu_dbs_info_s *dbs_info;
+			dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+			dbs_info->momentum_adder = 0;
+			if (dbs_tuners_ins.sampling_down_max_mom == 0)
+			dbs_info->rate_mult = 1;
+		    }
+
+		// ZZ: set sampling_down_momentum_sensitivity value
+		if (zzmoove_profiles[i].sampling_down_momentum_sensitivity <= MAX_SAMPLING_DOWN_MOMENTUM_SENSITIVITY
+		    && zzmoove_profiles[i].sampling_down_momentum_sensitivity >= 1) {
+		    dbs_tuners_ins.sampling_down_mom_sens = zzmoove_profiles[i].sampling_down_momentum_sensitivity;
+
+		    // ZZ: Reset momentum_adder
+		    for_each_online_cpu(j) {
+			struct cpu_dbs_info_s *dbs_info;
+			dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+			dbs_info->momentum_adder = 0;
+		    }
+
+		// ZZ: set sampling_rate value
+		dbs_tuners_ins.sampling_rate = dbs_tuners_ins.sampling_rate_current
+		= max(zzmoove_profiles[i].sampling_rate, min_sampling_rate);
+
+		// ZZ: set sampling_rate_idle value
+		if (zzmoove_profiles[i].sampling_rate_idle == 0) {
+		    dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate
+		    = dbs_tuners_ins.sampling_rate_idle;
+		} else {
+		    dbs_tuners_ins.sampling_rate_idle = max(zzmoove_profiles[i].sampling_rate_idle, min_sampling_rate);
+		}
+
+		// ZZ: set sampling_rate_idle_delay value
+		if (zzmoove_profiles[i].sampling_rate_idle_delay >= 0) {
+		    sampling_rate_step_up_delay = 0;
+		    sampling_rate_step_down_delay = 0;
+		    dbs_tuners_ins.sampling_rate_idle_delay = zzmoove_profiles[i].sampling_rate_idle_delay;
+		}
+
+		// ZZ: set sampling_rate_idle_threshold value
+		if (zzmoove_profiles[i].sampling_rate_idle_threshold <= 100)
+		    dbs_tuners_ins.sampling_rate_idle_threshold = zzmoove_profiles[i].sampling_rate_idle_threshold;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set sampling_rate_sleep_multiplier value
+		if (zzmoove_profiles[i].sampling_rate_sleep_multiplier <= MAX_SAMPLING_RATE_SLEEP_MULTIPLIER
+		    && zzmoove_profiles[i].sampling_rate_sleep_multiplier >= 1)
+		    dbs_tuners_ins.sampling_rate_sleep_multiplier = zzmoove_profiles[i].sampling_rate_sleep_multiplier;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// ZZ: set scaling_block_cycles value
+		if (zzmoove_profiles[i].scaling_block_cycles >= 0) {
+		    dbs_tuners_ins.scaling_block_cycles = zzmoove_profiles[i].scaling_block_cycles;
+		    if (zzmoove_profiles[i].scaling_block_cycles == 0)
+			scaling_block_cycles_count = 0;
+		}
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		// ZZ: set scaling_block_temp value
+		if ((zzmoove_profiles[i].scaling_block_temp >= 30 && zzmoove_profiles[i].scaling_block_temp <= 80)
+		    || zzmoove_profiles[i].scaling_block_temp == 0) {
+		    dbs_tuners_ins.scaling_block_temp = zzmoove_profiles[i].scaling_block_temp;
+		}
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+		// ZZ: set scaling_block_freq value
+		if (zzmoove_profiles[i].scaling_block_freq == 0) {
+		    dbs_tuners_ins.scaling_block_freq = zzmoove_profiles[i].scaling_block_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].scaling_block_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].scaling_block_freq = check_frequency(zzmoove_profiles[i].scaling_block_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].scaling_block_freq) {
+			    dbs_tuners_ins.scaling_block_freq = zzmoove_profiles[i].scaling_block_freq;
+			}
+		    }
+		}
+
+		// ZZ: set scaling_block_threshold value
+		if (zzmoove_profiles[i].scaling_block_threshold >= 0
+		    && zzmoove_profiles[i].scaling_block_threshold <= 100)
+		    dbs_tuners_ins.scaling_block_threshold = zzmoove_profiles[i].scaling_block_threshold;
+
+		// ZZ: set scaling_block_force_down value
+		if (zzmoove_profiles[i].scaling_block_force_down >= 0
+		    && zzmoove_profiles[i].scaling_block_force_down != 1)
+		    dbs_tuners_ins.scaling_block_force_down = zzmoove_profiles[i].scaling_block_force_down;
+
+		// ZZ: set scaling_fastdown_freq value
+		if (zzmoove_profiles[i].scaling_fastdown_freq == 0) {
+		    dbs_tuners_ins.scaling_fastdown_freq = zzmoove_profiles[i].scaling_fastdown_freq;
+
+		} else if (system_freq_table && zzmoove_profiles[i].scaling_fastdown_freq <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].scaling_fastdown_freq = check_frequency(zzmoove_profiles[i].scaling_fastdown_freq);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].scaling_fastdown_freq) {
+			    dbs_tuners_ins.scaling_fastdown_freq = zzmoove_profiles[i].scaling_fastdown_freq;
+			}
+		    }
+		}
+
+		// ZZ: set scaling_fastdown_up_threshold value
+		if (zzmoove_profiles[i].scaling_fastdown_up_threshold <= 100 && zzmoove_profiles[i].scaling_fastdown_up_threshold
+		    > zzmoove_profiles[i].scaling_fastdown_down_threshold)
+		    dbs_tuners_ins.scaling_fastdown_up_threshold = zzmoove_profiles[i].scaling_fastdown_up_threshold;
+
+		// ZZ: set scaling_fastdown_down_threshold value
+		if (zzmoove_profiles[i].scaling_fastdown_down_threshold < zzmoove_profiles[i].scaling_fastdown_up_threshold
+		    && zzmoove_profiles[i].scaling_fastdown_down_threshold > 11)
+		    dbs_tuners_ins.scaling_fastdown_down_threshold = zzmoove_profiles[i].scaling_fastdown_down_threshold;
+
+		// ZZ: set smooth_up value
+		if (zzmoove_profiles[i].smooth_up <= 100 && zzmoove_profiles[i].smooth_up >= 1)
+		    dbs_tuners_ins.smooth_up = zzmoove_profiles[i].smooth_up;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set smooth_up_sleep value
+		if (zzmoove_profiles[i].smooth_up_sleep <= 100 && zzmoove_profiles[i].smooth_up_sleep >= 1)
+		    dbs_tuners_ins.smooth_up_sleep = zzmoove_profiles[i].smooth_up_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		// ZZ: set up_threshold value
+		if (zzmoove_profiles[i].up_threshold <= 100 && zzmoove_profiles[i].up_threshold
+		    >= zzmoove_profiles[i].down_threshold)
+		    dbs_tuners_ins.up_threshold = zzmoove_profiles[i].up_threshold;
+#ifdef ENABLE_HOTPLUGGING
+		// ZZ: set up_threshold_hotplug1 value
+		if (zzmoove_profiles[i].up_threshold_hotplug1 >= 0 && zzmoove_profiles[i].up_threshold_hotplug1 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug1 = zzmoove_profiles[i].up_threshold_hotplug1;
+		    hotplug_thresholds[0][0] = zzmoove_profiles[i].up_threshold_hotplug1;
+		}
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug2 value
+		if (zzmoove_profiles[i].up_threshold_hotplug2 >= 0 && zzmoove_profiles[i].up_threshold_hotplug2 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug2 = zzmoove_profiles[i].up_threshold_hotplug2;
+		    hotplug_thresholds[0][1] = zzmoove_profiles[i].up_threshold_hotplug2;
+		}
+
+		// ZZ: set up_threshold_hotplug3 value
+		if (zzmoove_profiles[i].up_threshold_hotplug3 >= 0 && zzmoove_profiles[i].up_threshold_hotplug3 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug3 = zzmoove_profiles[i].up_threshold_hotplug3;
+		    hotplug_thresholds[0][2] = zzmoove_profiles[i].up_threshold_hotplug3;
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug4 value
+		if (zzmoove_profiles[i].up_threshold_hotplug4 >= 0 && zzmoove_profiles[i].up_threshold_hotplug4 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug4 = zzmoove_profiles[i].up_threshold_hotplug4;
+		    hotplug_thresholds[0][3] = zzmoove_profiles[i].up_threshold_hotplug4;
+		}
+
+		// ZZ: set up_threshold_hotplug5 value
+		if (zzmoove_profiles[i].up_threshold_hotplug5 >= 0 && zzmoove_profiles[i].up_threshold_hotplug5 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug5 = zzmoove_profiles[i].up_threshold_hotplug5;
+		    hotplug_thresholds[0][4] = zzmoove_profiles[i].up_threshold_hotplug5;
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug6 value
+		if (zzmoove_profiles[i].up_threshold_hotplug6 >= 0 && zzmoove_profiles[i].up_threshold_hotplug6 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug6 = zzmoove_profiles[i].up_threshold_hotplug6;
+		    hotplug_thresholds[0][5] = zzmoove_profiles[i].up_threshold_hotplug6;
+		}
+
+		// ZZ: set up_threshold_hotplug7 value
+		if (zzmoove_profiles[i].up_threshold_hotplug7 >= 0 && zzmoove_profiles[i].up_threshold_hotplug7 <= 100) {
+		    dbs_tuners_ins.up_threshold_hotplug7 = zzmoove_profiles[i].up_threshold_hotplug7;
+		    hotplug_thresholds[0][6] = zzmoove_profiles[i].up_threshold_hotplug7;
+		}
+#endif /* (MAX_CORES == 8) */
+		// ZZ: set up_threshold_hotplug_freq1 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq1 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq1 = zzmoove_profiles[i].up_threshold_hotplug_freq1;
+		    hotplug_thresholds_freq[0][0] = zzmoove_profiles[i].up_threshold_hotplug_freq1;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq1 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq1 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq1);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+		        if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq1) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq1 = zzmoove_profiles[i].up_threshold_hotplug_freq1;
+			    hotplug_thresholds_freq[0][0] = zzmoove_profiles[i].up_threshold_hotplug_freq1;
+		        }
+		    }
+		}
+
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug_freq2 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq2 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq2 = zzmoove_profiles[i].up_threshold_hotplug_freq2;
+		    hotplug_thresholds_freq[0][1] = zzmoove_profiles[i].up_threshold_hotplug_freq2;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq2 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq2 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq2);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq2) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq2 = zzmoove_profiles[i].up_threshold_hotplug_freq2;
+			    hotplug_thresholds_freq[0][1] = zzmoove_profiles[i].up_threshold_hotplug_freq2;
+			}
+		    }
+		}
+
+		// ZZ: set up_threshold_hotplug_freq3 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq3 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq3 = zzmoove_profiles[i].up_threshold_hotplug_freq3;
+		    hotplug_thresholds_freq[0][2] = zzmoove_profiles[i].up_threshold_hotplug_freq3;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq3 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq3 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq3);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq3) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq3 = zzmoove_profiles[i].up_threshold_hotplug_freq3;
+			    hotplug_thresholds_freq[0][2] = zzmoove_profiles[i].up_threshold_hotplug_freq3;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug_freq4 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq4 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq4 = zzmoove_profiles[i].up_threshold_hotplug_freq4;
+		    hotplug_thresholds_freq[0][3] = zzmoove_profiles[i].up_threshold_hotplug_freq4;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq4 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq4 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq4);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq4) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq4 = zzmoove_profiles[i].up_threshold_hotplug_freq4;
+			    hotplug_thresholds_freq[0][3] = zzmoove_profiles[i].up_threshold_hotplug_freq4;
+			}
+		    }
+		}
+
+		// ZZ: set up_threshold_hotplug_freq5 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq5 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq5 = zzmoove_profiles[i].up_threshold_hotplug_freq5;
+		    hotplug_thresholds_freq[0][4] = zzmoove_profiles[i].up_threshold_hotplug_freq5;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq5 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq5 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq5);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq5) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq5 = zzmoove_profiles[i].up_threshold_hotplug_freq5;
+			    hotplug_thresholds_freq[0][4] = zzmoove_profiles[i].up_threshold_hotplug_freq5;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		// ZZ: set up_threshold_hotplug_freq6 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq6 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq6 = zzmoove_profiles[i].up_threshold_hotplug_freq6;
+		    hotplug_thresholds_freq[0][5] = zzmoove_profiles[i].up_threshold_hotplug_freq6;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq6 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq6 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq6);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq6) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq6 = zzmoove_profiles[i].up_threshold_hotplug_freq6;
+			    hotplug_thresholds_freq[0][5] = zzmoove_profiles[i].up_threshold_hotplug_freq6;
+			}
+		    }
+		}
+
+		// ZZ: set up_threshold_hotplug_freq7 value
+		if (zzmoove_profiles[i].up_threshold_hotplug_freq7 == 0) {
+		    dbs_tuners_ins.up_threshold_hotplug_freq7 = zzmoove_profiles[i].up_threshold_hotplug_freq7;
+		    hotplug_thresholds_freq[0][6] = zzmoove_profiles[i].up_threshold_hotplug_freq7;
+		}
+
+		if (system_freq_table && zzmoove_profiles[i].up_threshold_hotplug_freq7 <= system_freq_table[max_scaling_freq_hard].frequency) {
+		    zzmoove_profiles[i].up_threshold_hotplug_freq7 = check_frequency(zzmoove_profiles[i].up_threshold_hotplug_freq7);
+		    for (t = 0; (system_freq_table[t].frequency != system_table_end); t++) {
+			if (system_freq_table[t].frequency == zzmoove_profiles[i].up_threshold_hotplug_freq7) {
+			    dbs_tuners_ins.up_threshold_hotplug_freq7 = zzmoove_profiles[i].up_threshold_hotplug_freq7;
+			    hotplug_thresholds_freq[0][6] = zzmoove_profiles[i].up_threshold_hotplug_freq7;
+			}
+		    }
+		}
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		// ZZ: set up_threshold_sleep value
+		if (zzmoove_profiles[i].up_threshold_sleep <= 100 && zzmoove_profiles[i].up_threshold_sleep
+		    > dbs_tuners_ins.down_threshold_sleep)
+		    dbs_tuners_ins.up_threshold_sleep = zzmoove_profiles[i].up_threshold_sleep;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		// ZZ: set auto_adjust_freq_thresholds value
+		if (zzmoove_profiles[i].auto_adjust_freq_thresholds > 1) {
+		    zzmoove_profiles[i].auto_adjust_freq_thresholds = 1;
+		    dbs_tuners_ins.auto_adjust_freq_thresholds = zzmoove_profiles[i].auto_adjust_freq_thresholds;
+		} else {
+		    dbs_tuners_ins.auto_adjust_freq_thresholds = zzmoove_profiles[i].auto_adjust_freq_thresholds;
+		    pol_step = 0;
+		}
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+		// ZZ: set current profile number
+		dbs_tuners_ins.profile_number = profile_num;
+
+		// ZZ: set current profile name
+		strncpy(dbs_tuners_ins.profile, zzmoove_profiles[i].profile_name, sizeof(dbs_tuners_ins.profile));
+		set_profile_active = false; // ZZ: profile found - allow setting of tuneables again
+		return 1;
+	    }
+	}
+    }
+// ZZ: profile not found - allow setting of tuneables again
+set_profile_active = false;
+return 0;
+}
+
+// ff: added tuneable profile_sticky_mode -> possible values: 0 disabled, anything else enabled
+static ssize_t store_profile_sticky_mode(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1 || input < 0)
+	return -EINVAL;
+
+	dbs_tuners_ins.profile_sticky_mode = !!input;
+	return count;
+}
+
+// ZZ: tunable profile number -> for switching settings profiles, check zzmoove_profiles.h file for possible values
+static ssize_t store_profile_number(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;				// ZZ: regular input handling of this tuneable
+	int ret_profile;				// ZZ: return value for set_profile function
+	int ret;					// ZZ: regular input handling of this tuneable
+
+	ret = sscanf(buf, "%u", &input);		// ZZ: regular input handling of this tuneable
+
+	if (ret != 1)
+	    return -EINVAL;
+
+	// ZZ: if input is 0 set profile to custom mode
+	if (input == 0) {
+	    dbs_tuners_ins.profile_number = input;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	return count;
+	}
+
+	// ZZ: set profile and check result
+	ret_profile = set_profile(input);
+
+	if (ret_profile != 1)
+	    return -EINVAL; // ZZ: given profile not available
+	else
+	    return count; // ZZ: profile found return as normal
+}
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+// ZZ: tunable auto adjust freq thresholds -> for a automatic adjustment of all freq thresholds.
+static ssize_t store_auto_adjust_freq_thresholds(struct kobject *a, struct attribute *b, const char *buf, size_t count)
+{
+	unsigned int input;
+	int ret;
+
+	ret = sscanf(buf, "%u", &input);
+
+	if (ret != 1
+#ifdef ENABLE_PROFILES_SUPPORT
+	    || set_profile_active == true)
+#else
+	    )
+#endif /* ENABLE_PROFILES_SUPPORT */
+	    return -EINVAL;
+
+	input = !!input;
+
+	if (input == 0)
+	    pol_step = 0;
+#ifdef ENABLE_PROFILES_SUPPORT
+	// ZZ: set profile number to 0 and profile name to custom mode if value has changed
+	if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0 && dbs_tuners_ins.auto_adjust_freq_thresholds != input) {
+	    dbs_tuners_ins.profile_number = 0;
+	    strncpy(dbs_tuners_ins.profile, custom_profile, sizeof(dbs_tuners_ins.profile));
+	}
+#endif /* ENABLE_PROFILES_SUPPORT */
+	dbs_tuners_ins.auto_adjust_freq_thresholds = input;
+
+	return count;
+}
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+
+// Yank: add hotplug up/down threshold sysfs store interface
+#ifdef ENABLE_HOTPLUGGING
+#ifdef ENABLE_PROFILES_SUPPORT
+#define store_up_threshold_hotplug_freq(name,core)						\
+static ssize_t store_up_threshold_hotplug_freq##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	int i = 0;										\
+												\
+	ret = sscanf(buf, "%u", &input);							\
+	if (ret != 1 || set_profile_active == true)						\
+	    return -EINVAL;									\
+												\
+	if (input == 0) {									\
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0	\
+	    && (dbs_tuners_ins.up_threshold_hotplug_freq##name != input				\
+	    || hotplug_thresholds_freq[0][core] == input)) {					\
+		dbs_tuners_ins.profile_number = 0;						\
+		strncpy(dbs_tuners_ins.profile, custom_profile,					\
+		sizeof(dbs_tuners_ins.profile));						\
+	    }											\
+	    dbs_tuners_ins.up_threshold_hotplug_freq##name = input;				\
+	    hotplug_thresholds_freq[0][core] = input;						\
+	return count;										\
+	}											\
+												\
+	input = check_frequency(input);								\
+												\
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {			\
+	    return -EINVAL;									\
+	} else {										\
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {	\
+		    if (unlikely(system_freq_table[i].frequency == input)) {			\
+			if (dbs_tuners_ins.profile_number != 0					\
+			&& !dbs_tuners_ins.profile_sticky_mode					\
+			&& (dbs_tuners_ins.up_threshold_hotplug_freq##name != input		\
+			|| hotplug_thresholds_freq[0][core] == input)) {			\
+			    dbs_tuners_ins.profile_number = 0;					\
+			    strncpy(dbs_tuners_ins.profile, custom_profile,			\
+			    sizeof(dbs_tuners_ins.profile));					\
+			}									\
+			dbs_tuners_ins.up_threshold_hotplug_freq##name = input;			\
+			hotplug_thresholds_freq[0][core] = input;				\
+		    return count;								\
+		    }										\
+	    }											\
+	}											\
+	return -EINVAL;										\
+}												\
+
+#define store_down_threshold_hotplug_freq(name,core)						\
+static ssize_t store_down_threshold_hotplug_freq##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	int i = 0;										\
+												\
+	ret = sscanf(buf, "%u", &input);							\
+	if (ret != 1 || set_profile_active == true)						\
+	    return -EINVAL;									\
+												\
+	if (input == 0) {									\
+	    if (!dbs_tuners_ins.profile_sticky_mode && dbs_tuners_ins.profile_number != 0	\
+	    && (dbs_tuners_ins.down_threshold_hotplug_freq##name != input			\
+	    || hotplug_thresholds_freq[1][core] == input)) {					\
+		dbs_tuners_ins.profile_number = 0;						\
+		strncpy(dbs_tuners_ins.profile, custom_profile,					\
+		sizeof(dbs_tuners_ins.profile));						\
+	    }											\
+	    dbs_tuners_ins.down_threshold_hotplug_freq##name = input;				\
+	    hotplug_thresholds_freq[1][core] = input;						\
+	return count;										\
+	}											\
+												\
+	input = check_frequency(input);								\
+												\
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {			\
+	    return -EINVAL;									\
+	} else {										\
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {	\
+		    if (unlikely(system_freq_table[i].frequency == input)) {			\
+			if (dbs_tuners_ins.profile_number != 0					\
+			&& !dbs_tuners_ins.profile_sticky_mode					\
+			&& (dbs_tuners_ins.down_threshold_hotplug_freq##name != input		\
+			|| hotplug_thresholds_freq[1][core] == input)) {			\
+			    dbs_tuners_ins.profile_number = 0;					\
+			    strncpy(dbs_tuners_ins.profile, custom_profile,			\
+			    sizeof(dbs_tuners_ins.profile));					\
+			}									\
+			dbs_tuners_ins.down_threshold_hotplug_freq##name = input;		\
+			hotplug_thresholds_freq[1][core] = input;				\
+		    return count;								\
+		    }										\
+	    }											\
+	}											\
+	return -EINVAL;										\
+}												\
+
+/*
+ * ZZ: tuneables -> possible values: 0 to disable core (only in up thresholds), range from above
+ * appropriate down thresholds up to scaling max frequency, if not set default for up and down
+ * thresholds is 0
+ */
+store_up_threshold_hotplug_freq(1,0);
+store_down_threshold_hotplug_freq(1,0);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug_freq(2,1);
+store_down_threshold_hotplug_freq(2,1);
+store_up_threshold_hotplug_freq(3,2);
+store_down_threshold_hotplug_freq(3,2);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug_freq(4,3);
+store_down_threshold_hotplug_freq(4,3);
+store_up_threshold_hotplug_freq(5,4);
+store_down_threshold_hotplug_freq(5,4);
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+store_up_threshold_hotplug_freq(6,5);
+store_down_threshold_hotplug_freq(6,5);
+store_up_threshold_hotplug_freq(7,6);
+store_down_threshold_hotplug_freq(7,6);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+#ifndef ENABLE_PROFILES_SUPPORT
+#define store_up_threshold_hotplug_freq(name,core)						\
+static ssize_t store_up_threshold_hotplug_freq##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	int i = 0;										\
+												\
+	ret = sscanf(buf, "%u", &input);							\
+	if (ret != 1)										\
+	    return -EINVAL;									\
+												\
+	if (input == 0) {									\
+	    dbs_tuners_ins.up_threshold_hotplug_freq##name = input;				\
+	    hotplug_thresholds_freq[0][core] = input;						\
+	return count;										\
+	}											\
+												\
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {			\
+	    return -EINVAL;									\
+	} else {										\
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {	\
+		    if (unlikely(system_freq_table[i].frequency == input)) {			\
+			dbs_tuners_ins.up_threshold_hotplug_freq##name = input;			\
+			hotplug_thresholds_freq[0][core] = input;				\
+		    return count;								\
+		    }										\
+	    }											\
+	}											\
+	return -EINVAL;										\
+}												\
+
+#define store_down_threshold_hotplug_freq(name,core)						\
+static ssize_t store_down_threshold_hotplug_freq##name						\
+(struct kobject *a, struct attribute *b, const char *buf, size_t count)				\
+{												\
+	unsigned int input;									\
+	int ret;										\
+	int i = 0;										\
+												\
+	ret = sscanf(buf, "%u", &input);							\
+	if (ret != 1)										\
+	    return -EINVAL;									\
+												\
+	if (input == 0) {									\
+	    dbs_tuners_ins.down_threshold_hotplug_freq##name = input;				\
+	    hotplug_thresholds_freq[1][core] = input;						\
+	return count;										\
+	}											\
+												\
+	if (input > system_freq_table[max_scaling_freq_hard].frequency) {			\
+	    return -EINVAL;									\
+	} else {										\
+	    for (i = 0; (likely(system_freq_table[i].frequency != system_table_end)); i++) {	\
+		    if (unlikely(system_freq_table[i].frequency == input)) {			\
+			dbs_tuners_ins.down_threshold_hotplug_freq##name = input;		\
+			hotplug_thresholds_freq[1][core] = input;				\
+		    return count;								\
+		    }										\
+	    }											\
+	}											\
+	return -EINVAL;										\
+}												\
+
+/*
+ * ZZ: tuneables -> possible values: 0 to disable core (only in up thresholds), range from above
+ * appropriate down thresholds up to scaling max frequency, if not set default for up and down
+ * thresholds is 0
+ */
+store_up_threshold_hotplug_freq(1,0);
+store_down_threshold_hotplug_freq(1,0);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug_freq(2,1);
+store_down_threshold_hotplug_freq(2,1);
+store_up_threshold_hotplug_freq(3,2);
+store_down_threshold_hotplug_freq(3,2);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+store_up_threshold_hotplug_freq(4,3);
+store_down_threshold_hotplug_freq(4,3);
+store_up_threshold_hotplug_freq(5,4);
+store_down_threshold_hotplug_freq(5,4);
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+store_up_threshold_hotplug_freq(6,5);
+store_down_threshold_hotplug_freq(6,5);
+store_up_threshold_hotplug_freq(7,6);
+store_down_threshold_hotplug_freq(7,6);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_PROFILES_SUPPORT */
+#endif /* ENABLE_HOTPLUGGING */
+
+#ifdef ENABLE_PROFILES_SUPPORT
+define_one_global_rw(profile_number);
+define_one_global_rw(profile_sticky_mode);
+define_one_global_ro(profile);
+#endif /* ENABLE_PROFILES_SUPPORT */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+define_one_global_rw(auto_adjust_freq_thresholds);
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+define_one_global_ro(sampling_rate_current);
+define_one_global_rw(sampling_rate);
+define_one_global_rw(sampling_rate_idle_threshold);
+define_one_global_rw(sampling_rate_idle);
+define_one_global_rw(sampling_rate_idle_delay);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(sampling_rate_sleep_multiplier);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(sampling_down_factor);
+define_one_global_rw(sampling_down_max_momentum);
+define_one_global_rw(sampling_down_momentum_sensitivity);
+define_one_global_rw(up_threshold);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(up_threshold_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+define_one_global_rw(up_threshold_hotplug1);
+define_one_global_rw(up_threshold_hotplug_freq1);
+define_one_global_rw(block_up_multiplier_hotplug1);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+define_one_global_rw(up_threshold_hotplug2);
+define_one_global_rw(up_threshold_hotplug_freq2);
+define_one_global_rw(block_up_multiplier_hotplug2);
+define_one_global_rw(up_threshold_hotplug3);
+define_one_global_rw(up_threshold_hotplug_freq3);
+define_one_global_rw(block_up_multiplier_hotplug3);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+define_one_global_rw(up_threshold_hotplug4);
+define_one_global_rw(up_threshold_hotplug_freq4);
+define_one_global_rw(block_up_multiplier_hotplug4);
+define_one_global_rw(up_threshold_hotplug5);
+define_one_global_rw(up_threshold_hotplug_freq5);
+define_one_global_rw(block_up_multiplier_hotplug5);
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+define_one_global_rw(up_threshold_hotplug6);
+define_one_global_rw(up_threshold_hotplug_freq6);
+define_one_global_rw(block_up_multiplier_hotplug6);
+define_one_global_rw(up_threshold_hotplug7);
+define_one_global_rw(up_threshold_hotplug_freq7);
+define_one_global_rw(block_up_multiplier_hotplug7);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+define_one_global_rw(down_threshold);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(down_threshold_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+define_one_global_rw(down_threshold_hotplug1);
+define_one_global_rw(down_threshold_hotplug_freq1);
+define_one_global_rw(block_down_multiplier_hotplug1);
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+define_one_global_rw(down_threshold_hotplug2);
+define_one_global_rw(down_threshold_hotplug_freq2);
+define_one_global_rw(block_down_multiplier_hotplug2);
+define_one_global_rw(down_threshold_hotplug3);
+define_one_global_rw(down_threshold_hotplug_freq3);
+define_one_global_rw(block_down_multiplier_hotplug3);
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+define_one_global_rw(down_threshold_hotplug4);
+define_one_global_rw(down_threshold_hotplug_freq4);
+define_one_global_rw(block_down_multiplier_hotplug4);
+define_one_global_rw(down_threshold_hotplug5);
+define_one_global_rw(down_threshold_hotplug_freq5);
+define_one_global_rw(block_down_multiplier_hotplug5);
+#endif
+#if (MAX_CORES == 8)
+define_one_global_rw(down_threshold_hotplug6);
+define_one_global_rw(down_threshold_hotplug_freq6);
+define_one_global_rw(block_down_multiplier_hotplug6);
+define_one_global_rw(down_threshold_hotplug7);
+define_one_global_rw(down_threshold_hotplug_freq7);
+define_one_global_rw(block_down_multiplier_hotplug7);
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+define_one_global_rw(ignore_nice_load);
+define_one_global_rw(smooth_up);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(smooth_up_sleep);
+#ifdef ENABLE_HOTPLUGGING
+define_one_global_rw(hotplug_sleep);
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(freq_limit);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(freq_limit_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(fast_scaling_up);
+define_one_global_rw(fast_scaling_down);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(fast_scaling_sleep_up);
+define_one_global_rw(fast_scaling_sleep_down);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(afs_threshold1);
+define_one_global_rw(afs_threshold2);
+define_one_global_rw(afs_threshold3);
+define_one_global_rw(afs_threshold4);
+define_one_global_rw(grad_up_threshold);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(grad_up_threshold_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(early_demand);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(early_demand_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+define_one_global_rw(disable_hotplug);
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+define_one_global_rw(disable_hotplug_sleep);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+define_one_global_rw(hotplug_block_up_cycles);
+define_one_global_rw(hotplug_block_down_cycles);
+define_one_global_rw(hotplug_stagger_up);
+define_one_global_rw(hotplug_stagger_down);
+define_one_global_rw(hotplug_idle_threshold);
+define_one_global_rw(hotplug_idle_freq);
+define_one_global_rw(hotplug_engage_freq);
+define_one_global_rw(hotplug_max_limit);
+define_one_global_rw(hotplug_min_limit);
+define_one_global_rw(hotplug_lock);
+#endif /* ENABLE_HOTPLUGGING */
+define_one_global_rw(scaling_block_threshold);
+define_one_global_rw(scaling_block_cycles);
+define_one_global_rw(scaling_up_block_cycles);
+define_one_global_rw(scaling_up_block_freq);
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+define_one_global_rw(scaling_block_temp);
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+define_one_global_rw(scaling_trip_temp);
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+define_one_global_rw(scaling_block_freq);
+define_one_global_rw(scaling_block_force_down);
+define_one_global_rw(scaling_fastdown_freq);
+define_one_global_rw(scaling_fastdown_up_threshold);
+define_one_global_rw(scaling_fastdown_down_threshold);
+define_one_global_rw(scaling_responsiveness_freq);
+define_one_global_rw(scaling_responsiveness_up_threshold);
+define_one_global_rw(scaling_proportional);
+#ifdef ENABLE_INPUTBOOSTER
+// ff: Input Booster
+define_one_global_rw(inputboost_cycles);
+define_one_global_rw(inputboost_up_threshold);
+define_one_global_rw(inputboost_punch_cycles);
+define_one_global_rw(inputboost_punch_freq);
+define_one_global_rw(inputboost_punch_on_fingerdown);
+define_one_global_rw(inputboost_punch_on_fingermove);
+define_one_global_rw(inputboost_punch_on_epenmove);
+define_one_global_rw(inputboost_typingbooster_up_threshold);
+define_one_global_rw(inputboost_typingbooster_cores);
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+// ff: Music Detection
+define_one_global_rw(music_max_freq);
+define_one_global_rw(music_min_freq);
+#ifdef ENABLE_HOTPLUGGING
+define_one_global_rw(music_min_cores);
+#endif /* ENABLE_HOTPLUGGING */
+define_one_global_rw(music_state);
+#endif /* ENABLE_MUSIC_LIMITS */
+// Yank: version info tunable
+static ssize_t show_version(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", ZZMOOVE_VERSION);
+}
+
+static DEVICE_ATTR(version, S_IRUGO , show_version, NULL);
+
+#ifdef ENABLE_PROFILES_SUPPORT
+// ZZ: profiles version info tunable
+static ssize_t show_version_profiles(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n", profiles_file_version);
+}
+
+static DEVICE_ATTR(version_profiles, S_IRUGO , show_version_profiles, NULL);
+
+// ZZ: print out all available profiles
+static ssize_t show_profile_list(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int i = 0, c = 0;
+    char profiles[512];
+
+    for (i = 0; (zzmoove_profiles[i].profile_number != PROFILE_TABLE_END); i++) {
+	c += sprintf(profiles+c, "profile: %d " "name: %s\n", zzmoove_profiles[i].profile_number,
+	zzmoove_profiles[i].profile_name);
+    }
+    return sprintf(buf, profiles);
+}
+
+static DEVICE_ATTR(profile_list, S_IRUGO , show_profile_list, NULL);
+#endif /* ENABLE_PROFILES_SUPPORT */
+
+#ifdef ZZMOOVE_DEBUG
+// Yank: debug info
+static ssize_t show_zzmoove_debug(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return sprintf(buf, "available cores                : %d\n"
+#if (MAX_CORES == 2 || MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+			"core 0 online                  : %d\n"
+			"core 1 online                  : %d\n"
+#endif /* (MAX_CORES == 2 || MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+			"core 2 online                  : %d\n"
+			"core 3 online                  : %d\n"
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+			"core 4 online                  : %d\n"
+			"core 5 online                  : %d\n"
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+			"core 6 online                  : %d\n"
+			"core 7 online                  : %d\n"
+#endif /* (MAX_CORES == 8) */
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+			"current cpu temp               : %d C\n"
+			"scaling block temp             : %d C\n"
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+			"current cpu temp               : %d C\n"
+			"thermal trip temp              : %d C\n"
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+			"running gov instances          : %d\n"
+#ifdef ENABLE_PROFILES_SUPPORT
+			"loaded profile                 : %s\n"
+			"loaded profile number          : %d\n"
+#endif /* ENABLE_PROFILES_SUPPORT */
+			"max freq                       : %d\n"
+			"min freq                       : %d\n"
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+			"auto adjust step               : %d\n"
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+			"current load                   : %d\n"
+			"current frequency              : %d\n"
+			"current sampling rate          : %u\n"
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+			"freq limit awake               : %u\n"
+			"freq limit asleep              : %u\n"
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+			"freq table in desc order       : %d\n"
+			"freq table size                : %u\n"
+			"limit table start              : %u\n"
+			"max scaling freq hard          : %u\n"
+			"max scaling freq soft          : %u\n"
+			"freq init count                : %u\n"
+			"scaling boost                  : %d\n"
+			"scaling cancel up              : %d\n"
+			"scaling mode up                : %d\n"
+			"scaling force down             : %d\n"
+			"scaling mode down              : %d\n"
+			"scaling up threshold           : %d\n"
+#ifdef ENABLE_INPUTBOOSTER
+			"inputboost cycles              : %d\n"
+			"inputboost up threshold        : %d\n"
+			"inputboost punch cycles        : %u\n"
+			"inputboost punch freq          : %d\n"
+			"inputboost punch on finger down: %d\n"
+			"inputboost punch on finger move: %d\n"
+			"inputboost punch on epenmove   : %d\n"
+			"inputboost typing up threshold : %d\n"
+			"inputboost typing cores        : %d\n"
+#endif /* ENABLE_INPUTBOOSTER */
+			"current sampling down factor   : %d\n"
+			"current max momentum           : %d\n"
+#ifdef ENABLE_MUSIC_LIMITS
+			"music max freq                 : %d\n"
+			"music min freq                 : %d\n"
+			"music state                    : %d\n"
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ENABLE_HOTPLUGGING
+			"scaling down threshold         : %d\n"
+			"hotplug block up cycles        : %d\n"
+			"hotplug block down cycles      : %d\n"
+			"hotplug up threshold1          : %d\n"
+			"hotplug up threshold2          : %d\n"
+			"hotplug up threshold3          : %d\n"
+			"hotplug up threshold1 freq     : %d\n"
+			"hotplug up threshold2 freq     : %d\n"
+			"hotplug up threshold3 freq     : %d\n"
+			"hotplug down threshold1        : %d\n"
+			"hotplug down threshold2        : %d\n"
+			"hotplug down threshold3        : %d\n"
+			"hotplug down threshold1 freq   : %d\n"
+			"hotplug down threshold2 freq   : %d\n"
+			"hotplug down threshold3 freq   : %d\n",
+#else
+			"scaling down threshold         : %d\n",
+#endif /* ENABLE_HOTPLUGGING */
+			possible_cpus,
+#if (MAX_CORES == 2 || MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+			cpu_online(0),
+			cpu_online(1),
+#endif
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+			cpu_online(2),
+			cpu_online(3),
+#endif
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+			cpu_online(4),
+			cpu_online(5),
+#endif
+#if (MAX_CORES == 8)
+			cpu_online(6),
+			cpu_online(7),
+#endif
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+			cpu_temp,
+			dbs_tuners_ins.scaling_block_temp,
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+			tmu_temp_cpu,
+			dbs_tuners_ins.scaling_trip_temp,
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+			dbs_enable,
+#ifdef ENABLE_PROFILES_SUPPORT
+			dbs_tuners_ins.profile,
+			dbs_tuners_ins.profile_number,
+#endif /* PROFILES_SUPPORT */
+			pol_max,
+			pol_min,
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+			pol_step,
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+			cur_load,
+			cur_freq,
+			dbs_tuners_ins.sampling_rate_current,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+			freq_limit_awake,
+			freq_limit_asleep,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+			freq_table_desc,
+			freq_table_size,
+			limit_table_start,
+			max_scaling_freq_hard,
+			max_scaling_freq_soft,
+			freq_init_count,
+			boost_freq,
+			cancel_up_scaling,
+			scaling_mode_up,
+			force_down_scaling,
+			scaling_mode_down,
+			scaling_up_threshold,
+#ifdef ENABLE_INPUTBOOSTER
+			dbs_tuners_ins.inputboost_cycles,
+			dbs_tuners_ins.inputboost_up_threshold,
+			dbs_tuners_ins.inputboost_punch_cycles,
+			dbs_tuners_ins.inputboost_punch_freq,
+			dbs_tuners_ins.inputboost_punch_on_fingerdown,
+			dbs_tuners_ins.inputboost_punch_on_fingermove,
+			dbs_tuners_ins.inputboost_punch_on_epenmove,
+			dbs_tuners_ins.inputboost_typingbooster_up_threshold,
+			dbs_tuners_ins.inputboost_typingbooster_cores,
+#endif /* ENABLE_INPUTBOOSTER */
+			zz_sampling_down_factor,
+			zz_sampling_down_max_mom,
+#ifdef ENABLE_MUSIC_LIMITS
+			dbs_tuners_ins.music_max_freq,
+			dbs_tuners_ins.music_min_freq,
+			dbs_tuners_ins.music_state,
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ENABLE_HOTPLUGGING
+			scaling_down_threshold,
+			zz_hotplug_block_up_cycles,
+			zz_hotplug_block_down_cycles,
+			hotplug_thresholds[0][0],
+			hotplug_thresholds[0][1],
+			hotplug_thresholds[0][2],
+			hotplug_thresholds_freq[0][0],
+			hotplug_thresholds_freq[0][1],
+			hotplug_thresholds_freq[0][2],
+			hotplug_thresholds[1][0],
+			hotplug_thresholds[1][1],
+			hotplug_thresholds[1][2],
+			hotplug_thresholds_freq[1][0],
+			hotplug_thresholds_freq[1][1],
+			hotplug_thresholds_freq[1][2]);
+#else
+			scaling_down_threshold);
+#endif /* ENABLE_HOTPLUGGING */
+}
+
+static DEVICE_ATTR(zzmoove_debug, S_IRUGO , show_zzmoove_debug, NULL);
+#endif /* ZZMOOVE_DEBUG */
+
+static struct attribute *dbs_attributes[] = {
+	&sampling_rate_min.attr,
+	&sampling_rate.attr,
+	&sampling_rate_current.attr,
+	&sampling_rate_idle_threshold.attr,
+	&sampling_rate_idle.attr,
+	&sampling_rate_idle_delay.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&sampling_rate_sleep_multiplier.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&sampling_down_factor.attr,
+	&sampling_down_max_momentum.attr,
+	&sampling_down_momentum_sensitivity.attr,
+	&up_threshold.attr,
+	&down_threshold.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&up_threshold_sleep.attr,
+	&down_threshold_sleep.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&ignore_nice_load.attr,
+	&smooth_up.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&smooth_up_sleep.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&freq_limit.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&freq_limit_sleep.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&fast_scaling_up.attr,
+	&fast_scaling_down.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&fast_scaling_sleep_up.attr,
+	&fast_scaling_sleep_down.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&afs_threshold1.attr,
+	&afs_threshold2.attr,
+	&afs_threshold3.attr,
+	&afs_threshold4.attr,
+	&grad_up_threshold.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&grad_up_threshold_sleep.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&early_demand.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&early_demand_sleep.attr,
+#ifdef ENABLE_HOTPLUGGING
+	&hotplug_sleep.attr,
+#endif /* ENABLE_HOTPLUGGING */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+	&disable_hotplug.attr,
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+	&disable_hotplug_sleep.attr,
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	&hotplug_block_up_cycles.attr,
+	&hotplug_block_down_cycles.attr,
+	&hotplug_stagger_up.attr,
+	&hotplug_stagger_down.attr,
+	&hotplug_idle_threshold.attr,
+	&hotplug_idle_freq.attr,
+	&hotplug_engage_freq.attr,
+	&hotplug_max_limit.attr,
+	&hotplug_min_limit.attr,
+	&hotplug_lock.attr,
+#endif /* ENABLE_HOTPLUGGING */
+	&scaling_block_threshold.attr,
+	&scaling_block_cycles.attr,
+	&scaling_up_block_cycles.attr,
+	&scaling_up_block_freq.attr,
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	&scaling_block_temp.attr,
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	&scaling_trip_temp.attr,
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	&scaling_block_freq.attr,
+	&scaling_block_force_down.attr,
+	&scaling_fastdown_freq.attr,
+	&scaling_fastdown_up_threshold.attr,
+	&scaling_fastdown_down_threshold.attr,
+	&scaling_responsiveness_freq.attr,
+	&scaling_responsiveness_up_threshold.attr,
+	&scaling_proportional.attr,
+#ifdef ENABLE_HOTPLUGGING
+	&up_threshold_hotplug1.attr,
+	&up_threshold_hotplug_freq1.attr,
+	&block_up_multiplier_hotplug1.attr,
+	&down_threshold_hotplug1.attr,
+	&down_threshold_hotplug_freq1.attr,
+	&block_down_multiplier_hotplug1.attr,
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	&up_threshold_hotplug2.attr,
+	&up_threshold_hotplug_freq2.attr,
+	&block_up_multiplier_hotplug2.attr,
+	&down_threshold_hotplug2.attr,
+	&down_threshold_hotplug_freq2.attr,
+	&block_down_multiplier_hotplug2.attr,
+	&up_threshold_hotplug3.attr,
+	&up_threshold_hotplug_freq3.attr,
+	&block_up_multiplier_hotplug3.attr,
+	&down_threshold_hotplug3.attr,
+	&down_threshold_hotplug_freq3.attr,
+	&block_down_multiplier_hotplug3.attr,
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	&up_threshold_hotplug4.attr,
+	&up_threshold_hotplug_freq4.attr,
+	&block_up_multiplier_hotplug4.attr,
+	&down_threshold_hotplug4.attr,
+	&down_threshold_hotplug_freq4.attr,
+	&block_down_multiplier_hotplug4.attr,
+	&up_threshold_hotplug5.attr,
+	&up_threshold_hotplug_freq5.attr,
+	&block_up_multiplier_hotplug5.attr,
+	&down_threshold_hotplug5.attr,
+	&down_threshold_hotplug_freq5.attr,
+	&block_down_multiplier_hotplug5.attr,
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	&up_threshold_hotplug6.attr,
+	&up_threshold_hotplug_freq6.attr,
+	&block_up_multiplier_hotplug6.attr,
+	&down_threshold_hotplug6.attr,
+	&down_threshold_hotplug_freq6.attr,
+	&block_down_multiplier_hotplug6.attr,
+	&up_threshold_hotplug7.attr,
+	&up_threshold_hotplug_freq7.attr,
+	&block_up_multiplier_hotplug7.attr,
+	&down_threshold_hotplug7.attr,
+	&down_threshold_hotplug_freq7.attr,
+	&block_down_multiplier_hotplug7.attr,
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#ifdef ENABLE_INPUTBOOSTER
+	&inputboost_cycles.attr,
+	&inputboost_up_threshold.attr,
+	&inputboost_punch_cycles.attr,
+	&inputboost_punch_freq.attr,
+	&inputboost_punch_on_fingerdown.attr,
+	&inputboost_punch_on_fingermove.attr,
+	&inputboost_punch_on_epenmove.attr,
+	&inputboost_typingbooster_up_threshold.attr,
+	&inputboost_typingbooster_cores.attr,
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+	&music_max_freq.attr,
+	&music_min_freq.attr,
+#ifdef ENABLE_HOTPLUGGING
+	&music_min_cores.attr,
+#endif /* ENABLE_HOTPLUGGING */
+	&music_state.attr,
+#endif /* ENABLE_MUSIC_LIMITS */
+	&dev_attr_version.attr,
+#ifdef ENABLE_PROFILES_SUPPORT
+	&dev_attr_version_profiles.attr,
+	&dev_attr_profile_list.attr,
+	&profile.attr,
+	&profile_number.attr,
+	&profile_sticky_mode.attr,
+#endif /* ENABLE_PROFILES_SUPPORT */
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+	&auto_adjust_freq_thresholds.attr,
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ZZMOOVE_DEBUG
+	&dev_attr_zzmoove_debug.attr,
+#endif /* ZZMOOVE_DEBUG */
+	NULL
+};
+
+static struct attribute_group dbs_attr_group = {
+	.attrs = dbs_attributes,
+	.name = "zzmoove",
+};
+
+/************************** sysfs end **************************/
+
+static void dbs_check_cpu(struct cpu_dbs_info_s *this_dbs_info)
+{
+	unsigned int j, load = 0, max_load = 0;
+	struct cpufreq_policy *policy;
+#if defined(ZZMOOVE_DEBUG) && defined(ENABLE_INPUTBOOSTER)
+	struct timeval time_now;
+#endif /* ZZMOOVE_DEBUG */
+	unsigned int down_threshold_override = 0;
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int num_online_cpus;
+
+	boost_hotplug = false;					// ZZ: reset early demand boost hotplug flag
+#endif /* ENABLE_HOTPLUGGING */
+	boost_freq = false;					// ZZ: reset early demand boost freq flag
+	force_down_scaling = false;				// ZZ: reset force down scaling flag
+	cancel_up_scaling = false;				// ZZ: reset cancel up scaling flag
+
+	policy = this_dbs_info->cur_policy;
+	on_cpu = policy->cpu;
+
+	if (on_cpu == 0)
+	    cur_freq = policy->cur;				// Yank: store current frequency for hotplugging frequency thresholds
+
+#ifdef ENABLE_INPUTBOOSTER
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	if (tmu_throttle_steps < 1) {
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		if (flg_ctr_cpuboost > 0) {
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/dbs_check_cpu] manual max-boost call! boosting to: %d mhz %d more times, cur: %d\n", policy->max, flg_ctr_cpuboost, policy->cur);
+#endif /* ZZMOOVE_DEBUG */
+			if (policy->cur < policy->max) {
+				__cpufreq_driver_target(policy, policy->max, CPUFREQ_RELATION_H);
+			}
+
+			flg_ctr_cpuboost--;
+			flg_ctr_inputboost_punch--;
+			scaling_up_block_cycles_count = 0;
+			return;
+		}
+
+		if (flg_ctr_inputboost_punch > 0) {
+
+			// decrement now, and boost to inputboost_punch_freq later on.
+			// ctr should have anticipated the lost final cycle by padding +1.
+
+			flg_ctr_inputboost_punch--;
+
+			if (!flg_ctr_inputboost_punch) {
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/dbs_check_cpu] inputboost - punch expired\n");
+#endif /* ZZMOOVE_DEBUG */
+			} else {
+
+				if (policy->cur < dbs_tuners_ins.inputboost_punch_freq) {
+#ifdef ZZMOOVE_DEBUG
+					// ZZ: save current time
+					do_gettimeofday(&time_now);
+
+					// ZZ: get time difference
+					time_since_touchbooster_lastrun = (time_now.tv_sec - time_touchbooster_lastrun.tv_sec) * MSEC_PER_SEC +
+										(time_now.tv_usec - time_touchbooster_lastrun.tv_usec) / USEC_PER_MSEC;
+
+					pr_info("[zzmoove/dbs_check_cpu] time since touch: %d ms\n", time_since_touchbooster_lastrun);
+					pr_info("[zzmoove/dbs_check_cpu] freq: %d too low, punching to %d immediately\n", policy->cur, dbs_tuners_ins.inputboost_punch_freq);
+#endif /* ZZMOOVE_DEBUG */
+					__cpufreq_driver_target(policy, dbs_tuners_ins.inputboost_punch_freq, CPUFREQ_RELATION_H);
+				}
+			}
+		}
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	} else {
+		// ff: reset all boosts
+		flg_ctr_cpuboost = 0;
+		flg_ctr_inputboost = 0;
+		flg_ctr_inputboost_punch = 0;
+		flg_ctr_inputbooster_typingbooster = 0;
+
+		// ff: check for cores that need to come down
+#ifdef ENABLE_HOTPLUGGING
+		if (on_cpu == 0 && !dbs_tuners_ins.disable_hotplug && num_online_cpus() != 1)
+		    queue_work_on(0, dbs_wq, &hotplug_offline_work);
+#endif /* ENABLE_HOTPLUGGING */
+	}
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+#endif /* ENABLE_INPUTBOOSTER */
+	/*
+	 * Every sampling_rate, we check, if current idle time is less than 20%
+	 * (default), then we try to increase frequency. Every sampling_rate *
+	 * sampling_down_factor, we check, if current idle time is more than 80%
+	 * (default), then we try to decrease frequency.
+	 */
+
+	/*
+	 * ZZ: Get absolute load and make calcualtions for early demand, auto fast
+	 * scaling and scaling block functionality
+	 */
+	for_each_cpu(j, policy->cpus) {
+		struct cpu_dbs_info_s *j_dbs_info;
+		u64 cur_wall_time, cur_idle_time;
+		unsigned int idle_time, wall_time;
+
+		j_dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+
+		cur_idle_time = get_cpu_idle_time(j,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) || defined(CPU_IDLE_TIME_IN_CPUFREQ)	/* overrule for sources with backported cpufreq implementation */
+		     &cur_wall_time, 0);
+#else
+		     &cur_wall_time);
+#endif /* LINUX_VERSION_CODE... */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		wall_time = (unsigned int)
+				(cur_wall_time - j_dbs_info->prev_cpu_wall);
+#else
+		wall_time = (unsigned int) cputime64_sub(cur_wall_time,
+				j_dbs_info->prev_cpu_wall);
+#endif /* LINUX_VERSION_CODE... */
+		j_dbs_info->prev_cpu_wall = cur_wall_time;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		idle_time = (unsigned int)
+
+		(cur_idle_time - j_dbs_info->prev_cpu_idle);
+		j_dbs_info->prev_cpu_idle = cur_idle_time;
+#else
+		idle_time = (unsigned int) cputime64_sub(cur_idle_time,
+				j_dbs_info->prev_cpu_idle);
+		j_dbs_info->prev_cpu_idle = cur_idle_time;
+#endif /* LINUX_VERSION_CODE... */
+		if (dbs_tuners_ins.ignore_nice) {
+		    u64 cur_nice;
+		    unsigned long cur_nice_jiffies;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		    cur_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE] -
+				 j_dbs_info->prev_cpu_nice;
+#else
+		    cur_nice = cputime64_sub(kstat_cpu(j).cpustat.nice,
+				 j_dbs_info->prev_cpu_nice);
+#endif /* LINUX_VERSION_CODE... */
+		    /*
+		     * Assumption: nice time between sampling periods will
+		     * be less than 2^32 jiffies for 32 bit sys
+		     */
+		    cur_nice_jiffies = (unsigned long)
+		    cputime64_to_jiffies64(cur_nice);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+		    j_dbs_info->prev_cpu_nice = kcpustat_cpu(j).cpustat[CPUTIME_NICE];
+#else
+		    j_dbs_info->prev_cpu_nice = kstat_cpu(j).cpustat.nice;
+#endif /* LINUX_VERSION_CODE... */
+		    idle_time += jiffies_to_usecs(cur_nice_jiffies);
+		}
+
+		if (unlikely(!wall_time || wall_time < idle_time))
+		    continue;
+
+		load = 100 * (wall_time - idle_time) / wall_time;
+#if defined(CONFIG_ARCH_EXYNOS4)
+		if (load > max_load)
+#endif /* CONFIG_ARCH_EXYNOS4 */
+		    cur_load = max_load = load;		// ZZ: added static cur_load for hotplugging functions
+
+		/*
+		 * ZZ: Early demand by Stratosk
+		 * Calculate the gradient of load. If it is too steep we assume
+		 * that the load will go over up_threshold in next iteration(s) and
+		 * we increase the frequency immediately
+		 *
+		 * At suspend:
+		 * Seperate early demand for suspend to be able to adjust scaling behaving at screen off and therefore to be
+		 * able to react problems which can occur because of too strictly suspend settings
+		 * So this will: boost freq and switch to fast scaling mode 2 at the same time if load is steep enough
+		 * (the value in grad_up_threshold_sleep) and in addition will lower the sleep multiplier to 2
+		 * (if it was set higher) when load goes above the value in grad_up_threshold_sleep
+		 */
+
+		if (dbs_tuners_ins.early_demand && !suspend_flag) {
+
+		    // ZZ: early demand at awake
+		    if (max_load > this_dbs_info->prev_load && max_load - this_dbs_info->prev_load
+			> dbs_tuners_ins.grad_up_threshold)
+			boost_freq = true;
+#ifdef ENABLE_HOTPLUGGING
+			boost_hotplug = true;
+#endif /* ENABLE_HOTPLUGGING */
+		// ZZ: early demand at suspend
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		} else if (dbs_tuners_ins.early_demand_sleep && suspend_flag) {
+
+			    // ZZ: check if we are over sleep threshold
+			    if (max_load > dbs_tuners_ins.grad_up_threshold_sleep
+				&& dbs_tuners_ins.sampling_rate_sleep_multiplier > 2)
+				dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate_idle * 2;	// ZZ: lower sleep multiplier
+			    else
+			        dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate_idle
+			        * dbs_tuners_ins.sampling_rate_sleep_multiplier;				// ZZ: restore sleep multiplier
+
+			    // ZZ: if load is steep enough enable freq boost and fast up scaling
+			    if (max_load > this_dbs_info->prev_load && max_load - this_dbs_info->prev_load
+			        > dbs_tuners_ins.grad_up_threshold_sleep) {
+			        boost_freq = true;								// ZZ: boost frequency
+			        scaling_mode_up = 2;								// ZZ: enable fast scaling up mode 2
+			    } else {
+			        scaling_mode_up = 0;								// ZZ: disable fast scaling again
+			    }
+		}
+#else
+		}
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+
+		/*
+		 * ZZ/Yank: Auto fast scaling mode
+		 * Switch to all 4 fast scaling modes depending on load gradient
+		 * the mode will start switching at given afs threshold load changes in both directions
+		 */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		if ((dbs_tuners_ins.fast_scaling_up       > 4 && !suspend_flag) ||
+		    (dbs_tuners_ins.fast_scaling_sleep_up > 4 &&  suspend_flag)    ) {
+#else
+		if (dbs_tuners_ins.fast_scaling_up       > 4 && !suspend_flag) {
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+		    if (max_load > this_dbs_info->prev_load && max_load - this_dbs_info->prev_load <= dbs_tuners_ins.afs_threshold1) {
+				scaling_mode_up = 0;
+		    } else if (max_load - this_dbs_info->prev_load <= dbs_tuners_ins.afs_threshold2) {
+				scaling_mode_up = 1;
+		    } else if (max_load - this_dbs_info->prev_load <= dbs_tuners_ins.afs_threshold3) {
+				scaling_mode_up = 2;
+		    } else if (max_load - this_dbs_info->prev_load <= dbs_tuners_ins.afs_threshold4) {
+				scaling_mode_up = 3;
+		    } else {
+				scaling_mode_up = 4;
+		    }
+		}
+
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		if ((dbs_tuners_ins.fast_scaling_down       > 4 && !suspend_flag) ||
+		    (dbs_tuners_ins.fast_scaling_sleep_down > 4 &&  suspend_flag)    ) {
+#else
+		if (dbs_tuners_ins.fast_scaling_down       > 4 && !suspend_flag) {
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND) */
+		  if (max_load < this_dbs_info->prev_load && this_dbs_info->prev_load - max_load <= dbs_tuners_ins.afs_threshold1) {
+				scaling_mode_down = 0;
+		    } else if (this_dbs_info->prev_load - max_load <= dbs_tuners_ins.afs_threshold2) {
+				scaling_mode_down = 1;
+		    } else if (this_dbs_info->prev_load - max_load <= dbs_tuners_ins.afs_threshold3) {
+				scaling_mode_down = 2;
+		    } else if (this_dbs_info->prev_load - max_load <= dbs_tuners_ins.afs_threshold4) {
+				scaling_mode_down = 3;
+		    } else {
+				scaling_mode_down = 4;
+		    }
+		}
+
+		/*
+		 * ZZ: Scaling block for reducing up scaling 'overhead'
+		 *
+		 * If the given freq threshold is reached do following:
+		 * Calculate the gradient of load in both directions count them every time they are under the load threshold
+		 * and block up scaling during that time. If max count of cycles (and therefore threshold hits) are reached
+		 * switch to 'force down mode' which lowers the freq the next given block cycles. By all that we can avoid
+		 * 'sticking' on max or relatively high frequency (caused by the very fast scaling behaving of zzmoove)
+		 * when load is constantly on mid to higher load during a 'longer' peroid.
+		 *
+		 * Or if exynos4 CPU temperature reading is enabled below do following:
+		 * Use current CPU temperature as a blocking threshold to lower the frequency and therefore keep the CPU cooler.
+		 * so in particular this will lower the frequency to the frequency set in 'scaling_block_freq' and hold it
+		 * there till the temperature goes under the temperature threshold again.
+		 *
+		 * u can choose here to use either fixed blocking cycles or the temperature threshold. using fixed blocking cycles disables
+		 * temperature depending blocking. in case of temperature depending blocks u must set a target freq in scaling_block_freq
+		 * tuneable. fixed block cycle feature can still be used optional without a frequency as 'starting threshold' like before
+		 */
+
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		if (dbs_tuners_ins.scaling_block_cycles == 0 && dbs_tuners_ins.scaling_block_freq != 0
+		    && cpu_temp >= dbs_tuners_ins.scaling_block_temp && !suspend_flag) {
+		    if (policy->cur == dbs_tuners_ins.scaling_block_freq) {
+			cancel_up_scaling = true;
+#ifdef ENABLE_HOTPLUGGING
+			hotplug_up_temp_block = true;
+#endif /* ENABLE_HOTPLUGGING */
+		    }
+		    if (policy->cur > dbs_tuners_ins.scaling_block_freq || policy->cur == policy->max) {
+			scaling_mode_down = 0;	// ZZ: if fast scaling down was enabled disable it to be sure that block freq will be met
+			force_down_scaling = true;
+		    }
+		}
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+		// ZZ: start blocking if we are not at suspend freq threshold is reached and max load is not at maximum
+		if (dbs_tuners_ins.scaling_block_cycles != 0 && policy->cur >= dbs_tuners_ins.scaling_block_freq
+		    && !suspend_flag && max_load != 100) {
+
+		    // ZZ: depending on load threshold count the gradients and block up scaling till max cycles are reached
+		    if ((scaling_block_cycles_count <= dbs_tuners_ins.scaling_block_cycles && max_load > this_dbs_info->prev_load
+			&& max_load - this_dbs_info->prev_load >= dbs_tuners_ins.scaling_block_threshold) ||
+			(scaling_block_cycles_count <= dbs_tuners_ins.scaling_block_cycles && max_load < this_dbs_info->prev_load
+			&& this_dbs_info->prev_load - max_load >= dbs_tuners_ins.scaling_block_threshold) ||
+			dbs_tuners_ins.scaling_block_threshold == 0) {
+			scaling_block_cycles_count++;							// ZZ: count gradients
+			cancel_up_scaling = true;							// ZZ: block scaling up at the same time
+		    }
+
+		    // ZZ: then switch to 'force down mode'
+		    if (scaling_block_cycles_count == dbs_tuners_ins.scaling_block_cycles) {		// ZZ: amount of cycles is reached
+			if (dbs_tuners_ins.scaling_block_force_down != 0)
+			    scaling_block_cycles_count = dbs_tuners_ins.scaling_block_cycles		// ZZ: switch to force down mode if enabled
+			    * dbs_tuners_ins.scaling_block_force_down;
+		        else
+			    scaling_block_cycles_count = 0;						// ZZ: down force disabled start from scratch
+		    }
+
+		    // ZZ: and force down scaling during next given bock cycles
+		    if (scaling_block_cycles_count > dbs_tuners_ins.scaling_block_cycles) {
+			if (unlikely(--scaling_block_cycles_count > dbs_tuners_ins.scaling_block_cycles))
+			    force_down_scaling = true;							// ZZ: force down scaling
+			else
+			    scaling_block_cycles_count = 0;						// ZZ: done -> reset counter
+		    }
+
+		}
+
+		// ZZ: used for gradient load calculation in fast scaling, scaling block and early demand
+		if (dbs_tuners_ins.early_demand || dbs_tuners_ins.scaling_block_cycles != 0
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+		  || dbs_tuners_ins.fast_scaling_up > 4 || dbs_tuners_ins.fast_scaling_down > 4 || (dbs_tuners_ins.early_demand_sleep && !suspend_flag))
+		    this_dbs_info->prev_load = max_load;
+#else
+		  || dbs_tuners_ins.fast_scaling_up > 4 || dbs_tuners_ins.fast_scaling_down > 4)
+		    this_dbs_info->prev_load = max_load;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+	}
+
+#ifdef ENABLE_HOTPLUGGING
+	// ZZ: if hotplug idle threshold is reached and cpu frequency is at its minimum disable hotplug
+	if (policy->cur < dbs_tuners_ins.hotplug_idle_freq && max_load < dbs_tuners_ins.hotplug_idle_threshold
+	    && dbs_tuners_ins.hotplug_idle_threshold != 0 && !suspend_flag)
+	    hotplug_idle_flag = true;
+	else
+	    hotplug_idle_flag = false;
+
+	num_online_cpus = num_online_cpus();
+
+	// ff: calculate hotplug block multipliers
+	if (num_online_cpus == 1) {
+		// ff: only main core is online, so apply block_up for core #2 (aka 1)
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 1 core\n");
+#endif /* ZZMOOVE_DEBUG */
+		zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug1;
+		zz_hotplug_block_down_cycles = 0; // ff: if 1 core is online, we can't go below that, so it's a moot setting
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 1 core - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+#if (MAX_CORES == 2 || MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	} else if (num_online_cpus == 2) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 2 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+#if (MAX_CORES == 2)
+		    zz_hotplug_block_up_cycles = 0; // ff: if all cores are online, we can't go above that, so it's a moot setting
+#else
+		    zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug2;
+		    zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug1;
+#endif /* #if (MAX_CORES == 2) */
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 2 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+#endif /* (MAX_CORES == 2 || MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	} else if (num_online_cpus == 3) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 3 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+		zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug3;
+		zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug2;
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 3 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+	} else if (num_online_cpus == 4) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 4 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+#if (MAX_CORES == 4)
+		    zz_hotplug_block_up_cycles = 0; // ff: if all cores are online, we can't go above that, so it's a moot setting
+#else
+		    zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug4;
+		    zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug3;
+#endif /* (MAX_CORES == 4) */
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 4 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	} else if (num_online_cpus == 5) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 5 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+		zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug5;
+		zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug4;
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 5 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+	} else if (num_online_cpus == 6) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 6 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+#if (MAX_CORES == 6)
+		    zz_hotplug_block_up_cycles = 0; // ff: if all cores are online, we can't go above that, so it's a moot setting
+#else
+		    zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug6;
+		    zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug5;
+#endif /* (MAX_CORES == 6) */
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 6 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	} else if (num_online_cpus == 7) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 7 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+		zz_hotplug_block_up_cycles = dbs_tuners_ins.hotplug_block_up_cycles * dbs_tuners_ins.block_up_multiplier_hotplug7;
+		zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug6;
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 7 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+	} else if (num_online_cpus == 8) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 8 cores\n");
+#endif /* ZZMOOVE_DEBUG */
+		zz_hotplug_block_up_cycles = 0; // ff: if all cores are online, we can't go above that, so it's a moot setting
+		zz_hotplug_block_down_cycles = dbs_tuners_ins.hotplug_block_down_cycles * dbs_tuners_ins.block_down_multiplier_hotplug7;
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] 8 cores - block up: %d, block down: %d\n", zz_hotplug_block_up_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+#endif /* (MAX_CORES == 8) */
+	}
+
+	// ff: make sure counters are synced
+	if (num_online_cpus != num_online_cpus_last) {
+		// ff: cores have been changed, counters invalid
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] reset block counters\n");
+#endif /* ZZMOOVE_DEBUG */
+		hplg_up_block_cycles = 0;
+		hplg_down_block_cycles = 0;
+	}
+
+	// ff: save how many cores were on so we'll know if they changed
+	num_online_cpus_last = num_online_cpus;
+
+	// ZZ: block cycles to be able to slow down hotplugging - added hotplug enagage freq (ffolkes)
+	// ff: also added a check to see if hotplug_max_limit is requesting only 1 core - if so, no sense in wasting time with hotplugging work
+	// ff: also added a check for hotplug_lock - if it's enabled, don't hotplug.
+	if (on_cpu == 0) {
+	    if (((!dbs_tuners_ins.disable_hotplug && num_online_cpus() != possible_cpus) || hotplug_idle_flag)
+		&& (!dbs_tuners_ins.hotplug_engage_freq || policy->cur >= dbs_tuners_ins.hotplug_engage_freq)
+		&& (!dbs_tuners_ins.hotplug_max_limit || dbs_tuners_ins.hotplug_max_limit > 1)
+		&& (!dbs_tuners_ins.hotplug_lock || num_online_cpus() > dbs_tuners_ins.hotplug_lock)) {
+		if (hplg_up_block_cycles > zz_hotplug_block_up_cycles
+		    || (!hotplug_up_in_progress && zz_hotplug_block_up_cycles == 0)) {
+			queue_work_on(0, dbs_wq, &hotplug_online_work);
+		    if (zz_hotplug_block_up_cycles != 0)
+			hplg_up_block_cycles = 0;
+		}
+		if (zz_hotplug_block_up_cycles != 0)
+		    hplg_up_block_cycles++;
+	    }
+	}
+#endif /* ENABLE_HOTPLUGGING */
+
+	// ZZ: Sampling rate idle
+	if (dbs_tuners_ins.sampling_rate_idle != dbs_tuners_ins.sampling_rate
+	    && max_load > dbs_tuners_ins.sampling_rate_idle_threshold
+	    && !suspend_flag && dbs_tuners_ins.sampling_rate_current != dbs_tuners_ins.sampling_rate) {
+	    if (sampling_rate_step_up_delay >= dbs_tuners_ins.sampling_rate_idle_delay) {
+	        dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate;
+	        if (dbs_tuners_ins.sampling_rate_idle_delay != 0)
+		    sampling_rate_step_up_delay = 0;
+	    }
+	    if (dbs_tuners_ins.sampling_rate_idle_delay != 0)
+	        sampling_rate_step_up_delay++;
+	}
+
+	// ZZ: Scaling fastdown and responsiveness thresholds (ffolkes)
+	if (!suspend_flag && dbs_tuners_ins.scaling_fastdown_freq && policy->cur > dbs_tuners_ins.scaling_fastdown_freq) {
+	    scaling_up_threshold = dbs_tuners_ins.scaling_fastdown_up_threshold;
+	} else if (!suspend_flag && dbs_tuners_ins.scaling_responsiveness_freq && policy->cur < dbs_tuners_ins.scaling_responsiveness_freq) {
+	    scaling_up_threshold = dbs_tuners_ins.scaling_responsiveness_up_threshold;
+	} else {
+	    scaling_up_threshold = dbs_tuners_ins.up_threshold;
+	}
+
+#ifdef ENABLE_INPUTBOOSTER
+	// ff: apply inputboost up threshold(s)
+	if (flg_ctr_inputboost > 0 && !suspend_flag) {
+		if (flg_ctr_inputbooster_typingbooster > 0) {
+			// ff: override normal inputboost_up_threshold
+			scaling_up_threshold = dbs_tuners_ins.inputboost_typingbooster_up_threshold;
+#ifdef ENABLE_HOTPLUGGING
+			if (num_online_cpus < dbs_tuners_ins.inputboost_typingbooster_cores) {
+				// ff: bring core(s) online
+				if (on_cpu == 0)
+				    queue_work_on(0, dbs_wq, &hotplug_online_work);
+			}
+#endif /* ENABLE_HOTPLUGGING */
+			flg_ctr_inputbooster_typingbooster--;
+		} else {
+			if (dbs_tuners_ins.inputboost_up_threshold) {
+				// ff: in the future there may be other boost options,
+				//     so be prepared for this one to be 0
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove] inputboost - boosting up threshold to: %d, from: %d, %d more times\n", dbs_tuners_ins.inputboost_up_threshold, scaling_up_threshold, flg_ctr_inputboost);
+#endif /* ZZMOOVE_DEBUG */
+				scaling_up_threshold = dbs_tuners_ins.inputboost_up_threshold;
+			}
+		}
+		if (scaling_up_threshold <= dbs_tuners_ins.down_threshold) {
+			// ff: we need to adjust the down_threshold. also, don't go too low
+			down_threshold_override = max(11, (int)(scaling_up_threshold - 5));
+		}
+		flg_ctr_inputboost--;
+#ifdef ZZMOOVE_DEBUG
+		if (flg_ctr_inputboost < 1) {
+			pr_info("[zzmoove/dbs_check_cpu] inputboost event expired\n");
+		}
+#endif /* ZZMOOVE_DEBUG */
+	}
+
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/dbs_check_cpu] up_threshold: %d\n", scaling_up_threshold);
+#endif /* ZZMOOVE_DEBUG */
+#endif /* ENABLE_INPUTBOOSTER */
+	// Check for frequency increase
+	if ((max_load >= scaling_up_threshold || boost_freq) // ZZ: boost switch for early demand and scaling block switches added
+	    && !cancel_up_scaling && !force_down_scaling) {
+
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		if (tmu_throttle_steps > 0) {
+			// ff: thermal throttling is in effect, disregard all other functions
+
+			this_dbs_info->requested_freq = zz_get_next_freq(policy->cur, 1, max_load);
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/dbs_check_cpu] thermal throttling - cur freq: %d, max: %d, new freq: %d\n", policy->cur, policy->max, this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+			__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+									CPUFREQ_RELATION_H);
+			return;
+		}
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+
+	    // ZZ: Sampling down momentum - if momentum is inactive switch to 'down_skip' method
+	    if (zz_sampling_down_max_mom == 0 && zz_sampling_down_factor > 1)
+		this_dbs_info->down_skip = 0;
+
+		// ZZ: Frequency Limit: if we are at freq_limit break out early
+		if (dbs_tuners_ins.freq_limit != 0
+			&& policy->cur == dbs_tuners_ins.freq_limit) {
+#ifdef ENABLE_MUSIC_LIMITS
+			// ff: but what if the music max freq wants to take over?
+			if (suspend_flag && dbs_tuners_ins.music_max_freq && dbs_tuners_ins.music_state && policy->cur < dbs_tuners_ins.music_max_freq) {
+				// ff: this is ugly, but this IF is so much easier like this.
+			} else {
+				return;
+			}
+#else
+				return;
+#endif /* ENABLE_MUSIC_LIMITS */
+		}
+
+	    // if we are already at full speed then break out early but not if freq limit is set
+	    if (policy->cur == policy->max && dbs_tuners_ins.freq_limit == 0)	// ZZ: changed check from reqested_freq to current freq (DerTeufel1980)
+		return;
+
+	    // ZZ: Sampling down momentum - if momentum is active and we are switching to max speed, apply sampling_down_factor
+	    if (zz_sampling_down_max_mom != 0 && policy->cur < policy->max)
+		this_dbs_info->rate_mult = zz_sampling_down_factor;
+
+		this_dbs_info->requested_freq = zz_get_next_freq(policy->cur, 1, max_load);
+
+		if (dbs_tuners_ins.freq_limit != 0
+			&& this_dbs_info->requested_freq > dbs_tuners_ins.freq_limit) {
+#ifdef ENABLE_MUSIC_LIMITS
+			// ff: right now we normally would let the freq_limit snub this, but we have to see if music needs to take over
+			if (suspend_flag && dbs_tuners_ins.music_max_freq && dbs_tuners_ins.music_state) {
+				// ff: screen is off, music freq is set, and music is playing.
+
+				// ff: make sure we haven't exceeded the music freq.
+				if (this_dbs_info->requested_freq > dbs_tuners_ins.music_max_freq) {
+					this_dbs_info->requested_freq = dbs_tuners_ins.music_max_freq;
+				}
+
+			} else {
+				this_dbs_info->requested_freq = dbs_tuners_ins.freq_limit;
+			}
+#else
+				this_dbs_info->requested_freq = dbs_tuners_ins.freq_limit;
+#endif /* ENABLE_MUSIC_LIMITS */
+		}
+
+#ifdef ENABLE_INPUTBOOSTER
+		if (flg_ctr_inputboost_punch > 0 && this_dbs_info->requested_freq < dbs_tuners_ins.inputboost_punch_freq) {
+			// ff: inputbooster punch is active and the the target freq needs to be at least that high
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/dbs_check_cpu] inputboost - UP too low - repunched freq to %d, from %d\n", dbs_tuners_ins.inputboost_punch_freq, this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+			this_dbs_info->requested_freq = dbs_tuners_ins.inputboost_punch_freq;
+		}
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_INPUTBOOSTER
+		// ff: check to see if we need to block up cycles, only do it if the screen is on, and typingbooster off
+		if (dbs_tuners_ins.scaling_up_block_cycles && !suspend_flag && flg_ctr_inputbooster_typingbooster < 1) {
+#else
+		// ff: check to see if we need to block up cycles, only do it if the screen is on, and typingbooster off
+		if (dbs_tuners_ins.scaling_up_block_cycles && !suspend_flag) {
+#endif /* ENABLE_INPUTBOOSTER */
+			// ff: if we're at or beyond the threshold frequency
+			if (policy->cur >= dbs_tuners_ins.scaling_up_block_freq) {
+
+				if (scaling_up_block_cycles_count < dbs_tuners_ins.scaling_up_block_cycles) {
+					scaling_up_block_cycles_count++;
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove/dbs_check_cpu] scaling up BLOCKED #%d - cur freq: %d, target freq: %d\n", scaling_up_block_cycles_count, policy->cur, this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+					return;
+				} else {
+					scaling_up_block_cycles_count = 0;
+				}
+
+			} else {
+
+				if (policy->cur < dbs_tuners_ins.scaling_up_block_freq) {
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove/dbs_check_cpu] scaling up RESET #%d - cur freq: %d, target freq: %d\n", scaling_up_block_cycles_count, policy->cur, this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+					scaling_up_block_cycles_count = 0;
+				}
+			}
+		}
+
+#ifdef ENABLE_MUSIC_LIMITS
+		if (dbs_tuners_ins.music_min_freq
+			&& this_dbs_info->requested_freq <= dbs_tuners_ins.music_min_freq
+			&& dbs_tuners_ins.music_state
+			) {
+			// ff: music is playing and there is a min set. ignore the screen-off max and set this then
+			this_dbs_info->requested_freq = dbs_tuners_ins.music_min_freq;
+		}
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] scaling up SET - cur freq: %d, max: %d, new freq: %d\n", policy->cur, policy->max,  this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+			    CPUFREQ_RELATION_H);
+
+	    // ZZ: Sampling down momentum - calculate momentum and update sampling down factor
+	    if (zz_sampling_down_max_mom != 0 && this_dbs_info->momentum_adder
+		< dbs_tuners_ins.sampling_down_mom_sens) {
+		this_dbs_info->momentum_adder++;
+		dbs_tuners_ins.sampling_down_momentum = (this_dbs_info->momentum_adder
+		* zz_sampling_down_max_mom) / dbs_tuners_ins.sampling_down_mom_sens;
+		zz_sampling_down_factor = orig_sampling_down_factor
+		+ dbs_tuners_ins.sampling_down_momentum;
+	    }
+	    return;
+	}
+
+#ifdef ENABLE_HOTPLUGGING
+	// ZZ: block cycles to be able to slow down hotplugging
+	if (on_cpu == 0) {
+	    if (!dbs_tuners_ins.disable_hotplug && num_online_cpus() != 1 && !hotplug_idle_flag) {
+		    if (unlikely(hplg_down_block_cycles >= zz_hotplug_block_down_cycles)
+			    || (!hotplug_down_in_progress && zz_hotplug_block_down_cycles == 0)) {
+#ifdef ZZMOOVE_DEBUG
+				    pr_info("[zzmoove] offline_work - %d / %d\n", hplg_down_block_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+					queue_work_on(0, dbs_wq, &hotplug_offline_work);
+
+					hplg_down_block_cycles = 0;
+		    }
+		    if (zz_hotplug_block_down_cycles != 0) {
+#ifdef ZZMOOVE_DEBUG
+			    pr_info("[zzmoove] skipped offline_work - %d / %d\n", hplg_down_block_cycles, zz_hotplug_block_down_cycles);
+#endif /* ZZMOOVE_DEBUG */
+			    hplg_down_block_cycles++;
+		    }
+	    }
+	}
+#endif /* ENABLE_HOTPLUGGING */
+
+	// ZZ: Sampling down momentum - if momentum is inactive switch to down skip method and if sampling_down_factor is active break out early
+	if (zz_sampling_down_max_mom == 0 && zz_sampling_down_factor > 1) {
+	    if (++this_dbs_info->down_skip < zz_sampling_down_factor)
+		return;
+	    this_dbs_info->down_skip = 0;
+	}
+
+	// ZZ: Sampling down momentum - calculate momentum and update sampling down factor
+	if (zz_sampling_down_max_mom != 0 && this_dbs_info->momentum_adder > 1) {
+	    this_dbs_info->momentum_adder -= 2;
+	    dbs_tuners_ins.sampling_down_momentum = (this_dbs_info->momentum_adder
+	    * zz_sampling_down_max_mom) / dbs_tuners_ins.sampling_down_mom_sens;
+	    zz_sampling_down_factor = orig_sampling_down_factor
+	    + dbs_tuners_ins.sampling_down_momentum;
+	}
+
+	// ZZ: Sampling rate idle
+	if (dbs_tuners_ins.sampling_rate_idle != dbs_tuners_ins.sampling_rate
+	    && max_load < dbs_tuners_ins.sampling_rate_idle_threshold && !suspend_flag
+	    && dbs_tuners_ins.sampling_rate_current != dbs_tuners_ins.sampling_rate_idle) {
+	    if (sampling_rate_step_down_delay >= dbs_tuners_ins.sampling_rate_idle_delay) {
+		dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate_idle;
+		if (dbs_tuners_ins.sampling_rate_idle_delay != 0)
+		    sampling_rate_step_down_delay = 0;
+	    }
+	    if (dbs_tuners_ins.sampling_rate_idle_delay != 0)
+		sampling_rate_step_down_delay++;
+	}
+
+	// ZZ: Scaling fastdown threshold (ffolkes)
+	if (!suspend_flag && dbs_tuners_ins.scaling_fastdown_freq != 0 && policy->cur > dbs_tuners_ins.scaling_fastdown_freq)
+	    scaling_down_threshold = dbs_tuners_ins.scaling_fastdown_down_threshold;
+	else
+	    scaling_down_threshold = dbs_tuners_ins.down_threshold;
+
+
+	// ff: if the up_threshold was boosted, we need to adjust this, too
+	if (down_threshold_override && down_threshold_override < scaling_down_threshold) {
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/dbs_check_cpu] DOWN - down_threshold override (from: %d, to: %d)\n", scaling_down_threshold, down_threshold_override);
+#endif /* ZZMOOVE_DEBUG */
+		scaling_down_threshold = down_threshold_override;
+	}
+
+	// Check for frequency decrease
+	if (max_load < scaling_down_threshold || force_down_scaling) {				// ZZ: added force down switch
+
+		// ZZ: Sampling down momentum - no longer fully busy, reset rate_mult
+		this_dbs_info->rate_mult = 1;
+
+		// if we cannot reduce the frequency anymore, break out early
+#ifdef ENABLE_MUSIC_LIMITS
+		if (policy->cur == policy->min || (dbs_tuners_ins.music_min_freq && dbs_tuners_ins.music_state && policy->cur == dbs_tuners_ins.music_min_freq))
+			return;
+#else
+		if (policy->cur == policy->min)
+			return;
+#endif /* ENABLE_MUSIC_LIMITS */
+		this_dbs_info->requested_freq = zz_get_next_freq(policy->cur, 2, max_load);
+
+#ifdef ENABLE_INPUTBOOSTER
+		if (flg_ctr_inputboost_punch > 0 && this_dbs_info->requested_freq < dbs_tuners_ins.inputboost_punch_freq) {
+			// ff: inputbooster punch is active and the the target freq needs to be at least that high
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/dbs_check_cpu] inputboost - DOWN too low - repunched freq to %d, from %d\n", dbs_tuners_ins.inputboost_punch_freq, this_dbs_info->requested_freq);
+#endif /* ZZMOOVE_DEBUG */
+			this_dbs_info->requested_freq = dbs_tuners_ins.inputboost_punch_freq;
+		}
+#endif /* ENABLE_INPUTBOOSTER */
+		if (dbs_tuners_ins.freq_limit != 0 && this_dbs_info->requested_freq
+		    > dbs_tuners_ins.freq_limit)
+		    this_dbs_info->requested_freq = dbs_tuners_ins.freq_limit;
+
+#ifdef ENABLE_MUSIC_LIMITS
+		if (dbs_tuners_ins.music_min_freq
+			&& this_dbs_info->requested_freq <= dbs_tuners_ins.music_min_freq
+			&& dbs_tuners_ins.music_state
+			) {
+
+			this_dbs_info->requested_freq = dbs_tuners_ins.music_min_freq;
+		}
+#endif /* ENABLE_MUSIC_LIMITS */
+		__cpufreq_driver_target(policy, this_dbs_info->requested_freq,
+			CPUFREQ_RELATION_L);							// ZZ: changed to relation low
+		return;
+	}
+}
+
+// ZZ/ff: inputbooster work
+#ifdef ENABLE_WORK_RESTARTLOOP
+static void zz_restartloop_work(struct work_struct *work)
+{
+	struct cpu_dbs_info_s *dbs_info =
+		container_of(work, struct cpu_dbs_info_s, work.work);
+	unsigned int cpu = dbs_info->cpu;
+	work_restartloop_in_progress = true;
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/zz_restartloop_work] restarting cycle\n");
+#endif /* ZZMOOVE_DEBUG */
+	cancel_delayed_work_sync(&dbs_info->work);
+	flush_workqueue(dbs_wq);
+	queue_delayed_work_on(cpu, dbs_wq, &dbs_info->work, 0);
+	work_restartloop_in_progress = false;
+}
+#endif /* ENABLE_WORK_RESTARTLOOP */
+
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+static void tt_reset(void)
+{
+	flg_ctr_tmu_overheating = 0;
+	tmu_throttle_steps = 0;
+	ctr_tmu_neutral = 0;
+	ctr_tmu_falling = 0;
+}
+
+// ff: Snapdragon thermal tripping
+static void tmu_check_work(struct work_struct * work_tmu_check)
+{
+	struct tsens_device tsens_dev;
+	long temp = 0;
+	int tmu_temp_delta = 0;
+	int tmu_temp_eventdelta = 0;
+
+	// ff: get temp
+	tsens_dev.sensor_num = 1;
+	tsens_get_temp(&tsens_dev, &temp);
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/thermal] sensor: %d, value: %ld\n", tsens_dev.sensor_num, temp);
+#endif /* ZZMOOVE_DEBUG */
+	tmu_temp_cpu = temp;
+
+	// ff: check this first, since 99% of the time we'll stop here
+	if (tmu_temp_cpu < dbs_tuners_ins.scaling_trip_temp) {
+		flg_ctr_tmu_overheating = 0;
+		tt_reset();
+		tmu_temp_cpu_last = temp;
+		return;
+	}
+
+	if (tmu_temp_cpu >= 75) {
+		// ff: emergency mode, drop to min freq
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/thermal] ALERT! high temp: %ld, step throttle: %d (%d mhz)\n", temp, tmu_throttle_steps, system_freq_table[max_scaling_freq_soft].frequency);
+#endif /* ZZMOOVE_DEBUG */
+		tmu_throttle_steps = max_scaling_freq_soft;
+		return;
+
+	} else if (tmu_temp_cpu >= 70) {
+		// ff: emergency mode, drop to min freq + 4
+#ifdef ZZMOOVE_DEBUG
+		pr_info("[zzmoove/thermal] ALERT! high temp: %ld, step throttle: %d (%d mhz)\n", temp, tmu_throttle_steps, system_freq_table[max_scaling_freq_soft - 4].frequency);
+#endif /* ZZMOOVE_DEBUG */
+		tmu_throttle_steps = (max_scaling_freq_soft - 4);
+		return;
+	}
+
+	if (flg_ctr_tmu_overheating < 1) {
+		// ff: first run, not overheating
+
+		if (temp >= dbs_tuners_ins.scaling_trip_temp) {
+			flg_ctr_tmu_overheating = 1;
+			tmu_throttle_steps = 1;
+			ctr_tmu_falling = 0;
+			ctr_tmu_neutral = 0;
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/thermal] TRIPPED - was: %d, now: %d - step throttle: %d (%d mhz)\n",
+			tmu_temp_cpu_last, tmu_temp_cpu, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+#endif /* ZZMOOVE_DEBUG */
+		}
+
+	} else {
+		// ff: another run of overheating
+		tmu_temp_delta = (tmu_temp_cpu - tmu_temp_cpu_last);
+		tmu_temp_eventdelta = (tmu_temp_cpu - dbs_tuners_ins.scaling_trip_temp);
+
+		// ff: determine direction
+		if (tmu_temp_delta > 0) {
+
+			// ff: ascending
+			flg_ctr_tmu_overheating++;
+
+			tmu_throttle_steps = flg_ctr_tmu_overheating;
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/thermal] RISING - was: %d, now: %d (delta: %d, eventdelta: %d) - step throttle: %d (%d mhz)\n",
+			tmu_temp_cpu_last, tmu_temp_cpu, tmu_temp_delta, tmu_temp_eventdelta, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+#endif /* ZZMOOVE_DEBUG */
+			ctr_tmu_falling = 0;
+			ctr_tmu_neutral = 0;
+
+		} else if (tmu_temp_delta < 0) {
+
+			// ff: descending
+			ctr_tmu_falling++;
+			ctr_tmu_neutral = 0;
+
+			if (ctr_tmu_falling > 1 && tmu_temp_cpu <= (dbs_tuners_ins.scaling_trip_temp + 2)) {
+
+				ctr_tmu_falling = 0;
+
+				// ff: don't go too low
+				if (flg_ctr_tmu_overheating > max_scaling_freq_soft) {
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove/thermal] fell too low - was: %d, now; %d\n", flg_ctr_tmu_overheating, max_scaling_freq_soft);
+#endif /* ZZMOOVE_DEBUG */
+					flg_ctr_tmu_overheating = max_scaling_freq_soft;
+				}
+
+				flg_ctr_tmu_overheating--;
+
+				if (flg_ctr_tmu_overheating < 0) {
+					flg_ctr_tmu_overheating = 1;
+				}
+
+				tmu_throttle_steps = flg_ctr_tmu_overheating;
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/thermal] FALLING - was: %d, now: %d (delta: %d, eventdelta: %d) - step throttle: %d (%d mhz)\n",
+						tmu_temp_cpu_last, tmu_temp_cpu, tmu_temp_delta, tmu_temp_eventdelta, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+
+			} else {
+
+				pr_info("[zzmoove/thermal] FALLING - IGNORING - was: %d, now: %d (delta: %d, eventdelta: %d) - step throttle: %d (%d mhz)\n",
+						tmu_temp_cpu_last, tmu_temp_cpu, tmu_temp_delta, tmu_temp_eventdelta, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+#endif /* ZZMOOVE_DEBUG */
+			}
+
+		} else {
+			// ff: neutral
+			ctr_tmu_neutral++;
+
+			//ctr_tmu_falling = 0;
+
+			if (ctr_tmu_neutral > 2 && tmu_temp_cpu >= (dbs_tuners_ins.scaling_trip_temp + 5)) {
+				// ff: if it has remained neutral for too long, throttle more
+
+				ctr_tmu_neutral = 0;
+
+				flg_ctr_tmu_overheating++;
+
+				tmu_throttle_steps = flg_ctr_tmu_overheating;
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/thermal] STEADY - now: %d - step throttle: %d (%d mhz)\n", tmu_temp_cpu, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+
+			} else {
+				pr_info("[zzmoove/thermal] STEADY - IGNORING - was: %d, now: %d (delta: %d, eventdelta: %d) - step throttle: %d (%d mhz)\n",
+						tmu_temp_cpu_last, tmu_temp_cpu, tmu_temp_delta, tmu_temp_eventdelta, tmu_throttle_steps, system_freq_table[tmu_throttle_steps].frequency);
+#endif /* ZZMOOVE_DEBUG */
+			}
+		}
+	}
+
+	// ff: save the temp for the next loop.
+	tmu_temp_cpu_last = temp;
+}
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+
+// ZZ: function for hotplug down work
+#ifdef ENABLE_HOTPLUGGING
+static void __cpuinit hotplug_offline_work_fn(struct work_struct *work)
+{
+	int cpu;	// ZZ: for hotplug down loop
+
+	hotplug_down_in_progress = true;
+
+	if (dbs_tuners_ins.hotplug_lock > 0)
+	    disable_cores = 1;
+
+	if (disable_cores > 0) {
+	    enable_disable_cores();
+	    hotplug_down_in_progress = false;
+	    return;
+	}
+
+	// Yank: added frequency thresholds
+	for_each_online_cpu(cpu) {
+		if (likely(cpu_online(cpu) && (cpu)) && cpu != 0
+			&& cur_load <= hotplug_thresholds[1][cpu-1]
+			&& (!dbs_tuners_ins.hotplug_min_limit || cpu >= dbs_tuners_ins.hotplug_min_limit)
+#ifdef ENABLE_MUSIC_LIMITS
+			&& (!dbs_tuners_ins.music_state || (dbs_tuners_ins.music_state
+			&& (!dbs_tuners_ins.music_min_cores || cpu >= dbs_tuners_ins.music_min_cores)))
+#endif /* ENABLE_MUSIC_LIMITS */
+#ifdef ENABLE_INPUTBOOSTER
+			&& (!dbs_tuners_ins.hotplug_min_limit_touchbooster || cpu >= dbs_tuners_ins.hotplug_min_limit_touchbooster)
+#endif /* ENABLE_INPUTBOOSTER */
+			&& (hotplug_thresholds_freq[1][cpu-1] == 0
+				|| cur_freq <= hotplug_thresholds_freq[1][cpu-1]
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+				|| hotplug_freq_threshold_out_of_range[1][cpu-1])
+#else
+			)
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+			) {
+#ifdef ZZMOOVE_DEBUG
+#if defined(ENABLE_MUSIC_LIMITS) && defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_offline_work] turning off cpu: %d, load: %d / %d, min_limit: %d music_min: %d (saved: %d), min_touchbooster: %d, freq: %d / %d, mftl: %d\n",
+				cpu, cur_load, hotplug_thresholds[1][cpu-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.music_min_cores, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[1][cpu-1], hotplug_freq_threshold_out_of_range[1][cpu-1]);
+#elif defined(ENABLE_MUSIC_LIMITS) && !defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_offline_work] turning off cpu: %d, load: %d / %d, min_limit: %d music_min: %d (saved: %d), min_touchbooster: %d, freq: %d, mftl: %d\n",
+				cpu, cur_load, hotplug_thresholds[1][cpu-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.music_min_cores, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[1][cpu-1]);
+#elif !defined(ENABLE_MUSIC_LIMITS) && defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_offline_work] turning off cpu: %d, load: %d / %d, min_limit: %d (saved: %d), min_touchbooster: %d, freq: %d / %d, mftl: %d\n",
+				cpu, cur_load, hotplug_thresholds[1][cpu-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[1][cpu-1], hotplug_freq_threshold_out_of_range[1][cpu-1]);
+#elif !defined(ENABLE_MUSIC_LIMITS) && !defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_offline_work] turning off cpu: %d, load: %d / %d, min_limit: %d (saved: %d), min_touchbooster: %d, freq: %d, mftl: %d\n",
+				cpu, cur_load, hotplug_thresholds[1][cpu-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[1][cpu-1]);
+#endif /* defined(ENABLE_MUSIC_LIMITS)... */
+#endif /* ZZMOOVE_DEBUG */
+
+#ifdef ENABLE_INPUTBOOSTER
+			// ff: don't take this cpu offline if it is less than what the typingbooster set
+			if (flg_ctr_inputbooster_typingbooster > 0 && cpu < dbs_tuners_ins.inputboost_typingbooster_cores) {
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_offline_work] typing booster requested cpu%d on, trying next cpu...\n", cpu);
+#endif /* ZZMOOVE_DEBUG */
+				continue;
+			}
+#endif /* ENABLE_INPUTBOOSTER */
+			if (dbs_tuners_ins.hotplug_stagger_down) {
+
+				// ff: stagger and remove core incrementally
+				if (cpu < (possible_cpus - 1) && cpu_online(cpu + 1)) {
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove/hotplug_offline_work] higher cpu (%d) is still online, trying next cpu...\n", cpu + 1);
+#endif /* ZZMOOVE_DEBUG */
+					continue;
+				}
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_offline_work] CPU %d OFF\n", cpu);
+#endif /* ZZMOOVE_DEBUG */
+				cpu_down(cpu);
+
+				// ff: break after a core removed
+				hotplug_down_in_progress = false;
+				return;
+
+			} else {
+				// ff: remove core normally
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_offline_work] CPU %d OFF\n", cpu);
+#endif /* ZZMOOVE_DEBUG */
+				cpu_down(cpu);
+			}
+		}
+	}
+	hotplug_down_in_progress = false;
+}
+
+// ZZ: function for hotplug up work
+static void __cpuinit hotplug_online_work_fn(struct work_struct *work)
+{
+	int i = 0;	// ZZ: for hotplug up loop
+
+	hotplug_up_in_progress = true;
+
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	if (hotplug_up_temp_block) {
+	    hotplug_up_temp_block = false;
+	    hotplug_up_in_progress = false;
+	    return;
+	}
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+	if (dbs_tuners_ins.hotplug_lock > 0)
+	    disable_cores = 3;
+
+	/*
+	 * ZZ: hotplug idle flag to enable offline cores on idle to avoid higher/achieve balanced cpu load at idle
+	 * and enable cores flag to enable offline cores on governor stop and at late resume
+	 */
+	if (unlikely(hotplug_idle_flag || enable_cores > 0)){
+	    enable_disable_cores();
+	    hotplug_up_in_progress = false;
+	    return;
+	}
+#ifdef ENABLE_INPUTBOOSTER
+	if (flg_ctr_inputbooster_typingbooster > 0 && num_online_cpus() < dbs_tuners_ins.inputboost_typingbooster_cores) {
+		for (i = 1; i < num_possible_cpus(); i++) {
+			if (!cpu_online(i) && i < dbs_tuners_ins.inputboost_typingbooster_cores) {
+				cpu_up(i);
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_online_work_fn/typingbooster] cpu%d forced online\n", i);
+#endif /* ZZMOOVE_DEBUG */
+			}
+		}
+	}
+#endif /* ENABLE_INPUTBOOSTER */
+	// Yank: added frequency thresholds
+	for (i = 1; likely(i < possible_cpus); i++) {
+		if (!cpu_online(i) && hotplug_thresholds[0][i-1] != 0 && cur_load >= hotplug_thresholds[0][i-1]
+			&& (!dbs_tuners_ins.hotplug_max_limit || i < dbs_tuners_ins.hotplug_max_limit)
+			&& (hotplug_thresholds_freq[0][i-1] == 0 || cur_freq >= hotplug_thresholds_freq[0][i-1]
+			|| boost_hotplug
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+			|| hotplug_freq_threshold_out_of_range[0][i-1])
+#else
+			)
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+			) {
+#ifdef ZZMOOVE_DEBUG
+#if defined(ENABLE_MUSIC_LIMITS) && defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_online_work] turning on cpu: %d, load: %d / %d, min_limit: %d music_min: %d (saved: %d), min_touchbooster: %d, freq: %d / %d, mftl: %d\n",
+				i, cur_load, hotplug_thresholds[0][i-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.music_min_cores, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[0][i-1], hotplug_freq_threshold_out_of_range[0][i-1]);
+#elif defined(ENABLE_MUSIC_LIMITS) && !defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_online_work] turning on cpu: %d, load: %d / %d, min_limit: %d music_min: %d (saved: %d), min_touchbooster: %d, freq: %d, mftl: %d\n",
+				i, cur_load, hotplug_thresholds[0][i-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.music_min_cores, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[0][i-1]);
+#elif !defined(ENABLE_MUSIC_LIMITS) && defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_online_work] turning on cpu: %d, load: %d / %d, min_limit: %d (saved: %d), min_touchbooster: %d, freq: %d / %d, mftl: %d\n",
+				i, cur_load, hotplug_thresholds[0][i-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[0][i-1], hotplug_freq_threshold_out_of_range[0][i-1]);
+#elif !defined(ENABLE_MUSIC_LIMITS) && !defined(ENABLE_AUTO_ADJUST_FREQ)
+			pr_info("[zzmoove/hotplug_online_work] turning on cpu: %d, load: %d / %d, min_limit: %d (saved: %d), min_touchbooster: %d, freq: %d, mftl: %d\n",
+				i, cur_load, hotplug_thresholds[0][i-1], dbs_tuners_ins.hotplug_min_limit, dbs_tuners_ins.hotplug_min_limit_saved,
+				dbs_tuners_ins.hotplug_min_limit_touchbooster, cur_freq, hotplug_thresholds_freq[0][i-1]);
+#endif /* defined(ENABLE_MUSIC_LIMITS)... */
+#endif /* ZZMOOVE_DEBUG */
+			// ff: stagger and add core incrementally
+			if (dbs_tuners_ins.hotplug_stagger_up) {
+
+				if (i > 1 && !cpu_online(i - 1)) {
+#ifdef ZZMOOVE_DEBUG
+					pr_info("[zzmoove/hotplug_online_work] previous cpu (%d) was not online, aborting work\n", i - 1);
+#endif /* ZZMOOVE_DEBUG */
+					hotplug_up_in_progress = false;
+					return;
+				}
+
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_online_work] CPU %d ON\n", i);
+#endif /* ZZMOOVE_DEBUG */
+				cpu_up(i);
+
+				// ff: break after a core added
+				hotplug_up_in_progress = false;
+				return;
+
+			} else {
+				// ff: add core normally
+#ifdef ZZMOOVE_DEBUG
+				pr_info("[zzmoove/hotplug_online_work] CPU %d ON\n", i);
+#endif /* ZZMOOVE_DEBUG */
+				cpu_up(i);
+			}
+		}
+	}
+	hotplug_up_in_progress = false;
+}
+#endif /* ENABLE_HOTPLUGGING */
+
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+// ZZ: function for exynos4 CPU temperature reading
+static void tmu_read_temperature(struct work_struct * tmu_read_work)
+{
+	cpu_temp = get_exynos4_temperature();
+	return;
+}
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+
+static void do_dbs_timer(struct work_struct *work)
+{
+	struct cpu_dbs_info_s *dbs_info =
+		container_of(work, struct cpu_dbs_info_s, work.work);
+	unsigned int cpu = dbs_info->cpu;
+
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	unsigned int tmu_check_delay = 0;
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	// We want all CPUs to do sampling nearly on same jiffy
+	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate_current * dbs_info->rate_mult); // ZZ: Sampling down momentum - added multiplier
+
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	// ZZ: start reading of temperature from exynos4 thermal management driver but disable it at suspend
+	if (dbs_tuners_ins.scaling_block_temp != 0) {						// ZZ: only if it is enabled and we are not at suspend
+	    if (!suspend_flag) {
+		schedule_delayed_work(&tmu_read_work, msecs_to_jiffies(DEF_TMU_READ_DELAY));	// ZZ: start work
+		temp_reading_started = true;							// ZZ: set work started flag
+		cancel_temp_reading = false;							// ZZ: reset cancel flag
+	    } else {
+		cancel_temp_reading = true;							// ZZ: else set cancel flag
+	    }
+
+	    if (temp_reading_started && cancel_temp_reading) {					// ZZ: if work was started and cancel flag was set
+		cancel_delayed_work(&tmu_read_work);						// ZZ: cancel work
+		cancel_temp_reading = false;							// ZZ: reset cancel flag
+		temp_reading_started = false;							// ZZ: reset started flag
+	    }
+	}
+
+	if (dbs_tuners_ins.scaling_block_temp == 0 && temp_reading_started)			// ZZ: if temp reading was disabled via sysfs and work was started
+	    cancel_delayed_work(&tmu_read_work);						// ZZ: cancel work
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	if (dbs_tuners_ins.scaling_trip_temp > 0) {
+		if (!suspend_flag)
+			tmu_check_delay = DEF_TMU_CHECK_DELAY;
+		else
+			tmu_check_delay = DEF_TMU_CHECK_DELAY_SLEEP;
+		schedule_delayed_work(&work_tmu_check, msecs_to_jiffies(tmu_check_delay));
+	} else {
+		tt_reset();
+	}
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	delay -= jiffies % delay;
+
+	mutex_lock(&dbs_info->timer_mutex);
+
+	dbs_check_cpu(dbs_info);
+
+	queue_delayed_work_on(cpu, dbs_wq, &dbs_info->work, delay);
+
+	mutex_unlock(&dbs_info->timer_mutex);
+}
+
+static inline void dbs_timer_init(struct cpu_dbs_info_s *dbs_info)
+{
+	// We want all CPUs to do sampling nearly on same jiffy
+	int delay = usecs_to_jiffies(dbs_tuners_ins.sampling_rate_current);
+	delay -= jiffies % delay;
+
+	dbs_info->enable = 1;
+
+	dbs_info_enabled = true;
+
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,7,0)
+	INIT_DEFERRABLE_WORK(&dbs_info->work, do_dbs_timer);
+#else
+	INIT_DELAYED_WORK_DEFERRABLE(&dbs_info->work, do_dbs_timer);
+#endif /* LINUX_VERSION_CODE... */
+	queue_delayed_work_on(dbs_info->cpu, dbs_wq, &dbs_info->work, delay);
+}
+
+static inline void dbs_timer_exit(struct cpu_dbs_info_s *dbs_info)
+{
+	dbs_info->enable = 0;
+
+	dbs_info_enabled = false;
+
+	cancel_delayed_work_sync(&dbs_info->work);
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	cancel_delayed_work(&tmu_read_work);					// ZZ: cancel cpu temperature reading
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+}
+
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+// raise sampling rate to SR*multiplier and adjust sampling rate/thresholds/hotplug/scaling/freq limit/freq step on blank screen
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(USE_LCD_NOTIFIER)
+static void __cpuinit powersave_early_suspend(struct early_suspend *handler)
+#elif defined(CONFIG_POWERSUSPEND) && !defined(USE_LCD_NOTIFIER) || defined(CONFIG_POWERSUSPEND) && defined(USE_LCD_NOTIFIER)
+static void __cpuinit powersave_suspend(struct power_suspend *handler)
+#elif defined(USE_LCD_NOTIFIER)
+void zzmoove_suspend(void)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+{
+	suspend_flag = true;				// ZZ: we want to know if we are at suspend because of things that shouldn't be executed at suspend
+	sampling_rate_awake = dbs_tuners_ins.sampling_rate_current;		// ZZ: save current sampling rate for restore on awake
+	up_threshold_awake = dbs_tuners_ins.up_threshold;			// ZZ: save up threshold for restore on awake
+	down_threshold_awake = dbs_tuners_ins.down_threshold;			// ZZ: save down threhold for restore on awake
+	zz_sampling_down_max_mom = 0;						// ZZ: sampling down momentum - disabled at suspend
+	smooth_up_awake = dbs_tuners_ins.smooth_up;				// ZZ: save smooth up value for restore on awake
+	fast_scaling_up_awake = dbs_tuners_ins.fast_scaling_up;			// Yank: save scaling setting for restore on awake for upscaling
+	fast_scaling_down_awake = dbs_tuners_ins.fast_scaling_down;		// Yank: save scaling setting for restore on awake for downscaling
+#ifdef ENABLE_HOTPLUGGING
+	disable_hotplug_awake = dbs_tuners_ins.disable_hotplug;			// ZZ: save hotplug switch state for restore on awake
+	hotplug1_awake = dbs_tuners_ins.up_threshold_hotplug1;			// ZZ: save hotplug1 value for restore on awake
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	hotplug2_awake = dbs_tuners_ins.up_threshold_hotplug2;			// ZZ: save hotplug2 value for restore on awake
+	hotplug3_awake = dbs_tuners_ins.up_threshold_hotplug3;			// ZZ: save hotplug3 value for restore on awake
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	hotplug4_awake = dbs_tuners_ins.up_threshold_hotplug4;			// ZZ: save hotplug4 value for restore on awake
+	hotplug5_awake = dbs_tuners_ins.up_threshold_hotplug5;			// ZZ: save hotplug5 value for restore on awake
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	hotplug6_awake = dbs_tuners_ins.up_threshold_hotplug6;			// ZZ: save hotplug6 value for restore on awake
+	hotplug7_awake = dbs_tuners_ins.up_threshold_hotplug7;			// ZZ: save hotplug7 value for restore on awake
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+	sampling_rate_asleep = dbs_tuners_ins.sampling_rate_sleep_multiplier;	// ZZ: save sleep multiplier for sleep
+	up_threshold_asleep = dbs_tuners_ins.up_threshold_sleep;		// ZZ: save up threshold for sleep
+	down_threshold_asleep = dbs_tuners_ins.down_threshold_sleep;		// ZZ: save down threshold for sleep
+	smooth_up_asleep = dbs_tuners_ins.smooth_up_sleep;			// ZZ: save smooth up for sleep
+	fast_scaling_up_asleep = dbs_tuners_ins.fast_scaling_sleep_up;		// Yank: save fast scaling for sleep for upscaling
+	fast_scaling_down_asleep = dbs_tuners_ins.fast_scaling_sleep_down;	// Yank: save fast scaling for sleep for downscaling
+#ifdef ENABLE_HOTPLUGGING
+	disable_hotplug_asleep = dbs_tuners_ins.disable_hotplug_sleep;		// ZZ: save disable hotplug switch for sleep
+#endif /* ENABLE_HOTPLUGGING */
+	dbs_tuners_ins.sampling_rate_current = dbs_tuners_ins.sampling_rate_idle
+	* sampling_rate_asleep;							// ZZ: set sampling rate for sleep
+	dbs_tuners_ins.up_threshold = up_threshold_asleep;			// ZZ: set up threshold for sleep
+	dbs_tuners_ins.down_threshold = down_threshold_asleep;			// ZZ: set down threshold for sleep
+	dbs_tuners_ins.smooth_up = smooth_up_asleep;				// ZZ: set smooth up for for sleep
+	dbs_tuners_ins.freq_limit = freq_limit_asleep;				// ZZ: set freqency limit for sleep
+	dbs_tuners_ins.fast_scaling_up = fast_scaling_up_asleep;		// Yank: set fast scaling for sleep for upscaling
+	dbs_tuners_ins.fast_scaling_down = fast_scaling_down_asleep;		// Yank: set fast scaling for sleep for downscaling
+#ifdef ENABLE_HOTPLUGGING
+	dbs_tuners_ins.disable_hotplug = disable_hotplug_asleep;		// ZZ: set hotplug switch for sleep
+#endif /* ENABLE_HOTPLUGGING */
+	evaluate_scaling_order_limit_range(0, 0, suspend_flag, 0, 0);		// ZZ: table order detection and limit optimizations
+#ifdef ENABLE_HOTPLUGGING
+	if (dbs_tuners_ins.disable_hotplug_sleep == 1) {			// ZZ: enable all cores at suspend if disable hotplug sleep is set
+		enable_cores = 1;
+		queue_work_on(0, dbs_wq, &hotplug_online_work);
+	}
+#endif /* ENABLE_HOTPLUGGING */
+	if (dbs_tuners_ins.fast_scaling_up > 4)					// Yank: set scaling mode
+	    scaling_mode_up   = 0;						// ZZ: auto fast scaling
+	else
+	    scaling_mode_up   = dbs_tuners_ins.fast_scaling_up;			// Yank: fast scaling up only
+
+	if (dbs_tuners_ins.fast_scaling_down > 4)				// Yank: set scaling mode
+	    scaling_mode_down = 0;						// ZZ: auto fast scaling
+	else
+	    scaling_mode_down = dbs_tuners_ins.fast_scaling_down;		// Yank: fast scaling up only
+#ifdef ENABLE_HOTPLUGGING
+	if (likely(dbs_tuners_ins.hotplug_sleep != 0)
+#ifdef ENABLE_MUSIC_LIMITS
+	    && !dbs_tuners_ins.music_state) {					// ZZ: if set to 0 or music state is enabled do not touch hotplugging values
+#else
+	    ) {
+#endif /* ENABLE_MUSIC_LIMITS */
+	    if (dbs_tuners_ins.hotplug_sleep == 1) {
+		dbs_tuners_ins.up_threshold_hotplug1 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][0] = 0;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug2 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][1] = 0;
+		dbs_tuners_ins.up_threshold_hotplug3 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][2] = 0;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug4 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][3] = 0;
+		dbs_tuners_ins.up_threshold_hotplug5 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][4] = 0;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to one core
+		hotplug_thresholds[0][6] = 0;
+#endif /* (MAX_CORES == 8) */
+	    }
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	    if (dbs_tuners_ins.hotplug_sleep == 2) {
+		dbs_tuners_ins.up_threshold_hotplug2 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][1] = 0;
+		dbs_tuners_ins.up_threshold_hotplug3 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][2] = 0;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug4 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][3] = 0;
+		dbs_tuners_ins.up_threshold_hotplug5 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][4] = 0;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to two cores
+		hotplug_thresholds[0][6] = 0;
+#endif /* (MAX_CORES == 8) */
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	    }
+	    if (dbs_tuners_ins.hotplug_sleep == 3) {
+		dbs_tuners_ins.up_threshold_hotplug3 = 0;			// ZZ: set to three cores
+	        hotplug_thresholds[0][2] = 0;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug4 = 0;			// ZZ: set to three cores
+		hotplug_thresholds[0][3] = 0;
+		dbs_tuners_ins.up_threshold_hotplug5 = 0;			// ZZ: set to three cores
+		hotplug_thresholds[0][4] = 0;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to three cores
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to three cores
+		hotplug_thresholds[0][6] = 0;
+#endif /* (MAX_CORES == 8) */
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	    }
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	    if (dbs_tuners_ins.hotplug_sleep == 4) {
+		dbs_tuners_ins.up_threshold_hotplug4 = 0;			// ZZ: set to four cores
+		hotplug_thresholds[0][3] = 0;
+		dbs_tuners_ins.up_threshold_hotplug5 = 0;			// ZZ: set to four cores
+		hotplug_thresholds[0][4] = 0;
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to four cores
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to four cores
+		hotplug_thresholds[0][6] = 0;
+	    }
+
+	    if (dbs_tuners_ins.hotplug_sleep == 5) {
+		dbs_tuners_ins.up_threshold_hotplug5 = 0;			// ZZ: set to five cores
+		hotplug_thresholds[0][4] = 0;
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to five cores
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to five cores
+		hotplug_thresholds[0][6] = 0;
+	    }
+
+	    if (dbs_tuners_ins.hotplug_sleep == 6) {
+		dbs_tuners_ins.up_threshold_hotplug6 = 0;			// ZZ: set to six cores
+		hotplug_thresholds[0][5] = 0;
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to six cores
+		hotplug_thresholds[0][6] = 0;
+	    }
+
+	    if (dbs_tuners_ins.hotplug_sleep == 7) {
+		dbs_tuners_ins.up_threshold_hotplug7 = 0;			// ZZ: set to seven cores
+		hotplug_thresholds[0][6] = 0;
+	    }
+#endif /* (MAX_CORES == 8) */
+	}
+#endif /* ENABLE_HOTPLUGGING */
+#ifdef ENABLE_INPUTBOOSTER
+	// ff: reset some stuff.
+	flg_ctr_cpuboost = 0;
+	flg_ctr_inputboost = 0;
+	flg_ctr_inputboost_punch = 0;
+	flg_ctr_inputbooster_typingbooster = 0;
+#endif /* ENABLE_INPUTBOOSTER */
+	scaling_up_block_cycles_count = 0;
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/lcd_notifier] Suspend function executed.\n");
+#endif /* ZZMOOVE_DEBUG */
+}
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(USE_LCD_NOTIFIER)
+static void __cpuinit powersave_late_resume(struct early_suspend *handler)
+#elif defined(CONFIG_POWERSUSPEND) && !defined(USE_LCD_NOTIFIER)
+static void __cpuinit powersave_resume(struct power_suspend *handler)
+#elif defined(USE_LCD_NOTIFIER)
+void zzmoove_resume(void)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+{
+	suspend_flag = false;							// ZZ: we are resuming so reset supend flag
+	scaling_mode_up = 4;							// ZZ: scale up as fast as possibe
+	boost_freq = true;							// ZZ: and boost freq in addition
+
+#ifdef ENABLE_HOTPLUGGING
+	if (dbs_tuners_ins.disable_hotplug_sleep == 0) {
+	    enable_cores = 1;
+	    queue_work_on(0, dbs_wq, &hotplug_online_work); // ZZ: enable offline cores to avoid stuttering after resume if hotplugging limit was active
+	}
+#endif /* ENABLE_HOTPLUGGING */
+
+#ifdef ENABLE_INPUTBOOSTER
+	if (flg_ctr_cpuboost < 5)
+		flg_ctr_cpuboost = 5;
+#endif /* ENABLE_INPUTBOOSTER */
+
+#ifdef ENABLE_WORK_RESTARTLOOP
+	// ff: immediately call the dbs loop to apply the boost
+	if (!work_restartloop_in_progress)
+		queue_work_on(0, dbs_aux_wq, &work_restartloop);
+#endif /* ENABLE_WORK_RESTARTLOOP */
+
+#ifdef ENABLE_HOTPLUGGING
+	if (likely(dbs_tuners_ins.hotplug_sleep != 0)
+#ifdef ENABLE_MUSIC_LIMITS
+	    && !dbs_tuners_ins.music_state) {
+#else
+	    ) {
+#endif /* ENABLE_MUSIC_LIMITS */
+	    dbs_tuners_ins.up_threshold_hotplug1 = hotplug1_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][0] = hotplug1_awake;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	    dbs_tuners_ins.up_threshold_hotplug2 = hotplug2_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][1] = hotplug2_awake;
+	    dbs_tuners_ins.up_threshold_hotplug3 = hotplug3_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][2] = hotplug3_awake;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	    dbs_tuners_ins.up_threshold_hotplug4 = hotplug4_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][3] = hotplug4_awake;
+	    dbs_tuners_ins.up_threshold_hotplug5 = hotplug5_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][4] = hotplug5_awake;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	    dbs_tuners_ins.up_threshold_hotplug6 = hotplug6_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][5] = hotplug6_awake;
+	    dbs_tuners_ins.up_threshold_hotplug7 = hotplug7_awake;		// ZZ: restore previous settings
+	    hotplug_thresholds[0][6] = hotplug7_awake;
+#endif /* (MAX_CORES == 8) */
+	}
+#endif /* ENABLE_HOTPLUGGING */
+	zz_sampling_down_max_mom = orig_sampling_down_max_mom;			// ZZ: Sampling down momentum - restore max value
+	dbs_tuners_ins.sampling_rate_current = sampling_rate_awake;		// ZZ: restore previous settings
+	dbs_tuners_ins.up_threshold = up_threshold_awake;			// ZZ: restore previous settings
+	dbs_tuners_ins.down_threshold = down_threshold_awake;			// ZZ: restore previous settings
+	dbs_tuners_ins.smooth_up = smooth_up_awake;				// ZZ: restore previous settings
+	dbs_tuners_ins.freq_limit = freq_limit_awake;				// ZZ: restore previous settings
+	dbs_tuners_ins.fast_scaling_up   = fast_scaling_up_awake;		// Yank: restore previous settings for upscaling
+	dbs_tuners_ins.fast_scaling_down = fast_scaling_down_awake;		// Yank: restore previous settings for downscaling
+#ifdef ENABLE_HOTPLUGGING
+	dbs_tuners_ins.disable_hotplug = disable_hotplug_awake;			// ZZ: restore previous settings
+#endif /* ENABLE_HOTPLUGGING */
+	evaluate_scaling_order_limit_range(0, 0, suspend_flag, 0, 0);		// ZZ: table order detection and limit optimizations
+
+	if (dbs_tuners_ins.fast_scaling_up > 4)					// Yank: set scaling mode
+	    scaling_mode_up   = 0;						// ZZ: auto fast scaling
+	else
+	    scaling_mode_up   = dbs_tuners_ins.fast_scaling_up;			// Yank: fast scaling up only
+
+	if (dbs_tuners_ins.fast_scaling_down > 4)				// Yank: set scaling mode
+	    scaling_mode_down = 0;						// ZZ: auto fast scaling
+	else
+	    scaling_mode_down = dbs_tuners_ins.fast_scaling_down;		// Yank: fast scaling up only
+
+#ifdef ZZMOOVE_DEBUG
+	pr_info("[zzmoove/lcd_notifier] Resume function executed.\n");
+#endif /* ZZMOOVE_DEBUG */
+}
+
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined(DISABLE_POWER_MANAGEMENT)
+static struct early_suspend __refdata _powersave_early_suspend = {
+  .suspend = powersave_early_suspend,
+  .resume = powersave_late_resume,
+  .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN,
+};
+#elif defined(CONFIG_POWERSUSPEND) && defined(USE_LCD_NOTIFIER) && !defined (DISABLE_POWER_MANAGEMENT) || defined(CONFIG_POWERSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined (DISABLE_POWER_MANAGEMENT)
+static struct power_suspend __refdata powersave_powersuspend = {
+  .suspend = powersave_suspend,
+  .resume = powersave_resume,
+};
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+
+static int cpufreq_governor_dbs(struct cpufreq_policy *policy,
+				   unsigned int event)
+{
+	unsigned int cpu = policy->cpu;
+	struct cpu_dbs_info_s *this_dbs_info;
+	unsigned int j;
+	int rc;
+#if defined(ENABLE_HOTPLUGGING) && !defined(SNAP_NATIVE_HOTPLUGGING)
+	int i = 0;
+#endif /* ENABLE_HOTPLUGGING */
+	this_dbs_info = &per_cpu(cs_cpu_dbs_info, cpu);
+
+	switch (event) {
+	case CPUFREQ_GOV_START:
+		if ((!cpu_online(cpu)) || (!policy->cur))
+		    return -EINVAL;
+		mutex_lock(&dbs_mutex);
+
+		for_each_cpu(j, policy->cpus) {
+			struct cpu_dbs_info_s *j_dbs_info;
+			j_dbs_info = &per_cpu(cs_cpu_dbs_info, j);
+			j_dbs_info->cur_policy = policy;
+
+			j_dbs_info->prev_cpu_idle = get_cpu_idle_time(j,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,10,0) || defined(CPU_IDLE_TIME_IN_CPUFREQ)	/* ZZ: overrule for sources with backported cpufreq implementation */
+			&j_dbs_info->prev_cpu_wall, 0);
+#else
+			&j_dbs_info->prev_cpu_wall);
+#endif /* LINUX_VERSION_CODE... */
+			if (dbs_tuners_ins.ignore_nice) {
+			    j_dbs_info->prev_cpu_nice =
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0)
+			    kcpustat_cpu(j).cpustat[CPUTIME_NICE];
+#else
+			    kstat_cpu(j).cpustat.nice;
+#endif /* LINUX_VERSION_CODE... */
+			}
+			j_dbs_info->time_in_idle = get_cpu_idle_time_us(cpu, &j_dbs_info->idle_exit_time); // ZZ: idle exit time handling
+		}
+		this_dbs_info->cpu = cpu;					// ZZ: initialise the cpu field during governor start
+		this_dbs_info->rate_mult = 1;					// ZZ: sampling down momentum - reset multiplier
+		this_dbs_info->momentum_adder = 0;				// ZZ: sampling down momentum - reset momentum adder
+		this_dbs_info->down_skip = 0;					// ZZ: sampling down - reset down_skip
+		this_dbs_info->requested_freq = policy->cur;
+
+		// ZZ: get freq table, available cpus for hotplugging and optimize/detect scaling range
+#ifdef ENABLE_HOTPLUGGING
+		possible_cpus = num_possible_cpus();
+#endif /* ENABLE_HOTPLUGGING */
+		if (cpu == 0) {
+		    freq_init_count = 0;					// ZZ: reset init flag for governor reload
+		    system_freq_table = cpufreq_frequency_get_table(0);		// ZZ: update static system frequency table
+		    evaluate_scaling_order_limit_range(1, 0, 0, policy->min, policy->max);	// ZZ: table order detection and limit optimizations
+		}
+#if defined(ENABLE_HOTPLUGGING) && !defined(SNAP_NATIVE_HOTPLUGGING)
+		// ZZ: save default values in threshold array
+		for (i = 0; i < possible_cpus; i++) {
+		    hotplug_thresholds[0][i] = DEF_FREQUENCY_UP_THRESHOLD_HOTPLUG;
+		    hotplug_thresholds[1][i] = DEF_FREQUENCY_DOWN_THRESHOLD_HOTPLUG;
+		}
+#endif /* ENABLE_HOTPLUGGING */
+		mutex_init(&this_dbs_info->timer_mutex);
+		dbs_enable++;
+		/*
+		 * Start the timerschedule work, when this governor
+		 * is used for first time
+		 */
+		if (dbs_enable == 1) {
+		    unsigned int latency;
+		    // policy latency is in nS. Convert it to uS first
+		    latency = policy->cpuinfo.transition_latency / 1000;
+		    if (latency == 0)
+			latency = 1;
+
+			rc = sysfs_create_group(cpufreq_global_kobject,
+						&dbs_attr_group);
+			if (rc) {
+			    mutex_unlock(&dbs_mutex);
+			    return rc;
+			}
+
+			/*
+			 * conservative does not implement micro like ondemand
+			 * governor, thus we are bound to jiffes/HZ
+			 */
+			min_sampling_rate =
+				MIN_SAMPLING_RATE_RATIO * jiffies_to_usecs(3);
+			// Bring kernel and HW constraints together
+			min_sampling_rate = max(min_sampling_rate,
+					MIN_LATENCY_MULTIPLIER * latency);
+			dbs_tuners_ins.sampling_rate_current =
+				max(min_sampling_rate,
+				    latency * LATENCY_MULTIPLIER);
+#ifdef ENABLE_PROFILES_SUPPORT
+#if (DEF_PROFILE_NUMBER > 0)
+			set_profile(DEF_PROFILE_NUMBER);
+#endif /* (DEF_PROFILE_NUMBER > 0) */
+#endif /* ENABLE_PROFILES_SUPPORT */
+			// ZZ: Sampling down momentum - set down factor and max momentum
+			orig_sampling_down_factor = zz_sampling_down_factor;
+			orig_sampling_down_max_mom = zz_sampling_down_max_mom;
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+			sampling_rate_awake = dbs_tuners_ins.sampling_rate
+			= dbs_tuners_ins.sampling_rate_current;
+#else
+			dbs_tuners_ins.sampling_rate
+			= dbs_tuners_ins.sampling_rate_current;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+#if (defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) && !defined(DISABLE_POWER_MANAGEMENT)) || defined(USE_LCD_NOTIFIER)
+			up_threshold_awake = dbs_tuners_ins.up_threshold;
+			down_threshold_awake = dbs_tuners_ins.down_threshold;
+			smooth_up_awake = dbs_tuners_ins.smooth_up;
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+			// ZZ: switch to proportional scaling if we didn't get system freq table
+			if (!system_freq_table) {
+			    printk(KERN_ERR "[zzmoove] Failed to get system freq table! falling back to proportional scaling!\n");
+			    dbs_tuners_ins.scaling_proportional = 2;
+			}
+
+			cpufreq_register_notifier(
+					&dbs_cpufreq_notifier_block,
+					CPUFREQ_TRANSITION_NOTIFIER);
+#ifdef ENABLE_INPUTBOOST
+			if (dbs_tuners_ins.inputboost_cycles) {
+				rc = input_register_handler(&interactive_input_handler);
+				if (!rc)
+					pr_info("[zzmoove/store_inputboost_cycles] inputbooster - registered\n");
+				else
+					pr_info("[zzmoove/store_inputboost_cycles] inputbooster - register FAILED\n");
+				rc = 0;
+			}
+#endif /* ENABLE_INPUTBOOST */
+		}
+		mutex_unlock(&dbs_mutex);
+		dbs_timer_init(this_dbs_info);
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined(DISABLE_POWER_MANAGEMENT)
+		register_early_suspend(&_powersave_early_suspend);
+#elif defined(CONFIG_POWERSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined(DISABLE_POWER_MANAGEMENT)
+		if (cpu == 0)
+		    register_power_suspend(&powersave_powersuspend);
+#endif /* (defined(CONFIG_HAS_EARLYSUSPEND)... */
+		break;
+
+	case CPUFREQ_GOV_STOP:
+		/*
+		 * ZZ: enable all cores to avoid cores staying in offline state
+		 * when changing to a non-hotplugging-able governor
+		 */
+#if defined(ENABLE_HOTPLUGGING) && !defined(SNAP_NATIVE_HOTPLUGGING)
+		if (cpu == 0) {
+		    enable_cores = 1;
+		    queue_work_on(0, dbs_wq, &hotplug_online_work);			// ZZ: enable offline cores
+		}
+#endif /* defined(ENABLE_HOTPLUGGING)... */
+		dbs_timer_exit(this_dbs_info);
+
+		this_dbs_info->idle_exit_time = 0;					// ZZ: idle exit time handling
+
+		mutex_lock(&dbs_mutex);
+		dbs_enable--;
+		mutex_destroy(&this_dbs_info->timer_mutex);
+		/*
+		 * Stop the timerschedule work, when this governor
+		 * is used for the last time
+		 */
+		if (dbs_enable == 0) {
+#ifdef ENABLE_INPUTBOOST
+		    if (!policy->cpu && dbs_tuners_ins.inputboost_cycles)
+			input_unregister_handler(&interactive_input_handler);
+#endif /* ENABLE_INPUTBOOST */
+		    cpufreq_unregister_notifier(
+		    &dbs_cpufreq_notifier_block,
+		    CPUFREQ_TRANSITION_NOTIFIER);
+		}
+
+		mutex_unlock(&dbs_mutex);
+		if (!dbs_enable)
+		    sysfs_remove_group(cpufreq_global_kobject,
+		   &dbs_attr_group);
+#if defined(CONFIG_HAS_EARLYSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined(DISABLE_POWER_MANAGEMENT)
+		unregister_early_suspend(&_powersave_early_suspend);
+#elif defined(CONFIG_POWERSUSPEND) && !defined(USE_LCD_NOTIFIER) && !defined(DISABLE_POWER_MANAGEMENT)
+		if (cpu == 0)
+		    unregister_power_suspend(&powersave_powersuspend);
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		break;
+
+	case CPUFREQ_GOV_LIMITS:
+
+		// ZZ: save min/max policy only once from core 0 for freq thresholds ajustment
+		if (cpu == 0) {
+		    pol_max = policy->max;
+		    pol_min = policy->min;
+		}
+
+		mutex_lock(&this_dbs_info->timer_mutex);
+		    if (policy->max < this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->max, CPUFREQ_RELATION_H);
+		    else if (policy->min > this_dbs_info->cur_policy->cur)
+			__cpufreq_driver_target(
+					this_dbs_info->cur_policy,
+					policy->min, CPUFREQ_RELATION_L);
+		dbs_check_cpu(this_dbs_info);
+		mutex_unlock(&this_dbs_info->timer_mutex);
+
+		/*
+		 * ZZ: here again table order detection and limit optimizations
+		 * in case max freq has changed after gov start and before
+		 * Limit case due to apply timing issues. now we should be able to
+		 * catch all freq max changes during start of the governor
+		 */
+		if (cpu == 0)
+		    evaluate_scaling_order_limit_range(0, 1, suspend_flag, policy->min, policy->max);
+
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		// ZZ: do this only on core 0
+		if (cpu == 0) {
+		    if (old_pol_max == 0)						// ZZ: initialize var if we start the first time
+			old_pol_max = policy->max;
+
+		    if (dbs_tuners_ins.auto_adjust_freq_thresholds != 0) {
+			if (old_pol_max != policy->max) {
+			    pol_step = (old_pol_max / 100000) - (policy->max / 100000);	// ZZ: truncate and calculate step
+			    pol_step *= 100000;						// ZZ: bring it back to kHz
+			    pol_step *= -1;						// ZZ: invert for proper addition
+			} else {
+			    pol_step = 0;
+			}
+			old_pol_max = policy->max;
+		    }
+
+		adjust_freq_thresholds(pol_step);					// ZZ: adjust thresholds
+		}
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+		this_dbs_info->time_in_idle
+		= get_cpu_idle_time_us(cpu, &this_dbs_info->idle_exit_time);		// ZZ: idle exit time handling
+		break;
+	}
+	return 0;
+}
+
+#if (defined(USE_LCD_NOTIFIER) && !defined(CONFIG_POWERSUSPEND))
+// AP: callback handler for lcd notifier
+static int zzmoove_lcd_notifier_callback(struct notifier_block *this,
+								unsigned long event, void *data)
+{
+	switch (event)
+	{
+		case LCD_EVENT_OFF_END:
+
+			if (!suspend_flag)
+			    zzmoove_suspend();
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/lcd_notifier] Screen switched off.\n");
+#endif /* ZZMOOVE_DEBUG */
+			break;
+
+		case LCD_EVENT_ON_START:
+
+			if (suspend_flag)
+			    zzmoove_resume();
+#ifdef ZZMOOVE_DEBUG
+			pr_info("[zzmoove/lcd_notifier] Screen switched on.\n");
+#endif /* ZZMOOVE_DEBUG */
+			break;
+
+		default:
+			break;
+	}
+return 0;
+}
+#endif /* (defined(USE_LCD_NOTIFIER) */
+
+#ifndef CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE
+static
+#endif /* CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE */
+struct cpufreq_governor cpufreq_gov_zzmoove = {
+	.name			= "zzmoove",
+	.governor		= cpufreq_governor_dbs,
+	.max_transition_latency	= TRANSITION_LATENCY_LIMIT,
+	.owner			= THIS_MODULE,
+};
+
+static int __init cpufreq_gov_dbs_init(void)						// ZZ: idle exit time handling
+{
+    unsigned int i;
+    struct cpu_dbs_info_s *this_dbs_info;
+    // Initalize per-cpu data:
+    for_each_possible_cpu(i) {
+	this_dbs_info = &per_cpu(cs_cpu_dbs_info, i);
+	this_dbs_info->time_in_idle = 0;
+	this_dbs_info->idle_exit_time = 0;
+    }
+
+    dbs_wq = alloc_workqueue("zzmoove_dbs_wq", WQ_HIGHPRI, 0);
+#ifdef ENABLE_WORK_RESTARTLOOP
+    dbs_aux_wq = alloc_workqueue("zzmoove_dbs_aux_wq", WQ_HIGHPRI, 0);
+
+    if (!dbs_aux_wq) {
+	printk(KERN_ERR "[zzmoove] Failed to create zzmoove_dbs_aux_wq workqueue!\n");
+	return -EFAULT;
+    }
+#endif /* ENABLE_WORK_RESTARTLOOP */
+    if (!dbs_wq) {
+	printk(KERN_ERR "[zzmoove] Failed to create zzmoove_dbs_wq workqueue!\n");
+	return -EFAULT;
+    }
+
+#ifdef ENABLE_WORK_RESTARTLOOP
+    INIT_WORK(&work_restartloop, zz_restartloop_work);
+#endif /* ENABLE_WORK_RESTARTLOOP */
+
+#ifdef ENABLE_HOTPLUGGING
+    INIT_WORK(&hotplug_offline_work, hotplug_offline_work_fn);				// ZZ: init hotplug offline work
+    INIT_WORK(&hotplug_online_work, hotplug_online_work_fn);				// ZZ: init hotplug online work
+#endif /* ENABLE_HOTPLUGGING */
+
+#if (defined(USE_LCD_NOTIFIER) && !defined(CONFIG_POWERSUSPEND))
+	// AP: register callback handler for lcd notifier
+	zzmoove_lcd_notif.notifier_call = zzmoove_lcd_notifier_callback;
+	if (lcd_register_client(&zzmoove_lcd_notif) != 0) {
+		pr_err("%s: Failed to register lcd callback\n", __func__);
+		return -EFAULT;
+	}
+#endif /* (defined(USE_LCD_NOTIFIER)... */
+	return cpufreq_register_governor(&cpufreq_gov_zzmoove);
+}
+
+static void __exit cpufreq_gov_dbs_exit(void)
+{
+	cpufreq_unregister_governor(&cpufreq_gov_zzmoove);
+	destroy_workqueue(dbs_wq);
+#ifdef ENABLE_WORK_RESTARTLOOP
+	destroy_workqueue(dbs_aux_wq);
+#endif /* ENABLE_WORK_RESTARTLOOP */
+
+#if (defined(USE_LCD_NOTIFIER) && !defined(CONFIG_POWERSUSPEND))
+	lcd_unregister_client(&zzmoove_lcd_notif);
+#endif /* (defined(USE_LCD_NOTIFIER)... */
+}
+
+MODULE_AUTHOR("Zane Zaminsky <cyxman@yahoo.com>");
+MODULE_DESCRIPTION("'cpufreq_zzmoove' - A dynamic cpufreq governor based "
+		"on smoove governor from Michael Weingaertner which was originally based on "
+		"cpufreq_conservative from Alexander Clouter. Optimized for use with Samsung I9300 "
+		"using a fast scaling and CPU hotplug logic - ported/modified/optimized for I9300 "
+		"since November 2012 and further improved for exynos and snapdragon platform "
+		"by ZaneZam,Yank555 and ffolkes in 2013/14/15");
+MODULE_LICENSE("GPL");
+
+#ifdef CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE
+fs_initcall(cpufreq_gov_dbs_init);
+#else
+module_init(cpufreq_gov_dbs_init);
+#endif /* CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE */
+module_exit(cpufreq_gov_dbs_exit);
+
diff --git a/drivers/cpufreq/cpufreq_zzmoove_profiles.h b/drivers/cpufreq/cpufreq_zzmoove_profiles.h
new file mode 100644
index 0000000..2211ae4
--- /dev/null
+++ b/drivers/cpufreq/cpufreq_zzmoove_profiles.h
@@ -0,0 +1,2333 @@
+/*
+ * drivers/cpufreq/cpufreq_zzmoove_profiles.h - Profiles
+ *
+ * Copyright (C)  2013 Jean-Pierre Rasquin <yank555.lu@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * ZZMoove Governor profiles header file modified by Zane Zaminsky 2013/14
+ *
+ * currently available profiles by ZaneZam and Yank555:
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (1)'def'    -> Default              -> will set governor defaults                                                                     -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (2)'ybat    -> Yank Battery         -> a very good battery/performance balanced setting                                               -
+ * -                                         DEV-NOTE: highly recommended!                                                                  -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (3)'ybatext'-> Yank Battery Extreme -> like yank battery but focus on battery saving                                                  -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (4)'zzbat'  -> ZaneZam Battery      -> a more 'harsh' setting strictly focused on battery saving                                      -
+ * -                                         DEV-NOTE: might give some lags!                                                                -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (5)'zzbatp' -> ZaneZam Battery Plus -> NEW! reworked 'faster' battery setting                                                         -
+ * -                                         DEV-NOTE: recommended too!:)                                                                   -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (6)'zzopt'  -> ZaneZam Optimized    -> balanced setting with no focus in any direction                                                -
+ * -                                         DEV-NOTE: relict from back in the days, even though some people still like it!                 -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (7)'zzmod'  -> ZaneZam Moderate     -> NEW! setting based on 'zzopt' which has mainly (but not strictly only!) 2 cores online         -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (8)'zzperf' -> ZaneZam Performance  -> all you can get from zzmoove in terms of performance but still has the fast                    -
+ * -                                         down scaling/hotplugging behaving                                                              -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * -  (9)'zzinz'  -> ZaneZam InZane       -> NEW! based on performance with new insane scaling active. a new experience!                    -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * - (10)'zzgame' -> ZaneZam Gaming       -> NEW! based on performance with scaling block enabled to avoid cpu overheating during gameplay  -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ * - (11)'zzrelax'-> ZaneZam Relax        -> NEW! based on moderate (except hotplug settings) with relaxed sleep settings                   -
+ * ------------------------------------------------------------------------------------------------------------------------------------------
+ *
+ * NOTE: be aware when setting tuneables which have a 'should' in comments below that giving
+ *       them 'wrong' values can lead to odd hotplug behaving!
+ */
+
+// NOTE: profile values in this version are mainly for Snapdragon devices!
+static char profiles_file_version[20] = "0.3 beta8 SNAP";
+#define PROFILE_TABLE_END ~1
+#define END_OF_PROFILES "end"
+#define PROFILE_MAX_FREQ (2457600)	// ZZ: max possible freq in system table for freq adaption (possible OC frequencies inclusive)
+
+struct zzmoove_profile {
+	unsigned int profile_number;
+	char         profile_name[20];
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+	unsigned int auto_adjust_freq_thresholds;
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int disable_hotplug;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int disable_hotplug_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+	unsigned int down_threshold;
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int down_threshold_hotplug1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug2;
+	unsigned int down_threshold_hotplug3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug4;
+	unsigned int down_threshold_hotplug5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int down_threshold_hotplug6;
+	unsigned int down_threshold_hotplug7;
+#endif /* (MAX_CORES == 8) */
+	unsigned int down_threshold_hotplug_freq1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug_freq2;
+	unsigned int down_threshold_hotplug_freq3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int down_threshold_hotplug_freq4;
+	unsigned int down_threshold_hotplug_freq5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int down_threshold_hotplug_freq6;
+	unsigned int down_threshold_hotplug_freq7;
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int down_threshold_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int early_demand;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int early_demand_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int fast_scaling_up;
+	unsigned int fast_scaling_down;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int fast_scaling_sleep_up;
+	unsigned int fast_scaling_sleep_down;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int afs_threshold1;
+	unsigned int afs_threshold2;
+	unsigned int afs_threshold3;
+	unsigned int afs_threshold4;
+	unsigned int freq_limit;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int freq_limit_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int grad_up_threshold;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int grad_up_threshold_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int hotplug_block_up_cycles;
+	unsigned int block_up_multiplier_hotplug1;
+	unsigned int block_up_multiplier_hotplug2;
+	unsigned int block_up_multiplier_hotplug3;
+	unsigned int block_up_multiplier_hotplug4;
+	unsigned int block_up_multiplier_hotplug5;
+	unsigned int block_up_multiplier_hotplug6;
+	unsigned int block_up_multiplier_hotplug7;
+	unsigned int hotplug_block_down_cycles;
+	unsigned int block_down_multiplier_hotplug1;
+	unsigned int block_down_multiplier_hotplug2;
+	unsigned int block_down_multiplier_hotplug3;
+	unsigned int block_down_multiplier_hotplug4;
+	unsigned int block_down_multiplier_hotplug5;
+	unsigned int block_down_multiplier_hotplug6;
+	unsigned int block_down_multiplier_hotplug7;
+	unsigned int hotplug_stagger_up;
+	unsigned int hotplug_stagger_down;
+	unsigned int hotplug_idle_threshold;
+	unsigned int hotplug_idle_freq;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int hotplug_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int hotplug_engage_freq;
+	unsigned int hotplug_max_limit;
+	unsigned int hotplug_min_limit;
+	unsigned int hotplug_lock;
+#endif /* ENABLE_HOTPLUGGING */
+	unsigned int ignore_nice_load;
+	unsigned int sampling_down_factor;
+	unsigned int sampling_down_max_momentum;
+	unsigned int sampling_down_momentum_sensitivity;
+	unsigned int sampling_rate;
+	unsigned int sampling_rate_idle;
+	unsigned int sampling_rate_idle_delay;
+	unsigned int sampling_rate_idle_threshold;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int sampling_rate_sleep_multiplier;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int scaling_block_cycles;
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+	unsigned int scaling_block_temp;
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+	unsigned int scaling_trip_temp;
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+	unsigned int scaling_block_freq;
+	unsigned int scaling_block_threshold;
+	unsigned int scaling_block_force_down;
+	unsigned int scaling_fastdown_freq;
+	unsigned int scaling_fastdown_up_threshold;
+	unsigned int scaling_fastdown_down_threshold;
+	unsigned int scaling_responsiveness_freq;
+	unsigned int scaling_responsiveness_up_threshold;
+	unsigned int scaling_proportional;
+#ifdef ENABLE_INPUTBOOSTER
+	unsigned int inputboost_cycles;
+	unsigned int inputboost_up_threshold;
+	unsigned int inputboost_punch_cycles;
+	unsigned int inputboost_punch_freq;
+	unsigned int inputboost_punch_on_fingerdown;
+	unsigned int inputboost_punch_on_fingermove;
+	unsigned int inputboost_punch_on_epenmove;
+	unsigned int inputboost_typingbooster_up_threshold;
+	unsigned int inputboost_typingbooster_cores;
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+	unsigned int music_max_freq;
+	unsigned int music_min_freq;
+	unsigned int music_min_cores;
+#endif /* ENABLE_MUSIC_LIMITS */
+	unsigned int smooth_up;
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int smooth_up_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	unsigned int up_threshold;
+#ifdef ENABLE_HOTPLUGGING
+	unsigned int up_threshold_hotplug1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug2;
+	unsigned int up_threshold_hotplug3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug4;
+	unsigned int up_threshold_hotplug5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int up_threshold_hotplug6;
+	unsigned int up_threshold_hotplug7;
+#endif /* (MAX_CORES == 8) */
+	unsigned int up_threshold_hotplug_freq1;
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug_freq2;
+	unsigned int up_threshold_hotplug_freq3;
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+	unsigned int up_threshold_hotplug_freq4;
+	unsigned int up_threshold_hotplug_freq5;
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+	unsigned int up_threshold_hotplug_freq6;
+	unsigned int up_threshold_hotplug_freq7;
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+	unsigned int up_threshold_sleep;
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+};
+
+struct zzmoove_profile zzmoove_profiles[] = {
+	{
+		1,		// Default Profile
+		"def",		// default settings as hardcoded in the governor (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds (any value=enable, 0=disable)
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug (1=disable hotplugging, 0=enable hotplugging)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep (1=disable hotplugging, 0=enable hotplugging)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		52,		// down_threshold (range from 11 to 100 and must be lower than up_threshold)
+#ifdef ENABLE_HOTPLUGGING
+		55,		// down_threshold_hotplug1 (range from 1 to 100 and should be lower than up_threshold_hotplug1)
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug2 (range from 1 to 100 and should be lower than up_threshold_hotplug2)
+		55,		// down_threshold_hotplug3 (range from 1 to 100 and should be lower than up_threshold_hotplug3)
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4 (range from 1 to 100 and should be lower than up_threshold_hotplug4)
+		55,		// down_threshold_hotplug5 (range from 1 to 100 and should be lower than up_threshold_hotplug5)
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6 (range from 1 to 100 and should be lower than up_threshold_hotplug6)
+		55,		// down_threshold_hotplug7 (range from 1 to 100 and should be lower than up_threshold_hotplug7)
+#endif /* (MAX_CORES == 8) */
+		0,		// down_threshold_hotplug_freq1 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq1)
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq2 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq2)
+		0,		// down_threshold_hotplug_freq3 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq3)
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq4)
+		0,		// down_threshold_hotplug_freq5 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq5)
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq6)
+		0,		// down_threshold_hotplug_freq7 (range from 0 to scaling max and should be lower than up_threshold_hotplug_freq7)
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		44,		// down_threshold_sleep (range from 11 to 100 and must be lower than up_threshold_sleep)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// early_demand (any value=enable, 0=disable)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep (any value=enable, 0=disable)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// fast_scaling_up (range from 0 to 4)
+		0,		// fast_scaling_down (range from 0 to 4)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up (range from 0 to 4)
+		0,		// fast_scaling_sleep_down (range from 0 to 4)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		25,		// auto fast scaling step one (range from 1 to 100)
+		50,		// auto fast scaling step two (range from 1 to 100)
+		75,		// auto fast scaling step three (range from 1 to 100)
+		90,		// auto fast scaling step four (range from 1 to 100)
+		0,		// freq_limit (0=disable, range in system table from freq->min to freq->max in khz)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// freq_limit_sleep (0=disable, range in system table from freq->min to freq->max in khz)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		25,		// grad_up_threshold (range from 1 to 100)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep (range from 1 to 100)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles (0=disable, any value above 0)
+		1,		// block_up_multiplier_hotplug1 (1=disable hotplug up block cycles for 2nd core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug2 (1=disable hotplug up block cycles for 3rd core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug3 (1=disable hotplug up block cycles for 4th core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug4 (1=disable hotplug up block cycles for 2nd core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug5 (1=disable hotplug up block cycles for 3rd core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug6 (1=disable hotplug up block cycles for 4th core, 2 to 25x)
+		1,		// block_up_multiplier_hotplug7 (1=disable hotplug up block cycles for 4th core, 2 to 25x)
+		2,		// hotplug_block_down_cycles (0=disable, any value above 0)
+		1,		// block_down_multiplier_hotplug1 (1=disable hotplug down block cycles for 2nd core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug2 (1=disable hotplug down block cycles for 3rd core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug3 (1=disable hotplug down block cycles for 4th core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug4 (1=disable hotplug down block cycles for 2nd core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug5 (1=disable hotplug down block cycles for 3rd core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug6 (1=disable hotplug down block cycles for 4th core, 2 to 25x)
+		1,		// block_down_multiplier_hotplug7 (1=disable hotplug down block cycles for 4th core, 2 to 25x)
+		0,		// hotplug_stagger_up (0=disable, any value above 0)
+		0,		// hotplug_stagger_down (0=disable, any value above 0)
+		0,		// hotplug_idle_threshold (0=disable, range from 1 to 100)
+		0,		// hotplug_idle_freq (0=disable, range in system table from freq->min to freq->max in khz)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// hotplug_sleep (0=all cores enabled, range 1 to MAX_CORES - 1)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq (0=disable, range in system table from freq->min to freq->max in khz)
+		0,		// hotplug_max_limit (0=disable, range from 1 to MAX_CORES)
+		0,		// hotplug_min_limit (0=disable, range from 1 to MAX_CORES)
+		0,		// hotplug_lock (0=disable, range from 1 to MAX_CORES)
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load (0=disable, 1=enable)
+		1,		// sampling_down_factor (1=disable, range from 2 to MAX_SAMPLING_DOWN_FACTOR)
+		0,		// sampling_down_max_momentum (0=disable, range from 1 to MAX_SAMPLING_DOWN_FACTOR)
+		50,		// sampling_down_momentum_sensitivity (range from 1 to MAX_SAMPLING_DOWN_SENSITIVITY)
+		100000,		// sampling_rate (range from MIN_SAMPLING_RATE to any value)
+		180000,		// sampling_rate_idle (range from MIN_SAMPLING_RATE to any value)
+		0,		// sampling_rate_idle_delay (0=disable, any value above 0)
+		40,		// sampling_rate_idle_threshold (range from 1 to 100)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// sampling_rate_sleep_multiplier (range from 1 to 4)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles (0=disable, any value above 0)
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp (0=disable, range from 30C to 80C)
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp (0=disable, range from 40C to 69C)
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		1728000,	// scaling_block_freq (all valid system frequencies)
+		10,		// scaling_block_threshold (0=disable, range from 1 to 100)
+		2,		// scaling_block_force_down (0=disable, range from 2 to any value)
+		0,		// scaling_fastdown_freq (0=disable, range in system table from freq->min to freq->max in khz)
+		95,		// scaling_fastdown_up_threshold (range from over scaling_fastdown_down_threshold to 100)
+		90,		// scaling_fastdown_down_threshold (range from 11 to under scaling_fastdown_up_threshold)
+		0,		// scaling_responsiveness_freq (0=disable, range in system table from freq->min to freq->max in khz)
+		30,		// scaling_responsiveness_up_threshold (0=disable, range from 11 to 100)
+		0,		// scaling_proportional (0=disable, range from 1 to 3)
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles (0=disable, range from 0 to 1000)
+		80,		// inputboost_up_threshold (0=disable, range from 0 to 100)
+		20,		// inputboost_punch_cycles (0= disable, range form 0 to 500)
+		1728000,	// inputboost_punch_freq (0=disable, range from 0 to freq->max in khz)
+		1,		// inputboost_punch_on_fingerdown (0=disable, any value above 0)
+		0,		// inputboost_punch_on_fingermove (0=disable, any value above 0)
+		0,		// inputboost_punch_on_epenmove (0=disable, any value above 0)
+		40,		// inputboost_typingbooster_up_threshold (0=disable, range from 0 to 100)
+		3,		// inputboost_typingbooster_cores (0=disable, range from 1 to MAX_CORES)
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq (0=disable, range from 0 to freq->max in khz)
+		422400,		// music_min_freq (0=disable, range from 0 to freq->min in khz)
+		2,		// music_min_cores (0=disable, range from 1 to MAX_CORES)
+#endif /* ENABLE_MUSIC_LIMITS */
+		75,		// smooth_up (range from 1 to 100)
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep (range from 1 to 100)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		70,		// up_threshold (range 1 to 100 and must be higher than down_threshold)
+#ifdef ENABLE_HOTPLUGGING
+		68,		// up_threshold_hotplug1 (range 1 to 100 and should be higher than down_threshold_hotplug1)
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug2 (range 1 to 100 and should be higher than down_threshold_hotplug2)
+		68,		// up_threshold_hotplug3 (range 1 to 100 and should be higher than down_threshold_hotplug3)
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4 (range 1 to 100 and should be higher than down_threshold_hotplug4)
+		68,		// up_threshold_hotplug5 (range 1 to 100 and should be higher than down_threshold_hotplug5)
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6 (range 1 to 100 and should be higher than down_threshold_hotplug6)
+		68,		// up_threshold_hotplug7 (range 1 to 100 and should be higher than down_threshold_hotplug7)
+#endif /* (MAX_CORES == 8) */
+		0,		// up_threshold_hotplug_freq1 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq1)
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq2 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq2)
+		0,		// up_threshold_hotplug_freq3 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq3)
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq4)
+		0,		// up_threshold_hotplug_freq5 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq5)
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq6)
+		0,		// up_threshold_hotplug_freq7 (0 to disable core, range from 1 to scaling max and should be higher than down_threshold_hotplug_freq7)
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		90		// up_threshold_sleep (range from above down_threshold_sleep to 100)
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		2,
+		"ybat",		// Yank555.lu Battery Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		40,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		65,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		75,		// down_threshold_hotplug2
+		85,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		960000,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1267200,	// down_threshold_hotplug_freq2
+		1728000,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		75,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		5,		// fast_scaling_up
+		2,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		50,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		1,		// sampling_down_factor
+		0,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		75000,		// sampling_rate
+		180000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		95,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		90,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		85,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		90,		// up_threshold_hotplug2
+		98,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		1036800,	// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1497600,	// up_threshold_hotplug_freq2
+		2265600,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		85		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		3,
+		"ybatext",	// Yank555.lu Battery Extreme Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		50,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		70,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		80,		// down_threshold_hotplug2
+		90,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		883200,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1190400,	// down_threshold_hotplug_freq2
+		1574400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		75,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		5,		// fast_scaling_up
+		3,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		50,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		1,		// sampling_down_factor
+		0,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		70000,		// sampling_rate
+		180000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		95,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		90,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		70,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		90,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		95,		// up_threshold_hotplug2
+		98,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		1190400,	// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1574400,	// up_threshold_hotplug_freq2
+		2265600,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		85		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		4,
+		"zzbat",	// ZaneZam Battery Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		40,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		45,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug2
+		65,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		652800,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		960000,		// down_threshold_hotplug_freq2
+		1267200,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		60,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		50,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		1,		// sampling_down_factor
+		0,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		100000,		// sampling_rate
+		180000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		75,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		95,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		60,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		80,		// up_threshold_hotplug2
+		98,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		729600,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1190400,	// up_threshold_hotplug_freq2
+		1574400,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		5,
+		"zzbatp",	// ZaneZam Battery Plus Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		70,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		20,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		70,		// down_threshold_hotplug2
+		80,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		652800,		// down_threshold_hotplug_freq2
+		1574400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		65,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		1,		// sampling_down_factor
+		0,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		120000,		// sampling_rate
+		200000,		// sampling_rate_idle
+		5,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		80,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		75,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		20,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		50,		// up_threshold_hotplug2
+		90,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1497600,	// up_threshold_hotplug_freq2
+		1728000,	// up_threshold_hotplug_freq3
+
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		6,
+		"zzopt",	// ZaneZam Optimized Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		52,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		45,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug2
+		65,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		883200,		// down_threshold_hotplug_freq2
+		1190400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		60,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		35,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		20,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		70000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		0,		// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		422400,		// scaling_responsiveness_freq
+		0,		// scaling_responsiveness_up_threshold
+		0,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		75,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		67,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		68,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		78,		// up_threshold_hotplug2
+		88,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		652800,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1036800,	// up_threshold_hotplug_freq2
+		1574400,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		7,
+		"zzmod",	// ZaneZam Moderate Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		52,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		30,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		60,		// down_threshold_hotplug2
+		70,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		300000,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq2
+		0,		// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		55,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		3,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		40,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		20,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		70000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		68,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		20,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		100,		// up_threshold_hotplug2
+		100,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq2
+		0,		// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		8,
+		"zzperf",	// ZaneZam Performance Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		20,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		25,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		35,		// down_threshold_hotplug2
+		45,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		300000,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1190400,	// down_threshold_hotplug_freq2
+		1574400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		60,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// fast_scaling_up
+		1,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		25,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		50,		// sampling_down_max_momentum
+		25,		// sampling_down_momentum_sensitivity
+		60000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		0,		// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		0,		// scaling_responsiveness_freq
+		0,		// scaling_responsiveness_up_threshold
+		0,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		70,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		65,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		75,		// up_threshold_hotplug2
+		85,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1267200,	// up_threshold_hotplug_freq2
+		1728000,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		9,
+		"zzinz",	// ZaneZam InZane Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		20,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		25,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		35,		// down_threshold_hotplug2
+		45,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		300000,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		883200,		// down_threshold_hotplug_freq2
+		1036800,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		60,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		5,		// fast_scaling_up
+		5,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		25,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		80,		// sampling_down_max_momentum
+		15,		// sampling_down_momentum_sensitivity
+		60000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		0,		// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		0,		// scaling_responsiveness_freq
+		0,		// scaling_responsiveness_up_threshold
+		0,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		60,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		50,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		60,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		70,		// up_threshold_hotplug2
+		80,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1267200,	// up_threshold_hotplug_freq2
+		1728000,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		10,
+		"zzgame",	// ZaneZam Game Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		20,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		25,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		35,		// down_threshold_hotplug2
+		45,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1190400,	// down_threshold_hotplug_freq2
+		1574400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		60,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		729600,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		25,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		60,		// sampling_down_max_momentum
+		20,		// sampling_down_momentum_sensitivity
+		60000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		4,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_cycles
+		65,		// scaling_block_temp
+#else
+		15,		// scaling_block_cycles
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		1574400,	// scaling_block_freq
+		5,		// scaling_block_threshold
+		3,		// scaling_block_force_down
+		0,		// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		0,		// scaling_responsiveness_freq
+		0,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		70,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		65,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		75,		// up_threshold_hotplug2
+		85,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		652800,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1267200,	// up_threshold_hotplug_freq2
+		1958400,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		100		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		11,
+		"zzrelax",	// ZaneZam Relax Profile (please don't remove this profile)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		1,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		52,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		30,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		60,		// down_threshold_hotplug2
+		70,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		55,		// down_threshold_hotplug4
+		55,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		55,		// down_threshold_hotplug6
+		55,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		300000,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		883200,		// down_threshold_hotplug_freq2
+		1190400,	// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		59,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		1,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		1,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		3,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		30,		// afs_threshold1
+		50,		// afs_threshold2
+		70,		// afs_threshold3
+		90,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		40,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		28,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		2,		// hotplug_block_up_cycles
+		1,		// block_up_multiplier_hotplug1
+		1,		// block_up_multiplier_hotplug2
+		1,		// block_up_multiplier_hotplug3
+		1,		// block_up_multiplier_hotplug4
+		1,		// block_up_multiplier_hotplug5
+		1,		// block_up_multiplier_hotplug6
+		1,		// block_up_multiplier_hotplug7
+		2,		// hotplug_block_down_cycles
+		1,		// block_down_multiplier_hotplug1
+		1,		// block_down_multiplier_hotplug2
+		1,		// block_down_multiplier_hotplug3
+		1,		// block_down_multiplier_hotplug4
+		1,		// block_down_multiplier_hotplug5
+		1,		// block_down_multiplier_hotplug6
+		1,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		2,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		4,		// sampling_down_factor
+		20,		// sampling_down_max_momentum
+		50,		// sampling_down_momentum_sensitivity
+		70000,		// sampling_rate
+		100000,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		40,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		2,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// scaling_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		2,		// scaling_block_force_down
+		1958400,	// scaling_fastdown_freq
+		95,		// scaling_fastdown_up_threshold
+		90,		// scaling_fastdown_down_threshold
+		652800,		// scaling_responsiveness_freq
+		20,		// scaling_responsiveness_up_threshold
+		1,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		80,		// inputboost_up_threshold
+		20,		// inputboost_punch_cycles
+		1728000,	// inputboost_punch_freq
+		1,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		40,		// inputboost_typingbooster_up_threshold
+		3,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		1497600,	// music_max_freq
+		422400,		// music_min_freq
+		2,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		68,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		68,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		60,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		68,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		78,		// up_threshold_hotplug2
+		88,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		68,		// up_threshold_hotplug4
+		68,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		68,		// up_threshold_hotplug6
+		68,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		422400,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		1036800,	// up_threshold_hotplug_freq2
+		1574400,	// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		70		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	},
+	{
+		PROFILE_TABLE_END,
+		END_OF_PROFILES,// End of table entry (DON'T REMOVE THIS PROFILE !!!)
+#ifdef ENABLE_AUTO_ADJUST_FREQ
+		0,		// auto_adjust_freq_thresholds
+#endif /* ENABLE_AUTO_ADJUST_FREQ */
+#ifdef ENABLE_HOTPLUGGING
+		0,		// disable_hotplug
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// disable_hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// down_threshold
+#ifdef ENABLE_HOTPLUGGING
+		0,		// down_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug2
+		0,		// down_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug4
+		0,		// down_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug6
+		0,		// down_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		0,		// down_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq2
+		0,		// down_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq4
+		0,		// down_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// down_threshold_hotplug_freq6
+		0,		// down_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// down_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// early_demand
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// early_demand_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// fast_scaling_up
+		0,		// fast_scaling_down
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// fast_scaling_sleep_up
+		0,		// fast_scaling_sleep_down
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// afs_threshold1
+		0,		// afs_threshold2
+		0,		// afs_threshold3
+		0,		// afs_threshold4
+		0,		// freq_limit
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// freq_limit_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// grad_up_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// grad_up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+#ifdef ENABLE_HOTPLUGGING
+		0,		// hotplug_block_up_cycles
+		0,		// block_up_multiplier_hotplug1
+		0,		// block_up_multiplier_hotplug2
+		0,		// block_up_multiplier_hotplug3
+		0,		// block_up_multiplier_hotplug4
+		0,		// block_up_multiplier_hotplug5
+		0,		// block_up_multiplier_hotplug6
+		0,		// block_up_multiplier_hotplug7
+		0,		// hotplug_block_down_cycles
+		0,		// block_down_multiplier_hotplug1
+		0,		// block_down_multiplier_hotplug2
+		0,		// block_down_multiplier_hotplug3
+		0,		// block_down_multiplier_hotplug4
+		0,		// block_down_multiplier_hotplug5
+		0,		// block_down_multiplier_hotplug6
+		0,		// block_down_multiplier_hotplug7
+		0,		// hotplug_stagger_up
+		0,		// hotplug_stagger_down
+		0,		// hotplug_idle_threshold
+		0,		// hotplug_idle_freq
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// hotplug_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// hotplug_engage_freq
+		0,		// hotplug_max_limit
+		0,		// hotplug_min_limit
+		0,		// hotplug_lock
+#endif /* ENABLE_HOTPLUGGING */
+		0,		// ignore_nice_load
+		0,		// sampling_down_factor
+		0,		// sampling_down_max_momentum
+		0,		// sampling_down_momentum_sensitivity
+		0,		// sampling_rate
+		0,		// sampling_rate_idle
+		0,		// sampling_rate_idle_delay
+		0,		// sampling_rate_idle_threshold
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// sampling_rate_sleep_multiplier
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// scaling_block_cycles
+#ifdef CONFIG_EXYNOS4_EXPORT_TEMP
+		0,		// hotplug_block_temp
+#endif /* CONFIG_EXYNOS4_EXPORT_TEMP */
+#ifdef ENABLE_SNAP_THERMAL_SUPPORT
+		0,		// scaling_trip_temp
+#endif /* ENABLE_SNAP_THERMAL_SUPPORT */
+		0,		// scaling_block_freq
+		0,		// scaling_block_threshold
+		0,		// scaling_block_force_down
+		0,		// scaling_fastdown_freq
+		0,		// scaling_fastdown_up_threshold
+		0,		// scaling_fastdown_down_threshold
+		0,		// scaling_responsiveness_freq
+		0,		// scaling_responsiveness_up_threshold
+		0,		// scaling_proportional
+#ifdef ENABLE_INPUTBOOSTER
+		0,		// inputboost_cycles
+		0,		// inputboost_up_threshold
+		0,		// inputboost_punch_cycles
+		0,		// inputboost_punch_freq
+		0,		// inputboost_punch_on_fingerdown
+		0,		// inputboost_punch_on_fingermove
+		0,		// inputboost_punch_on_epenmove
+		0,		// inputboost_typingbooster_up_threshold
+		0,		// inputboost_typingbooster_cores
+#endif /* ENABLE_INPUTBOOSTER */
+#ifdef ENABLE_MUSIC_LIMITS
+		0,		// music_max_freq
+		0,		// music_min_freq
+		0,		// music_min_cores
+#endif /* ENABLE_MUSIC_LIMITS */
+		0,		// smooth_up
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0,		// smooth_up_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+		0,		// up_threshold
+#ifdef ENABLE_HOTPLUGGING
+		0,		// up_threshold_hotplug1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug2
+		0,		// up_threshold_hotplug3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug4
+		0,		// up_threshold_hotplug5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug6
+		0,		// up_threshold_hotplug7
+#endif /* (MAX_CORES == 8) */
+		0,		// up_threshold_hotplug_freq1
+#if (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq2
+		0,		// up_threshold_hotplug_freq3
+#endif /* (MAX_CORES == 4 || MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 6 || MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq4
+		0,		// up_threshold_hotplug_freq5
+#endif /* (MAX_CORES == 6 || MAX_CORES == 8) */
+#if (MAX_CORES == 8)
+		0,		// up_threshold_hotplug_freq6
+		0,		// up_threshold_hotplug_freq7
+#endif /* (MAX_CORES == 8) */
+#endif /* ENABLE_HOTPLUGGING */
+#if defined(CONFIG_HAS_EARLYSUSPEND) || defined(CONFIG_POWERSUSPEND) || defined(USE_LCD_NOTIFIER)
+		0		// up_threshold_sleep
+#endif /* defined(CONFIG_HAS_EARLYSUSPEND)... */
+	}
+};
+
diff --git a/drivers/cpuquiet/cpuquiet.c b/drivers/cpuquiet/cpuquiet.c
index 7a7b958..ae270de 100644
--- a/drivers/cpuquiet/cpuquiet.c
+++ b/drivers/cpuquiet/cpuquiet.c
@@ -178,6 +178,7 @@ static void __cpuinit cpuquiet_work_func(struct work_struct *work)
 	/* always keep CPU0 online */
 	cpumask_set_cpu(0, &online);
 	cpu_online = *cpu_online_mask;
+	cpumask_clear_cpu(0, &offline);
 
 	if (max_cpus < min_cpus)
 		max_cpus = min_cpus;
diff --git a/drivers/cpuquiet/governor.c b/drivers/cpuquiet/governor.c
index c094484..31bc4d0 100644
--- a/drivers/cpuquiet/governor.c
+++ b/drivers/cpuquiet/governor.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012 NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2012-2014 NVIDIA CORPORATION.  All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -50,6 +50,10 @@ int cpuquiet_switch_governor(struct cpuquiet_governor *gov)
 {
 	int err = 0;
 
+	/* Governor is already set, bail early */
+	if (cpuquiet_curr_governor == gov)
+		return err;
+
 	if (cpuquiet_curr_governor) {
 		if (cpuquiet_curr_governor->stop)
 			cpuquiet_curr_governor->stop();
diff --git a/drivers/cpuquiet/governors/runnable_threads.c b/drivers/cpuquiet/governors/runnable_threads.c
index 28e93bc..4bde159 100644
--- a/drivers/cpuquiet/governors/runnable_threads.c
+++ b/drivers/cpuquiet/governors/runnable_threads.c
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2013 NVIDIA CORPORATION.  All rights reserved.
+ * Copyright (c) 2012-2014 NVIDIA CORPORATION.  All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -38,7 +38,7 @@ static unsigned int sample_rate = 200;	  /* msec */
 #define NR_FSHIFT      (1 << NR_FSHIFT_EXP)
 /* avg run threads * 8 (e.g., 11 = 1.375 threads) */
 static unsigned int default_thresholds[] = {
-	10, 18, 20, UINT_MAX
+	10, 14, 20, UINT_MAX
 };
 
 static unsigned int nr_run_last;
@@ -227,12 +227,30 @@ static void runnables_stop(void)
 
 static int runnables_start(void)
 {
-	int i, err, arch_specific_sample_rate;
+	int err;
 
 	err = runnables_sysfs_init();
 	if (err)
 		return err;
 
+	runnables_enabled = true;
+
+	runnables_avg_sampler(0);
+
+	return 0;
+}
+
+static struct cpuquiet_governor runnables_governor = {
+	.name			= "runnable",
+	.start			= runnables_start,
+	.stop			= runnables_stop,
+	.owner			= THIS_MODULE,
+};
+
+static int __init init_runnables(void)
+{
+	int i, arch_specific_sample_rate;
+
 	INIT_WORK(&runnables_work, runnables_work_func);
 
 	init_timer(&runnables_timer);
@@ -247,31 +265,15 @@ static int runnables_start(void)
 		sample_rate = arch_specific_sample_rate * 10;
 
 	for (i = 0; i < ARRAY_SIZE(nr_run_thresholds); ++i) {
-		if (i < ARRAY_SIZE(default_thresholds))
-			nr_run_thresholds[i] = default_thresholds[i];
-		else if (i == (ARRAY_SIZE(nr_run_thresholds) - 1))
+		if (i == (ARRAY_SIZE(nr_run_thresholds) - 1))
 			nr_run_thresholds[i] = UINT_MAX;
+		else if (i < ARRAY_SIZE(default_thresholds))
+			nr_run_thresholds[i] = default_thresholds[i];
 		else
 			nr_run_thresholds[i] = i + 1 +
 				NR_FSHIFT / default_threshold_level;
 	}
 
-	runnables_enabled = true;
-
-	runnables_avg_sampler(0);
-
-	return 0;
-}
-
-static struct cpuquiet_governor runnables_governor = {
-	.name			= "runnable",
-	.start			= runnables_start,
-	.stop			= runnables_stop,
-	.owner			= THIS_MODULE,
-};
-
-static int __init init_runnables(void)
-{
 	return cpuquiet_register_governor(&runnables_governor);
 }
 
diff --git a/drivers/devfreq/Kconfig b/drivers/devfreq/Kconfig
index 5c055cf..13afb12 100644
--- a/drivers/devfreq/Kconfig
+++ b/drivers/devfreq/Kconfig
@@ -79,6 +79,15 @@ config DEVFREQ_GOV_MSM_ADRENO_TZ
 	  Sets the frequency using a "on-demand" algorithm.
 	  This governor is unlikely to be useful for other devices.
 
+config ADRENO_IDLER
+	tristate "MSM Adreno idler"
+	depends on DEVFREQ_GOV_MSM_ADRENO_TZ
+	help
+	  Uses a different calculation method on top of Adreno TZ
+	  just for calculating frequency for idle to reduce the
+	  wasted power coming from stock Adreno TZ while
+	  maintaining high-performance.
+
 config MSM_BIMC_BWMON
 	tristate "MSM BIMC Bandwidth monitor hardware"
 	depends on ARCH_MSM
diff --git a/drivers/devfreq/Makefile b/drivers/devfreq/Makefile
index 97b550b..7fd3d00 100644
--- a/drivers/devfreq/Makefile
+++ b/drivers/devfreq/Makefile
@@ -8,6 +8,7 @@ obj-$(CONFIG_DEVFREQ_GOV_POWERSAVE)	+= governor_powersave.o
 obj-$(CONFIG_DEVFREQ_GOV_USERSPACE)	+= governor_userspace.o
 obj-$(CONFIG_DEVFREQ_GOV_CPUFREQ)	+= governor_cpufreq.o
 obj-$(CONFIG_DEVFREQ_GOV_MSM_ADRENO_TZ)	+= governor_msm_adreno_tz.o
+obj-$(CONFIG_ADRENO_IDLER)		+= adreno_idler.o
 obj-$(CONFIG_DEVFREQ_GOV_MSM_CPUFREQ)	+= governor_msm_cpufreq.o
 obj-$(CONFIG_ARCH_MSM_KRAIT)		+= krait-l2pm.o
 obj-$(CONFIG_MSM_BIMC_BWMON)		+= bimc-bwmon.o
diff --git a/drivers/devfreq/adreno_idler.c b/drivers/devfreq/adreno_idler.c
new file mode 100644
index 0000000..0e6cd27b
--- /dev/null
+++ b/drivers/devfreq/adreno_idler.c
@@ -0,0 +1,113 @@
+/*
+ * Author: Park Ju Hyung aka arter97 <qkrwngud825@gmail.com>
+ *
+ * Copyright 2015 Park Ju Hyung
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+/*
+ * Adreno idler - Idling algorithm,
+ * an efficient workaround for msm-adreno-tz's overheads.
+ *
+ * Main goal is to lower the power consumptions while maintaining high-performance.
+ *
+ * Since msm-adreno-tz tends to *not* use the lowest frequency even on idle,
+ * Adreno idler replaces msm-adreno-tz's algorithm when it comes to
+ * calculating idle frequency(mostly by ondemand's method).
+ * The higher frequencies are not touched with this algorithm, so high-demanding
+ * games will (most likely) not suffer from worsened performance.
+ */
+
+#include <linux/module.h>
+#include <linux/devfreq.h>
+#include <linux/msm_adreno_devfreq.h>
+
+#define ADRENO_IDLER_MAJOR_VERSION 1
+#define ADRENO_IDLER_MINOR_VERSION 1
+
+/* stats.busy_time threshold for determining if the given workload is idle.
+   Any workload higher than this will be treated as a non-idle workload.
+   Adreno idler will more actively try to ramp down the frequency
+   if this is set to a higher value. */
+static unsigned long idleworkload = 5000;
+module_param_named(adreno_idler_idleworkload, idleworkload, ulong, 0664);
+
+/* Number of events to wait before ramping down the frequency.
+   The idlewait'th events before current one must be all idle before
+   Adreno idler ramps down the frequency.
+   This implementation is to prevent micro-lags on scrolling or playing games.
+   Adreno idler will more actively try to ramp down the frequency
+   if this is set to a lower value. */
+static unsigned int idlewait = 20;
+module_param_named(adreno_idler_idlewait, idlewait, uint, 0664);
+
+/* Taken from ondemand */
+static unsigned int downdifferential = 20;
+module_param_named(adreno_idler_downdifferential, downdifferential, uint, 0664);
+
+/* Master switch to activate the whole routine */
+static bool adreno_idler_active = true;
+module_param_named(adreno_idler_active, adreno_idler_active, bool, 0664);
+
+static unsigned int idlecount = 0;
+
+int adreno_idler(struct devfreq_dev_status stats, struct devfreq *devfreq,
+		 unsigned long *freq)
+{
+	if (!adreno_idler_active)
+		return 0;
+
+	if (stats.busy_time < idleworkload) {
+		/* busy_time >= idleworkload should be considered as a non-idle workload. */
+		idlecount++;
+		if (*freq == devfreq->profile->freq_table[devfreq->profile->max_state - 1]) {
+			/* Frequency is already at its lowest.
+			   No need to calculate things, so bail out. */
+			return 1;
+		}
+		if (idlecount >= idlewait &&
+		    stats.busy_time * 100 < stats.total_time * downdifferential) {
+			/* We are idle for (idlewait + 1)'th time! Ramp down the frequency now. */
+			*freq = devfreq->profile->freq_table[devfreq->profile->max_state - 1];
+			idlecount--;
+			return 1;
+		}
+	} else {
+		idlecount = 0;
+		/* Do not return 1 here and allow rest of the algorithm to
+		   figure out the appropriate frequency for current workload.
+		   It can even set it back to the lowest frequency. */
+	}
+	return 0;
+}
+EXPORT_SYMBOL(adreno_idler);
+
+static int __init adreno_idler_init(void)
+{
+	pr_info("adreno_idler: version %d.%d by arter97\n",
+		 ADRENO_IDLER_MAJOR_VERSION,
+		 ADRENO_IDLER_MINOR_VERSION);
+
+	return 0;
+}
+subsys_initcall(adreno_idler_init);
+
+static void __exit adreno_idler_exit(void)
+{
+	return;
+}
+module_exit(adreno_idler_exit);
+
+MODULE_AUTHOR("Park Ju Hyung <qkrwngud825@gmail.com>");
+MODULE_DESCRIPTION("'adreno_idler - A powersaver for Adreno TZ"
+	"Control idle algorithm for Adreno GPU series");
+MODULE_LICENSE("GPL");
diff --git a/drivers/devfreq/governor_msm_adreno_tz.c b/drivers/devfreq/governor_msm_adreno_tz.c
index d68ae65..7404f82 100644
--- a/drivers/devfreq/governor_msm_adreno_tz.c
+++ b/drivers/devfreq/governor_msm_adreno_tz.c
@@ -176,6 +176,10 @@ static int tz_init(struct devfreq_msm_adreno_tz_data *priv,
 	return ret;
 }
 
+#ifdef CONFIG_ADRENO_IDLER
+extern int adreno_idler(struct devfreq_dev_status stats, struct devfreq *devfreq,
+		 unsigned long *freq);
+#endif
 static int tz_get_target_freq(struct devfreq *devfreq, unsigned long *freq,
 				u32 *flag)
 {
@@ -193,7 +197,22 @@ static int tz_get_target_freq(struct devfreq *devfreq, unsigned long *freq,
 		return result;
 	}
 
+	/* Prevent overflow */
+	if (stats.busy_time >= (1 << 24) || stats.total_time >= (1 << 24)) {
+		stats.busy_time >>= 7;
+		stats.total_time >>= 7;
+	}
+
 	*freq = stats.current_frequency;
+	*flag = 0;
+
+#ifdef CONFIG_ADRENO_IDLER
+	if (adreno_idler(stats, devfreq, freq)) {
+		/* adreno_idler has asked to bail out now */
+		return 0;
+	}
+#endif
+
 	priv->bin.total_time += stats.total_time;
 	priv->bin.busy_time += stats.busy_time;
 
diff --git a/drivers/mfd/wcd9xxx-core.c b/drivers/mfd/wcd9xxx-core.c
index bbffbc2..ffe3398 100644
--- a/drivers/mfd/wcd9xxx-core.c
+++ b/drivers/mfd/wcd9xxx-core.c
@@ -314,6 +314,25 @@ int wcd9xxx_reg_read(
 }
 EXPORT_SYMBOL(wcd9xxx_reg_read);
 
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+int wcd9xxx_reg_read_safe(
+	struct wcd9xxx_core_resource *core_res,
+	unsigned short reg)
+{
+	u8 val;
+	int ret;
+
+	struct wcd9xxx *wcd9xxx = (struct wcd9xxx *) core_res->parent;
+	ret = wcd9xxx_read(wcd9xxx, reg, 1, &val, false);
+
+	if (ret < 0)
+		return ret;
+	else
+		return val;
+}
+EXPORT_SYMBOL_GPL(wcd9xxx_reg_read_safe);
+#endif
+
 static int wcd9xxx_write(struct wcd9xxx *wcd9xxx, unsigned short reg,
 			int bytes, void *src, bool interface_reg)
 {
diff --git a/drivers/video/msm/mdss/mdss_dsi_panel.c b/drivers/video/msm/mdss/mdss_dsi_panel.c
index fbf3c48..22b753c 100644
--- a/drivers/video/msm/mdss/mdss_dsi_panel.c
+++ b/drivers/video/msm/mdss/mdss_dsi_panel.c
@@ -23,6 +23,10 @@
 #include <linux/err.h>
 #include <linux/string.h>
 
+#ifdef CONFIG_POWERSUSPEND
+#include <linux/powersuspend.h>
+#endif
+
 #include "mdss_dsi.h"
 #include "mdss_dba_utils.h"
 
@@ -684,6 +688,10 @@ static int mdss_dsi_panel_on(struct mdss_panel_data *pdata)
 		return -EINVAL;
 	}
 
+#ifdef CONFIG_POWERSUSPEND
+	set_power_suspend_state_panel_hook(POWER_SUSPEND_INACTIVE);
+#endif
+
 	pinfo = &pdata->panel_info;
 	ctrl = container_of(pdata, struct mdss_dsi_ctrl_pdata,
 				panel_data);
@@ -786,6 +794,10 @@ static int mdss_dsi_panel_off(struct mdss_panel_data *pdata)
 		mdss_dba_utils_hdcp_enable(pinfo->dba_data, false);
 	}
 
+#ifdef CONFIG_POWERSUSPEND
+	set_power_suspend_state_panel_hook(POWER_SUSPEND_ACTIVE);
+#endif
+
 end:
 	pr_debug("%s:-\n", __func__);
 	return 0;
diff --git a/drivers/video/msm/mdss/mdss_fb.c b/drivers/video/msm/mdss/mdss_fb.c
index b37fd1e..772fa33 100644
--- a/drivers/video/msm/mdss/mdss_fb.c
+++ b/drivers/video/msm/mdss/mdss_fb.c
@@ -867,6 +867,68 @@ static ssize_t mdss_fb_get_dfps_mode(struct device *dev,
 	return ret;
 }
 
+static int pcc_r = 32768, pcc_g = 32768, pcc_b = 32768;
+static ssize_t mdss_get_rgb(struct device *dev,
+				struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d %d %d\n", pcc_r, pcc_g, pcc_b);
+}
+
+/**
+ * simple color temperature interface using polynomial color correction
+ *
+ * input values are r/g/b adjustments from 0-32768 representing 0 -> 1
+ *
+ * example adjustment @ 3500K:
+ * 1.0000 / 0.5515 / 0.2520 = 32768 / 25828 / 17347
+ *
+ * reference chart:
+ * http://www.vendian.org/mncharity/dir3/blackbody/UnstableURLs/bbr_color.html
+ */
+static ssize_t mdss_set_rgb(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	uint32_t r = 0, g = 0, b = 0;
+	struct mdp_pcc_cfg_data pcc_cfg;
+	u32 copyback = 0;
+
+    if (count > 19)
+		return -EINVAL;
+
+	sscanf(buf, "%d %d %d", &r, &g, &b);
+
+	if (r < 0 || r > 32768)
+		return -EINVAL;
+	if (g < 0 || g > 32768)
+		return -EINVAL;
+	if (b < 0 || b > 32768)
+		return -EINVAL;
+
+	pr_info("%s: r=%d g=%d b=%d", __func__, r, g, b);
+
+	memset(&pcc_cfg, 0, sizeof(struct mdp_pcc_cfg_data));
+
+	pcc_cfg.block = MDP_LOGICAL_BLOCK_DISP_0;
+	if (r == 32768 && g == 32768 && b == 32768)
+		pcc_cfg.ops = MDP_PP_OPS_DISABLE;
+	else
+		pcc_cfg.ops = MDP_PP_OPS_ENABLE;
+	pcc_cfg.ops |= MDP_PP_OPS_WRITE;
+	pcc_cfg.r.r = r;
+	pcc_cfg.g.g = g;
+	pcc_cfg.b.b = b;
+
+	if (mdss_mdp_pcc_config(&pcc_cfg, &copyback) == 0) {
+		pcc_r = r;
+		pcc_g = g;
+		pcc_b = b;
+		return count;
+	}
+
+	return -EINVAL;
+}
+
 static DEVICE_ATTR(msm_fb_type, S_IRUGO, mdss_fb_get_type, NULL);
 static DEVICE_ATTR(msm_fb_split, S_IRUGO | S_IWUSR, mdss_fb_show_split,
 					mdss_fb_store_split);
@@ -883,6 +945,8 @@ static DEVICE_ATTR(msm_fb_panel_status, S_IRUGO | S_IWUSR,
 	mdss_fb_get_panel_status, mdss_fb_force_panel_dead);
 static DEVICE_ATTR(msm_fb_dfps_mode, S_IRUGO | S_IWUSR,
 	mdss_fb_get_dfps_mode, mdss_fb_change_dfps_mode);
+static DEVICE_ATTR(rgb, S_IRUGO | S_IWUSR | S_IWGRP,
+	mdss_get_rgb, mdss_set_rgb);
 static struct attribute *mdss_fb_attrs[] = {
 	&dev_attr_msm_fb_type.attr,
 	&dev_attr_msm_fb_split.attr,
@@ -894,6 +958,7 @@ static struct attribute *mdss_fb_attrs[] = {
 	&dev_attr_msm_fb_thermal_level.attr,
 	&dev_attr_msm_fb_panel_status.attr,
 	&dev_attr_msm_fb_dfps_mode.attr,
+	&dev_attr_rgb.attr,
 	NULL,
 };
 
diff --git a/include/linux/cpufreq.h b/include/linux/cpufreq.h
index 37f89bf..f17cde5 100644
--- a/include/linux/cpufreq.h
+++ b/include/linux/cpufreq.h
@@ -430,6 +430,9 @@ extern struct cpufreq_governor cpufreq_gov_ondemand;
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_CONSERVATIVE)
 extern struct cpufreq_governor cpufreq_gov_conservative;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_conservative)
+#elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_ZZMOOVE)
+extern struct cpufreq_governor cpufreq_gov_zzmoove;
+#define CPUFREQ_DEFAULT_GOVERNOR       (&cpufreq_gov_zzmoove)
 #elif defined(CONFIG_CPU_FREQ_DEFAULT_GOV_INTERACTIVE)
 extern struct cpufreq_governor cpufreq_gov_interactive;
 #define CPUFREQ_DEFAULT_GOVERNOR	(&cpufreq_gov_interactive)
diff --git a/include/linux/mfd/wcd9xxx/core-resource.h b/include/linux/mfd/wcd9xxx/core-resource.h
index fa32fd4..affc4b3 100644
--- a/include/linux/mfd/wcd9xxx/core-resource.h
+++ b/include/linux/mfd/wcd9xxx/core-resource.h
@@ -135,6 +135,8 @@ void wcd9xxx_disable_irq(struct wcd9xxx_core_resource *, int);
 void wcd9xxx_disable_irq_sync(struct wcd9xxx_core_resource *, int);
 int wcd9xxx_reg_read(struct wcd9xxx_core_resource *,
 					 unsigned short);
+int wcd9xxx_reg_read_safe(struct wcd9xxx_core_resource *,
+					 unsigned short);
 int wcd9xxx_reg_write(struct wcd9xxx_core_resource *,
 					  unsigned short, u8);
 int wcd9xxx_bulk_read(struct wcd9xxx_core_resource *,
diff --git a/include/linux/powersuspend.h b/include/linux/powersuspend.h
new file mode 100644
index 0000000..e63e404
--- /dev/null
+++ b/include/linux/powersuspend.h
@@ -0,0 +1,42 @@
+/* include/linux/powersuspend.h
+ *
+ * Copyright (C) 2007-2008 Google, Inc.
+ * Copyright (C) 2013 Paul Reioux 
+ *
+ * Modified by Jean-Pierre Rasquin <yank555.lu@gmail.com>
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _LINUX_POWERSUSPEND_H
+#define _LINUX_POWERSUSPEND_H
+
+#include <linux/list.h>
+
+#define POWER_SUSPEND_INACTIVE	0
+#define POWER_SUSPEND_ACTIVE	1
+
+#define POWER_SUSPEND_USERSPACE	1	// Use fauxclock as trigger
+#define POWER_SUSPEND_PANEL	2	// Use display panel state as hook
+
+struct power_suspend {
+	struct list_head link;
+	void (*suspend)(struct power_suspend *h);
+	void (*resume)(struct power_suspend *h);
+};
+
+void register_power_suspend(struct power_suspend *handler);
+void unregister_power_suspend(struct power_suspend *handler);
+
+void set_power_suspend_state_panel_hook(int new_state);
+
+#endif
+
diff --git a/include/linux/qdsp6v2/rtac.h b/include/linux/qdsp6v2/rtac.h
index 1b4bdcf1..73b0ab0 100644
--- a/include/linux/qdsp6v2/rtac.h
+++ b/include/linux/qdsp6v2/rtac.h
@@ -14,11 +14,16 @@
 #ifndef __RTAC_H__
 #define __RTAC_H__
 
+#include <sound/apr_audio-v2.h>
+
 /* Voice Modes */
 #define RTAC_CVP		0
 #define RTAC_CVS		1
 #define RTAC_VOICE_MODES	2
 
+#define RTAC_MAX_ACTIVE_DEVICES		4
+#define RTAC_MAX_ACTIVE_POPP		8
+
 enum {
 	ADM_RTAC_CAL,
 	ASM_RTAC_CAL,
@@ -45,6 +50,26 @@ struct rtac_cal_block_data {
 	struct rtac_cal_data		cal_data;
 };
 
+struct rtac_popp_data {
+	uint32_t	popp;
+	uint32_t	popp_topology;
+};
+
+struct rtac_adm_data {
+	uint32_t		topology_id;
+	uint32_t		afe_port;
+	uint32_t		copp;
+	uint32_t		num_of_popp;
+	uint32_t		app_type;
+	uint32_t		acdb_dev_id;
+	struct rtac_popp_data	popp[RTAC_MAX_ACTIVE_POPP];
+};
+
+struct rtac_adm {
+	uint32_t			num_of_dev;
+	struct rtac_adm_data		device[RTAC_MAX_ACTIVE_DEVICES];
+};
+
 void rtac_add_adm_device(u32 port_id, u32 copp_id, u32 path_id, u32 popp_id,
 			u32 app_type, u32 acdb_dev_id);
 void rtac_remove_adm_device(u32 port_id, u32 copp_id);
@@ -65,4 +90,5 @@ void rtac_copy_voice_payload_to_user(void *payload, u32 payload_size);
 int rtac_clear_mapping(uint32_t cal_type);
 bool rtac_make_afe_callback(uint32_t *payload, u32 payload_size);
 void rtac_set_afe_handle(void *handle);
+void get_rtac_adm_data(struct rtac_adm *adm_data);
 #endif
diff --git a/include/linux/quickwakeup.h b/include/linux/quickwakeup.h
new file mode 100644
index 0000000..000effa0
--- /dev/null
+++ b/include/linux/quickwakeup.h
@@ -0,0 +1,46 @@
+/* include/linux/quickwakeup.h
+ *
+ * Copyright (C) 2014 Motorola Mobility LLC.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _QUICKWAKEUP_H_
+#define _QUICKWAKEUP_H_
+
+#ifdef __KERNEL__
+
+struct quickwakeup_ops {
+	struct list_head list;
+	char *name;
+	int (*qw_execute)(void *data);
+	int (*qw_check)(void *data);
+	int execute;
+	void *data;  /* arbitrary data passed back to user */
+};
+
+#ifdef CONFIG_QUICK_WAKEUP
+
+int quickwakeup_register(struct quickwakeup_ops *ops);
+void quickwakeup_unregister(struct quickwakeup_ops *ops);
+bool quickwakeup_suspend_again(void);
+
+#else
+
+static inline int quickwakeup_register(struct quickwakeup_ops *ops) { return 0; };
+static inline void quickwakeup_unregister(struct quickwakeup_ops *ops) {};
+static inline bool quickwakeup_suspend_again(void) { return 0; };
+
+#endif /* CONFIG_QUICK_WAKEUP */
+
+#endif /* __KERNEL__ */
+
+#endif /* _QUICKWAKEUP_H_ */
diff --git a/include/sound/q6adm-v2.h b/include/sound/q6adm-v2.h
index d3a4da8..1f4c6ab 100644
--- a/include/sound/q6adm-v2.h
+++ b/include/sound/q6adm-v2.h
@@ -36,6 +36,7 @@ enum {
 	ADM_RTAC_APR_CAL,
 	ADM_DTS_EAGLE,
 	ADM_SRS_TRUMEDIA,
+	ADM_RTAC_AUDVOL_CAL,
 	ADM_MAX_CAL_TYPES
 };
 
diff --git a/include/sound/q6core.h b/include/sound/q6core.h
index 146fc1a..01f921a70 100644
--- a/include/sound/q6core.h
+++ b/include/sound/q6core.h
@@ -152,6 +152,77 @@ struct avcs_cmdrsp_get_license_validation_result {
 	/* Length in bytes of the result that follows this structure*/
 };
 
+/* Set Q6 topologies */
+/*
+ *	Registers custom topologies in the aDSP for
+ *	use in audio, voice, AFE and LSM.
+ */
+
+
+#define AVCS_CMD_SHARED_MEM_MAP_REGIONS                             0x00012924
+#define AVCS_CMDRSP_SHARED_MEM_MAP_REGIONS                          0x00012925
+#define AVCS_CMD_SHARED_MEM_UNMAP_REGIONS                           0x00012926
+
+
+#define AVCS_CMD_REGISTER_TOPOLOGIES                                0x00012923
+
+/* The payload for the AVCS_CMD_REGISTER_TOPOLOGIES command */
+struct avcs_cmd_register_topologies {
+	struct apr_hdr hdr;
+	uint32_t                  payload_addr_lsw;
+	/* Lower 32 bits of the topology buffer address. */
+
+	uint32_t                  payload_addr_msw;
+	/* Upper 32 bits of the topology buffer address. */
+
+	uint32_t                  mem_map_handle;
+	/* Unique identifier for an address.
+	 * -This memory map handle is returned by the aDSP through the
+	 * memory map command.
+	 * -NULL mem_map_handle is interpreted as in-band parameter
+	 * passing.
+	 * -Client has the flexibility to choose in-band or out-of-band.
+	 * -Out-of-band is recommended in this case.
+	 */
+
+	uint32_t                  payload_size;
+	/* Size in bytes of the valid data in the topology buffer. */
+} __packed;
+
+
+#define AVCS_CMD_DEREGISTER_TOPOLOGIES                                0x0001292a
+
+/* The payload for the AVCS_CMD_DEREGISTER_TOPOLOGIES command */
+struct avcs_cmd_deregister_topologies {
+	struct apr_hdr hdr;
+	uint32_t                  payload_addr_lsw;
+	/* Lower 32 bits of the topology buffer address. */
+
+	uint32_t                  payload_addr_msw;
+	/* Upper 32 bits of the topology buffer address. */
+
+	uint32_t                  mem_map_handle;
+	/* Unique identifier for an address.
+	 * -This memory map handle is returned by the aDSP through the
+	 * memory map command.
+	 * -NULL mem_map_handle is interpreted as in-band parameter
+	 * passing.
+	 * -Client has the flexibility to choose in-band or out-of-band.
+	 * -Out-of-band is recommended in this case.
+	 */
+
+	uint32_t                  payload_size;
+	/* Size in bytes of the valid data in the topology buffer. */
+
+	uint32_t                  mode;
+	/* 0: Deregister selected topologies
+	 * 1: Deregister all topologies
+	 */
+} __packed;
+
+#define AVCS_MODE_DEREGISTER_ALL_CUSTOM_TOPOLOGIES	1
+
+
 int32_t core_set_license(uint32_t key, uint32_t module_id);
 int32_t core_get_license_status(uint32_t module_id);
 
diff --git a/include/uapi/linux/msm_audio_calibration.h b/include/uapi/linux/msm_audio_calibration.h
index fdf2fd7..eb6c692 100644
--- a/include/uapi/linux/msm_audio_calibration.h
+++ b/include/uapi/linux/msm_audio_calibration.h
@@ -92,6 +92,9 @@ enum {
 	AUDIO_CORE_METAINFO_CAL_TYPE,
 	SRS_TRUMEDIA_CAL_TYPE,
 
+	CORE_CUSTOM_TOPOLOGIES_CAL_TYPE,
+	ADM_RTAC_AUDVOL_CAL_TYPE,
+
 	ULP_LSM_TOPOLOGY_ID_CAL_TYPE,
 	MAX_CAL_TYPES,
 };
diff --git a/kernel/power/Kconfig b/kernel/power/Kconfig
index e97d220..04e6007 100644
--- a/kernel/power/Kconfig
+++ b/kernel/power/Kconfig
@@ -26,6 +26,19 @@ config WAKELOCK
 	bool
 	default y
 
+config POWERSUSPEND
+	bool "Power suspend"
+	default y
+	---help---
+	  Call early suspend handlers when the user requested sleep state
+	  changes.
+
+config POWERSUSPEND_DEBUG
+	bool "Powersuspend driver debugging code"
+	depends on POWERSUSPEND
+	help
+	  Output debugging info in dmesg [POWERSUSPEND] (Yank555.lu)
+
 config HIBERNATE_CALLBACKS
 	bool
 
@@ -289,6 +302,14 @@ config SUSPEND_TIME
 	  keeps statistics on the time spent in suspend in
 	  /sys/kernel/debug/suspend_time
 
+config QUICK_WAKEUP
+	bool "Quick wakeup"
+	depends on SUSPEND
+	default y
+	---help---
+	  Allow kernel driver to do periodic jobs without resuming the full system
+	  This option can increase battery life on android powered smartphone.
+	  
 config DEDUCE_WAKEUP_REASONS
 	bool
 	default n
@@ -304,4 +325,3 @@ config PARTIALRESUME
 	  Partial resume will occur only if all wakeup sources have
 	  partial-resume handlers associated with them, and they all return
 	  true.
-
diff --git a/kernel/power/Makefile b/kernel/power/Makefile
index eea427f..57e65c6 100644
--- a/kernel/power/Makefile
+++ b/kernel/power/Makefile
@@ -9,10 +9,12 @@ obj-$(CONFIG_SUSPEND)		+= suspend.o
 obj-$(CONFIG_PM_TEST_SUSPEND)	+= suspend_test.o
 obj-$(CONFIG_HIBERNATION)	+= hibernate.o snapshot.o swap.o user.o \
 				   block_io.o
+obj-$(CONFIG_POWERSUSPEND)	+= powersuspend.o
 obj-$(CONFIG_PM_AUTOSLEEP)	+= autosleep.o
 obj-$(CONFIG_PM_WAKELOCKS)	+= wakelock.o
 obj-$(CONFIG_SUSPEND_TIME)	+= suspend_time.o
 
+obj-$(CONFIG_QUICK_WAKEUP)	+= quickwakeup.o
 obj-$(CONFIG_MAGIC_SYSRQ)	+= poweroff.o
 
 obj-$(CONFIG_SUSPEND)	+= wakeup_reason.o
diff --git a/kernel/power/powersuspend.c b/kernel/power/powersuspend.c
new file mode 100644
index 0000000..34453d6
--- /dev/null
+++ b/kernel/power/powersuspend.c
@@ -0,0 +1,318 @@
+/* kernel/power/powersuspend.c
+ *
+ * Copyright (C) 2005-2008 Google, Inc.
+ * Copyright (C) 2013 Paul Reioux
+ *
+ * Modified by Jean-Pierre Rasquin <yank555.lu@gmail.com>
+ *
+ *  v1.1 - make powersuspend not depend on a userspace initiator anymore,
+ *         but use a hook in autosleep instead.
+ *
+ *  v1.2 - make kernel / userspace mode switchable
+ *
+ *  v1.3 - add a hook in display panel driver as alternative kernel trigger
+ *
+ *  v1.4 - add a hybrid-kernel mode, accepting both kernel hooks (first wins)
+ *
+ *  v1.5 - fix hybrid-kernel mode cannot be set through sysfs
+ *
+ *  v1.6 - remove autosleep and hybrid modes (autosleep not working on shamu)
+ *
+ *  v1.7 - do only run state change if change actually requests a new state
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/powersuspend.h>
+#include <linux/module.h>
+#include <linux/mutex.h>
+#include <linux/workqueue.h>
+
+#define MAJOR_VERSION	1
+#define MINOR_VERSION	7
+
+struct workqueue_struct *suspend_work_queue;
+
+static DEFINE_MUTEX(power_suspend_lock);
+static LIST_HEAD(power_suspend_handlers);
+static void power_suspend(struct work_struct *work);
+static void power_resume(struct work_struct *work);
+static DECLARE_WORK(power_suspend_work, power_suspend);
+static DECLARE_WORK(power_resume_work, power_resume);
+static DEFINE_SPINLOCK(state_lock);
+
+static int state; // Yank555.lu : Current powersave state (screen on / off)
+static int mode;  // Yank555.lu : Current powersave mode  (userspace / panel)
+
+void register_power_suspend(struct power_suspend *handler)
+{
+	struct list_head *pos;
+
+	mutex_lock(&power_suspend_lock);
+	list_for_each(pos, &power_suspend_handlers) {
+		struct power_suspend *p;
+		p = list_entry(pos, struct power_suspend, link);
+	}
+	list_add_tail(&handler->link, pos);
+	mutex_unlock(&power_suspend_lock);
+}
+EXPORT_SYMBOL(register_power_suspend);
+
+void unregister_power_suspend(struct power_suspend *handler)
+{
+	mutex_lock(&power_suspend_lock);
+	list_del(&handler->link);
+	mutex_unlock(&power_suspend_lock);
+}
+EXPORT_SYMBOL(unregister_power_suspend);
+
+static void power_suspend(struct work_struct *work)
+{
+	struct power_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] entering suspend...\n");
+	#endif
+	mutex_lock(&power_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == POWER_SUSPEND_INACTIVE)
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort)
+		goto abort_suspend;
+
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] suspending...\n");
+	#endif
+	list_for_each_entry(pos, &power_suspend_handlers, link) {
+		if (pos->suspend != NULL) {
+			pos->suspend(pos);
+		}
+	}
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] suspend completed.\n");
+	#endif
+abort_suspend:
+	mutex_unlock(&power_suspend_lock);
+}
+
+static void power_resume(struct work_struct *work)
+{
+	struct power_suspend *pos;
+	unsigned long irqflags;
+	int abort = 0;
+
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] entering resume...\n");
+	#endif
+	mutex_lock(&power_suspend_lock);
+	spin_lock_irqsave(&state_lock, irqflags);
+	if (state == POWER_SUSPEND_ACTIVE)
+		abort = 1;
+	spin_unlock_irqrestore(&state_lock, irqflags);
+
+	if (abort)
+		goto abort_resume;
+
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] resuming...\n");
+	#endif
+	list_for_each_entry_reverse(pos, &power_suspend_handlers, link) {
+		if (pos->resume != NULL) {
+			pos->resume(pos);
+		}
+	}
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] resume completed.\n");
+	#endif
+abort_resume:
+	mutex_unlock(&power_suspend_lock);
+}
+
+void set_power_suspend_state(int new_state)
+{
+	unsigned long irqflags;
+
+	if (state != new_state) {
+		spin_lock_irqsave(&state_lock, irqflags);
+		if (state == POWER_SUSPEND_INACTIVE && new_state == POWER_SUSPEND_ACTIVE) {
+			#ifdef CONFIG_POWERSUSPEND_DEBUG
+			pr_info("[POWERSUSPEND] state activated.\n");
+			#endif
+			state = new_state;
+			queue_work(suspend_work_queue, &power_suspend_work);
+		} else if (state == POWER_SUSPEND_ACTIVE && new_state == POWER_SUSPEND_INACTIVE) {
+			#ifdef CONFIG_POWERSUSPEND_DEBUG
+			pr_info("[POWERSUSPEND] state deactivated.\n");
+			#endif
+			state = new_state;
+			queue_work(suspend_work_queue, &power_resume_work);
+		}
+		spin_unlock_irqrestore(&state_lock, irqflags);
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	} else {
+		pr_info("[POWERSUSPEND] state change requested, but unchanged ?! Ignored !\n");
+	#endif
+	}
+}
+
+void set_power_suspend_state_panel_hook(int new_state)
+{
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] panel resquests %s.\n", new_state == POWER_SUSPEND_ACTIVE ? "sleep" : "wakeup");
+	#endif
+	// Yank555.lu : Only allow panel hook changes in panel mode
+	if (mode == POWER_SUSPEND_PANEL)
+		set_power_suspend_state(new_state);
+}
+
+EXPORT_SYMBOL(set_power_suspend_state_panel_hook);
+
+// ------------------------------------------ sysfs interface ------------------------------------------
+
+static ssize_t power_suspend_state_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%u\n", state);
+}
+
+static ssize_t power_suspend_state_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int new_state = 0;
+
+	// Yank555.lu : Only allow sysfs changes from userspace mode
+	if (mode != POWER_SUSPEND_USERSPACE)
+		return -EINVAL;
+
+	sscanf(buf, "%d\n", &new_state);
+
+	#ifdef CONFIG_POWERSUSPEND_DEBUG
+	pr_info("[POWERSUSPEND] userspace resquests %s.\n", new_state == POWER_SUSPEND_ACTIVE ? "sleep" : "wakeup");
+	#endif
+	if(new_state == POWER_SUSPEND_ACTIVE || new_state == POWER_SUSPEND_INACTIVE)
+		set_power_suspend_state(new_state);
+
+	return count;
+}
+
+static struct kobj_attribute power_suspend_state_attribute =
+	__ATTR(power_suspend_state, 0666,
+		power_suspend_state_show,
+		power_suspend_state_store);
+
+static ssize_t power_suspend_mode_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%u\n", mode);
+}
+
+static ssize_t power_suspend_mode_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int data = 0;
+
+	sscanf(buf, "%d\n", &data);
+
+	switch (data) {
+		case POWER_SUSPEND_PANEL:
+		case POWER_SUSPEND_USERSPACE:	mode = data;
+						return count;
+		default:
+			return -EINVAL;
+	}
+	
+}
+
+static struct kobj_attribute power_suspend_mode_attribute =
+	__ATTR(power_suspend_mode, 0666,
+		power_suspend_mode_show,
+		power_suspend_mode_store);
+
+static ssize_t power_suspend_version_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "version: %d.%d\n", MAJOR_VERSION, MINOR_VERSION);
+}
+
+static struct kobj_attribute power_suspend_version_attribute =
+	__ATTR(power_suspend_version, 0444,
+		power_suspend_version_show,
+		NULL);
+
+static struct attribute *power_suspend_attrs[] =
+{
+	&power_suspend_state_attribute.attr,
+	&power_suspend_mode_attribute.attr,
+	&power_suspend_version_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group power_suspend_attr_group =
+{
+	.attrs = power_suspend_attrs,
+};
+
+static struct kobject *power_suspend_kobj;
+
+// ------------------ sysfs interface -----------------------
+static int __init power_suspend_init(void)
+{
+
+	int sysfs_result;
+
+        power_suspend_kobj = kobject_create_and_add("power_suspend",
+				kernel_kobj);
+        if (!power_suspend_kobj) {
+                pr_err("%s kobject create failed!\n", __FUNCTION__);
+                return -ENOMEM;
+        }
+
+        sysfs_result = sysfs_create_group(power_suspend_kobj,
+			&power_suspend_attr_group);
+
+        if (sysfs_result) {
+                pr_info("%s group create failed!\n", __FUNCTION__);
+                kobject_put(power_suspend_kobj);
+                return -ENOMEM;
+        }
+
+	suspend_work_queue = create_singlethread_workqueue("p-suspend");
+
+	if (suspend_work_queue == NULL) {
+		return -ENOMEM;
+	}
+
+//	mode = POWER_SUSPEND_USERSPACE;	// Yank555.lu : Default to userspace mode
+	mode = POWER_SUSPEND_PANEL;	// Yank555.lu : Default to display panel mode
+
+	return 0;
+}
+
+static void __exit power_suspend_exit(void)
+{
+	if (power_suspend_kobj != NULL)
+		kobject_put(power_suspend_kobj);
+
+	destroy_workqueue(suspend_work_queue);
+} 
+
+core_initcall(power_suspend_init);
+module_exit(power_suspend_exit);
+
+MODULE_AUTHOR("Paul Reioux <reioux@gmail.com> / Jean-Pierre Rasquin <yank555.lu@gmail.com>");
+MODULE_DESCRIPTION("power_suspend - A replacement kernel PM driver for"
+        "Android's deprecated early_suspend/late_resume PM driver!");
+MODULE_LICENSE("GPL v2");
+
diff --git a/kernel/power/quickwakeup.c b/kernel/power/quickwakeup.c
new file mode 100644
index 0000000..46f9dda7
--- /dev/null
+++ b/kernel/power/quickwakeup.c
@@ -0,0 +1,104 @@
+/* kernel/power/quickwakeup.c
+ *
+ * Copyright (C) 2014 Motorola Mobility LLC.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/list.h>
+#include <linux/mutex.h>
+#include <linux/quickwakeup.h>
+
+static LIST_HEAD(qw_head);
+static DEFINE_MUTEX(list_lock);
+
+int quickwakeup_register(struct quickwakeup_ops *ops)
+{
+	mutex_lock(&list_lock);
+	list_add(&ops->list, &qw_head);
+	mutex_unlock(&list_lock);
+
+	return 0;
+}
+
+void quickwakeup_unregister(struct quickwakeup_ops *ops)
+{
+	mutex_lock(&list_lock);
+	list_del(&ops->list);
+	mutex_unlock(&list_lock);
+}
+
+static int quickwakeup_check(void)
+{
+	int check = 0;
+	struct quickwakeup_ops *index;
+
+	mutex_lock(&list_lock);
+
+	list_for_each_entry(index, &qw_head, list) {
+		int ret = index->qw_check(index->data);
+		index->execute = ret;
+		check |= ret;
+		pr_debug("%s: %s votes for %s\n", __func__, index->name,
+			ret ? "execute" : "dont care");
+	}
+
+	mutex_unlock(&list_lock);
+
+	return check;
+}
+
+/* return 1 => suspend again
+   return 0 => continue wakeup
+ */
+static int quickwakeup_execute(void)
+{
+	int suspend_again = 0;
+	int final_vote = 1;
+	struct quickwakeup_ops *index;
+
+	mutex_lock(&list_lock);
+
+	list_for_each_entry(index, &qw_head, list) {
+		if (index->execute) {
+			int ret = index->qw_execute(index->data);
+			index->execute = 0;
+			final_vote &= ret;
+			suspend_again = final_vote;
+			pr_debug("%s: %s votes for %s\n", __func__, index->name,
+				ret ? "suspend again" : "wakeup");
+		}
+	}
+
+	mutex_unlock(&list_lock);
+
+	pr_debug("%s: %s\n", __func__,
+		suspend_again ? "suspend again" : "wakeup");
+
+	return suspend_again;
+}
+
+/* return 1 => suspend again
+   return 0 => continue wakeup
+ */
+bool quickwakeup_suspend_again(void)
+{
+	int ret = 0;
+
+	if (quickwakeup_check())
+		ret = quickwakeup_execute();
+
+	pr_debug("%s- returning %d %s\n", __func__, ret,
+		ret ? "suspend again" : "wakeup");
+
+	return ret;
+}
diff --git a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
index 81420eb..228b311c 100644
--- a/sound/soc/codecs/Kconfig
+++ b/sound/soc/codecs/Kconfig
@@ -581,3 +581,9 @@ config SND_SOC_MSM_HDMI_CODEC_RX
 	help
 	HDMI audio drivers should be built only if the platform
         supports hdmi panel.
+
+config SOUND_CONTROL_HAX_3_GPL
+	tristate "new wcd93xx sound control hax"
+	default y
+	help
+	  FauxSound WCD93xx chipset sound control hacks 3.0 for deeper hax
diff --git a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
index db148d0d..7144caf 100644
--- a/sound/soc/codecs/Makefile
+++ b/sound/soc/codecs/Makefile
@@ -288,3 +288,5 @@ obj-$(CONFIG_SND_SOC_TFA98XX)	+= snd-soc-tfa98xx.o
 # Amp
 obj-$(CONFIG_SND_SOC_MAX9877)	+= snd-soc-max9877.o
 obj-$(CONFIG_SND_SOC_TPA6130A2)	+= snd-soc-tpa6130a2.o
+
+obj-$(CONFIG_SOUND_CONTROL_HAX_3_GPL) += sound_control_3_gpl.o
diff --git a/sound/soc/codecs/sound_control_3_gpl.c b/sound/soc/codecs/sound_control_3_gpl.c
new file mode 100644
index 0000000..c372ef0
--- /dev/null
+++ b/sound/soc/codecs/sound_control_3_gpl.c
@@ -0,0 +1,544 @@
+/*
+ * Author: Paul Reioux aka Faux123 <reioux@gmail.com>
+ *
+ * WCD93xx sound control module
+ * Copyright 2013 Paul Reioux
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/module.h>
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/mfd/wcd9xxx/core.h>
+#include <linux/mfd/wcd9xxx/wcd9320_registers.h>
+
+#define SOUND_CONTROL_MAJOR_VERSION	3
+#define SOUND_CONTROL_MINOR_VERSION	6
+
+extern struct snd_soc_codec *fauxsound_codec_ptr;
+extern int wcd9xxx_hw_revision;
+
+static int snd_ctrl_locked = 0;
+static int snd_rec_ctrl_locked = 0;
+
+extern unsigned int taiko_read(struct snd_soc_codec *codec, unsigned int reg);
+extern int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
+		unsigned int value);
+
+#define REG_SZ	25
+static unsigned int cached_regs[] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+			    0, 0, 0, 0, 0 };
+
+static unsigned int *cache_select(unsigned int reg)
+{
+	unsigned int *out = NULL;
+
+        switch (reg) {
+                case TAIKO_A_RX_HPH_L_GAIN:
+			out = &cached_regs[0];
+			break;
+                case TAIKO_A_RX_HPH_R_GAIN:
+			out = &cached_regs[1];
+			break;
+                case TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL:
+			out = &cached_regs[4];
+			break;
+                case TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL:
+			out = &cached_regs[5];
+			break;
+                case TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL:
+			out = &cached_regs[6];
+			break;
+                case TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL:
+			out = &cached_regs[7];
+			break;
+                case TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL:
+			out = &cached_regs[8];
+			break;
+                case TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL:
+			out = &cached_regs[9];
+			break;
+                case TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL:
+			out = &cached_regs[10];
+			break;
+                case TAIKO_A_CDC_TX1_VOL_CTL_GAIN:
+			out = &cached_regs[11];
+			break;
+                case TAIKO_A_CDC_TX2_VOL_CTL_GAIN:
+			out = &cached_regs[12];
+			break;
+                case TAIKO_A_CDC_TX3_VOL_CTL_GAIN:
+			out = &cached_regs[13];
+			break;
+                case TAIKO_A_CDC_TX4_VOL_CTL_GAIN:
+			out = &cached_regs[14];
+			break;
+                case TAIKO_A_CDC_TX5_VOL_CTL_GAIN:
+			out = &cached_regs[15];
+			break;
+                case TAIKO_A_CDC_TX6_VOL_CTL_GAIN:
+			out = &cached_regs[16];
+			break;
+                case TAIKO_A_CDC_TX7_VOL_CTL_GAIN:
+			out = &cached_regs[17];
+			break;
+                case TAIKO_A_CDC_TX8_VOL_CTL_GAIN:
+			out = &cached_regs[18];
+			break;
+                case TAIKO_A_CDC_TX9_VOL_CTL_GAIN:
+			out = &cached_regs[19];
+			break;
+                case TAIKO_A_CDC_TX10_VOL_CTL_GAIN:
+			out = &cached_regs[20];
+			break;
+		case TAIKO_A_RX_LINE_1_GAIN:
+			out = &cached_regs[21];
+			break;
+		case TAIKO_A_RX_LINE_2_GAIN:
+			out = &cached_regs[22];
+			break;
+		case TAIKO_A_RX_LINE_3_GAIN:
+			out = &cached_regs[23];
+			break;
+		case TAIKO_A_RX_LINE_4_GAIN:
+			out = &cached_regs[24];
+			break;
+        }
+	return out;
+}
+
+void snd_hax_cache_write(unsigned int reg, unsigned int value)
+{
+	unsigned int *tmp = cache_select(reg);
+
+	if (tmp != NULL)
+		*tmp = value;
+}
+EXPORT_SYMBOL(snd_hax_cache_write);
+
+unsigned int snd_hax_cache_read(unsigned int reg)
+{
+	if (cache_select(reg) != NULL)
+		return *cache_select(reg);
+	else
+		return -1;
+}
+EXPORT_SYMBOL(snd_hax_cache_read);
+
+int snd_hax_reg_access(unsigned int reg)
+{
+	int ret = 1;
+
+	switch (reg) {
+		case TAIKO_A_RX_HPH_L_GAIN:
+		case TAIKO_A_RX_HPH_R_GAIN:
+		case TAIKO_A_RX_HPH_L_STATUS:
+		case TAIKO_A_RX_HPH_R_STATUS:
+			if (snd_ctrl_locked > 1)
+				ret = 0;
+			break;
+		case TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX3_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX4_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX5_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX6_VOL_CTL_B2_CTL:
+		case TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL:
+		case TAIKO_A_RX_LINE_1_GAIN:
+		case TAIKO_A_RX_LINE_2_GAIN:
+		case TAIKO_A_RX_LINE_3_GAIN:
+		case TAIKO_A_RX_LINE_4_GAIN:
+			if (snd_ctrl_locked > 0)
+				ret = 0;
+			break;
+		case TAIKO_A_CDC_TX1_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX2_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX3_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX4_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX5_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX6_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX7_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX8_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX9_VOL_CTL_GAIN:
+		case TAIKO_A_CDC_TX10_VOL_CTL_GAIN:
+			if (snd_rec_ctrl_locked > 0)
+				ret = 0;
+			break;
+		default:
+			break;
+	}
+	return ret;
+}
+EXPORT_SYMBOL(snd_hax_reg_access);
+
+static bool calc_checksum(unsigned int a, unsigned int b, unsigned int c)
+{
+	unsigned char chksum = 0;
+
+	chksum = ~((a & 0xff) + (b & 0xff));
+
+	if (chksum == (c & 0xff)) {
+		return true;
+	} else {
+		return false;
+	}
+}
+
+static ssize_t cam_mic_gain_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%u\n",
+		taiko_read(fauxsound_codec_ptr,
+			TAIKO_A_CDC_TX3_VOL_CTL_GAIN));
+
+}
+
+static ssize_t cam_mic_gain_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int lval, chksum;
+
+	sscanf(buf, "%u %u", &lval, &chksum);
+
+	if (calc_checksum(lval, 0, chksum)) {
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_TX3_VOL_CTL_GAIN, lval);
+	}
+	return count;
+}
+
+static ssize_t mic_gain_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u\n",
+		taiko_read(fauxsound_codec_ptr,
+			TAIKO_A_CDC_TX2_VOL_CTL_GAIN));
+}
+
+static ssize_t mic_gain_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int lval, chksum;
+
+	sscanf(buf, "%u %u", &lval, &chksum);
+
+	if (calc_checksum(lval, 0, chksum)) {
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_TX2_VOL_CTL_GAIN, lval);
+	}
+	return count;
+
+}
+
+static ssize_t speaker_gain_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%u %u\n",
+			taiko_read(fauxsound_codec_ptr,
+				TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL),
+			taiko_read(fauxsound_codec_ptr,
+				TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL));
+
+}
+
+static ssize_t speaker_gain_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int lval, rval, chksum;
+
+	sscanf(buf, "%u %u %u", &lval, &rval, &chksum);
+
+	if (calc_checksum(lval, rval, chksum)) {
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL, lval);
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_RX7_VOL_CTL_B2_CTL, rval);
+	}
+	return count;
+}
+
+static ssize_t headphone_gain_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u %u\n",
+			taiko_read(fauxsound_codec_ptr,
+				TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL),
+			taiko_read(fauxsound_codec_ptr,
+				TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL));
+}
+
+static ssize_t headphone_gain_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int lval, rval, chksum;
+
+	sscanf(buf, "%u %u %u", &lval, &rval, &chksum);
+
+	if (calc_checksum(lval, rval, chksum)) {
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_RX1_VOL_CTL_B2_CTL, lval);
+		taiko_write(fauxsound_codec_ptr,
+			TAIKO_A_CDC_RX2_VOL_CTL_B2_CTL, rval);
+	}
+	return count;
+}
+
+static ssize_t headphone_pa_gain_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%u %u\n",
+		taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_L_GAIN),
+		taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_R_GAIN));
+}
+
+static ssize_t headphone_pa_gain_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int lval, rval, chksum;
+	unsigned int gain, status;
+	unsigned int out;
+
+	sscanf(buf, "%u %u %u", &lval, &rval, &chksum);
+
+	if (calc_checksum(lval, rval, chksum)) {
+	gain = taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_L_GAIN);
+	out = (gain & 0xf0) | lval;
+	taiko_write(fauxsound_codec_ptr, TAIKO_A_RX_HPH_L_GAIN, out);
+
+	status = taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_L_STATUS);
+	out = (status & 0x0f) | (lval << 4);
+	taiko_write(fauxsound_codec_ptr, TAIKO_A_RX_HPH_L_STATUS, out);
+
+	gain = taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_R_GAIN);
+	out = (gain & 0xf0) | rval;
+	taiko_write(fauxsound_codec_ptr, TAIKO_A_RX_HPH_R_GAIN, out);
+
+	status = taiko_read(fauxsound_codec_ptr, TAIKO_A_RX_HPH_R_STATUS);
+	out = (status & 0x0f) | (rval << 4);
+	taiko_write(fauxsound_codec_ptr, TAIKO_A_RX_HPH_R_STATUS, out);
+	}
+	return count;
+}
+
+static unsigned int selected_reg = 0xdeadbeef;
+
+static ssize_t sound_reg_select_store(struct kobject *kobj,
+                struct kobj_attribute *attr, const char *buf, size_t count)
+{
+        sscanf(buf, "%u", &selected_reg);
+
+	return count;
+}
+
+static ssize_t sound_reg_read_show(struct kobject *kobj,
+                struct kobj_attribute *attr, char *buf)
+{
+	if (selected_reg == 0xdeadbeef)
+		return -1;
+	else
+		return sprintf(buf, "%u\n",
+			taiko_read(fauxsound_codec_ptr, selected_reg));
+}
+
+static ssize_t sound_reg_write_store(struct kobject *kobj,
+                struct kobj_attribute *attr, const char *buf, size_t count)
+{
+        unsigned int out, chksum;
+
+	sscanf(buf, "%u %u", &out, &chksum);
+	if (calc_checksum(out, 0, chksum)) {
+		if (selected_reg != 0xdeadbeef)
+			taiko_write(fauxsound_codec_ptr, selected_reg, out);
+	}
+	return count;
+}
+
+static ssize_t sound_control_hw_revision_show (struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "hw_revision: %i\n", wcd9xxx_hw_revision);
+}
+
+static ssize_t sound_control_version_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "version: %u.%u\n",
+			SOUND_CONTROL_MAJOR_VERSION,
+			SOUND_CONTROL_MINOR_VERSION);
+}
+
+static ssize_t sound_control_locked_store(struct kobject *kobj,
+                struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int inp;
+
+	sscanf(buf, "%d", &inp);
+
+	snd_ctrl_locked = inp;
+
+	return count;
+}
+
+static ssize_t sound_control_locked_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%d\n", snd_ctrl_locked);
+}
+
+static ssize_t sound_control_rec_locked_store(struct kobject *kobj,
+                struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int inp;
+
+	sscanf(buf, "%d", &inp);
+
+	snd_rec_ctrl_locked = inp;
+
+	return count;
+}
+
+static ssize_t sound_control_rec_locked_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+        return sprintf(buf, "%d\n", snd_rec_ctrl_locked);
+}
+
+static struct kobj_attribute sound_reg_sel_attribute =
+	__ATTR(sound_reg_sel,
+		0222,
+		NULL,
+		sound_reg_select_store);
+
+static struct kobj_attribute sound_reg_read_attribute =
+	__ATTR(sound_reg_read,
+		0444,
+		sound_reg_read_show,
+		NULL);
+
+static struct kobj_attribute sound_reg_write_attribute =
+	__ATTR(sound_reg_write,
+		0222,
+		NULL,
+		sound_reg_write_store);
+
+static struct kobj_attribute cam_mic_gain_attribute =
+	__ATTR(gpl_cam_mic_gain,
+		0666,
+		cam_mic_gain_show,
+		cam_mic_gain_store);
+
+static struct kobj_attribute mic_gain_attribute =
+	__ATTR(gpl_mic_gain,
+		0666,
+		mic_gain_show,
+		mic_gain_store);
+
+static struct kobj_attribute speaker_gain_attribute =
+	__ATTR(gpl_speaker_gain,
+		0666,
+		speaker_gain_show,
+		speaker_gain_store);
+
+static struct kobj_attribute headphone_gain_attribute =
+	__ATTR(gpl_headphone_gain,
+		0666,
+		headphone_gain_show,
+		headphone_gain_store);
+
+static struct kobj_attribute headphone_pa_gain_attribute =
+	__ATTR(gpl_headphone_pa_gain,
+		0666,
+		headphone_pa_gain_show,
+		headphone_pa_gain_store);
+
+static struct kobj_attribute sound_control_locked_attribute =
+	__ATTR(gpl_sound_control_locked,
+		0666,
+		sound_control_locked_show,
+		sound_control_locked_store);
+
+static struct kobj_attribute sound_control_rec_locked_attribute =
+	__ATTR(gpl_sound_control_rec_locked,
+		0666,
+		sound_control_rec_locked_show,
+		sound_control_rec_locked_store);
+
+static struct kobj_attribute sound_control_version_attribute =
+	__ATTR(gpl_sound_control_version,
+		0444,
+		sound_control_version_show, NULL);
+
+static struct kobj_attribute sound_hw_revision_attribute =
+	__ATTR(gpl_sound_control_hw_revision,
+		0444,
+		sound_control_hw_revision_show, NULL);
+
+static struct attribute *sound_control_attrs[] =
+	{
+		&cam_mic_gain_attribute.attr,
+		&mic_gain_attribute.attr,
+		&speaker_gain_attribute.attr,
+		&headphone_gain_attribute.attr,
+		&headphone_pa_gain_attribute.attr,
+		&sound_control_locked_attribute.attr,
+		&sound_control_rec_locked_attribute.attr,
+		&sound_reg_sel_attribute.attr,
+		&sound_reg_read_attribute.attr,
+		&sound_reg_write_attribute.attr,
+		&sound_hw_revision_attribute.attr,
+		&sound_control_version_attribute.attr,
+		NULL,
+	};
+
+static struct attribute_group sound_control_attr_group =
+	{
+		.attrs = sound_control_attrs,
+	};
+
+static struct kobject *sound_control_kobj;
+
+static int sound_control_init(void)
+{
+	int sysfs_result;
+
+	sound_control_kobj =
+		kobject_create_and_add("sound_control_3", kernel_kobj);
+
+	if (!sound_control_kobj) {
+		pr_err("%s sound_control_kobj create failed!\n",
+			__FUNCTION__);
+		return -ENOMEM;
+        }
+
+	sysfs_result = sysfs_create_group(sound_control_kobj,
+			&sound_control_attr_group);
+
+	if (sysfs_result) {
+		pr_info("%s sysfs create failed!\n", __FUNCTION__);
+		kobject_put(sound_control_kobj);
+	}
+	return sysfs_result;
+}
+
+static void sound_control_exit(void)
+{
+	if (sound_control_kobj != NULL)
+		kobject_put(sound_control_kobj);
+}
+
+module_init(sound_control_init);
+module_exit(sound_control_exit);
+MODULE_LICENSE("GPL and additional rights");
+MODULE_AUTHOR("Paul Reioux <reioux@gmail.com>");
+MODULE_DESCRIPTION("Sound Control Module 3.x");
+
diff --git a/sound/soc/codecs/wcd9320.c b/sound/soc/codecs/wcd9320.c
index 6b4ebdf..ac31f6d 100644
--- a/sound/soc/codecs/wcd9320.c
+++ b/sound/soc/codecs/wcd9320.c
@@ -4628,27 +4628,16 @@ static int taiko_volatile(struct snd_soc_codec *ssc, unsigned int reg)
 	return 0;
 }
 
-static int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
-	unsigned int value)
-{
-	int ret;
-	struct wcd9xxx *wcd9xxx = codec->control_data;
-
-	if (reg == SND_SOC_NOPM)
-		return 0;
-
-	BUG_ON(reg > TAIKO_MAX_REGISTER);
-
-	if (!taiko_volatile(codec, reg)) {
-		ret = snd_soc_cache_write(codec, reg, value);
-		if (ret != 0)
-			dev_err(codec->dev, "Cache write to %x failed: %d\n",
-				reg, ret);
-	}
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+extern int snd_hax_reg_access(unsigned int);
+extern unsigned int snd_hax_cache_read(unsigned int);
+extern void snd_hax_cache_write(unsigned int, unsigned int);
+#endif
 
-	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
-}
-static unsigned int taiko_read(struct snd_soc_codec *codec,
+#ifndef CONFIG_SOUND_CONTROL_HAX_3_GPL
+static
+#endif
+unsigned int taiko_read(struct snd_soc_codec *codec,
 				unsigned int reg)
 {
 	unsigned int val;
@@ -4674,6 +4663,50 @@ static unsigned int taiko_read(struct snd_soc_codec *codec,
 	val = wcd9xxx_reg_read(&wcd9xxx->core_res, reg);
 	return val;
 }
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+EXPORT_SYMBOL(taiko_read);
+#endif
+
+#ifndef CONFIG_SOUND_CONTROL_HAX_3_GPL
+static
+#endif
+int taiko_write(struct snd_soc_codec *codec, unsigned int reg,
+	unsigned int value)
+{
+	int ret;
+	struct wcd9xxx *wcd9xxx = codec->control_data;
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+	unsigned int val;
+#endif
+
+	if (reg == SND_SOC_NOPM)
+		return 0;
+
+	BUG_ON(reg > TAIKO_MAX_REGISTER);
+
+	if (!taiko_volatile(codec, reg)) {
+		ret = snd_soc_cache_write(codec, reg, value);
+		if (ret != 0)
+			dev_err(codec->dev, "Cache write to %x failed: %d\n",
+				reg, ret);
+	}
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+	if (!snd_hax_reg_access(reg)) {
+		if (!((val = snd_hax_cache_read(reg)) != -1)) {
+			val = wcd9xxx_reg_read_safe(&wcd9xxx->core_res, reg);
+		}
+	} else {
+		snd_hax_cache_write(reg, value);
+		val = value;
+	}
+	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, val);
+#else
+	return wcd9xxx_reg_write(&wcd9xxx->core_res, reg, value);
+#endif
+}
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+EXPORT_SYMBOL(taiko_write);
+#endif
 
 static int taiko_startup(struct snd_pcm_substream *substream,
 		struct snd_soc_dai *dai)
@@ -7418,6 +7451,13 @@ static struct regulator *taiko_codec_find_regulator(struct snd_soc_codec *codec,
 	return NULL;
 }
 
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+struct snd_soc_codec *fauxsound_codec_ptr;
+EXPORT_SYMBOL(fauxsound_codec_ptr);
+int wcd9xxx_hw_revision;
+EXPORT_SYMBOL(wcd9xxx_hw_revision);
+#endif
+
 static int taiko_codec_probe(struct snd_soc_codec *codec)
 {
 	struct wcd9xxx *control;
@@ -7431,9 +7471,20 @@ static int taiko_codec_probe(struct snd_soc_codec *codec)
 	struct wcd9xxx *core = dev_get_drvdata(codec->dev->parent);
 	struct wcd9xxx_core_resource *core_res;
 
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+	pr_info("taiko codec probe...\n");
+	fauxsound_codec_ptr = codec;
+#endif
+
 	codec->control_data = dev_get_drvdata(codec->dev->parent);
 	control = codec->control_data;
 
+#ifdef CONFIG_SOUND_CONTROL_HAX_3_GPL
+	if (TAIKO_IS_1_0(control->version))
+		wcd9xxx_hw_revision = 1;
+	else
+		wcd9xxx_hw_revision = 2;
+#endif
 	wcd9xxx_ssr_register(control, taiko_device_down,
 			     taiko_post_reset_cb, (void *)codec);
 
diff --git a/sound/soc/msm/msm8974.c b/sound/soc/msm/msm8974.c
index 04cb228..75b2bc7 100644
--- a/sound/soc/msm/msm8974.c
+++ b/sound/soc/msm/msm8974.c
@@ -1400,7 +1400,7 @@ static int msm8974_configure_quat_mi2s_gpio(void)
 		ret = gpio_request(quat_mi2s_gpio[i].gpio_no,
 				quat_mi2s_gpio[i].gpio_name);
 
-		pr_info("%s: gpio = %d, gpio name = %s, rtn = %d\n", __func__,
+		pr_debug("%s: gpio = %d, gpio name = %s, rtn = %d\n", __func__,
 		quat_mi2s_gpio[i].gpio_no, quat_mi2s_gpio[i].gpio_name, ret);
 		gpio_set_value(quat_mi2s_gpio[i].gpio_no, 1);
 
@@ -1433,10 +1433,10 @@ static int msm8974_mi2s_startup(struct snd_pcm_substream *substream)
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
 
-	pr_info("%s: dai name %s %p\n", __func__, cpu_dai->name, cpu_dai->dev);
+	pr_debug("%s: dai name %s %p\n", __func__, cpu_dai->name, cpu_dai->dev);
 
 	if (atomic_inc_return(&quat_mi2s_clk.mi2s_rsc_ref) == 1) {
-		pr_info("%s: acquire mi2s resources\n", __func__);
+		pr_debug("%s: acquire mi2s resources\n", __func__);
 		msm8974_configure_quat_mi2s_gpio();
 		ret = afe_set_lpass_clock(AFE_PORT_ID_QUATERNARY_MI2S_RX,
 						&lpass_mi2s_enable);
@@ -1463,7 +1463,7 @@ static void msm8974_mi2s_shutdown(struct snd_pcm_substream *substream)
 	int ret = 0;
 
 	if (atomic_dec_return(&quat_mi2s_clk.mi2s_rsc_ref) == 0) {
-		pr_info("%s: free mi2s resources\n", __func__);
+		pr_debug("%s: free mi2s resources\n", __func__);
 		ret = afe_set_lpass_clock(AFE_PORT_ID_QUATERNARY_MI2S_RX,
 						&lpass_mi2s_disable);
 		if (ret < 0)
diff --git a/sound/soc/msm/qdsp6v2/audio_cal_utils.c b/sound/soc/msm/qdsp6v2/audio_cal_utils.c
index ecb1ee5..78fb9a7 100644
--- a/sound/soc/msm/qdsp6v2/audio_cal_utils.c
+++ b/sound/soc/msm/qdsp6v2/audio_cal_utils.c
@@ -56,12 +56,14 @@ size_t get_cal_info_size(int32_t cal_type)
 		size = sizeof(struct audio_cal_info_adm_top);
 		break;
 	case ADM_CUST_TOPOLOGY_CAL_TYPE:
+	case CORE_CUSTOM_TOPOLOGIES_CAL_TYPE:
 		size = 0;
 		break;
 	case ADM_AUDPROC_CAL_TYPE:
 		size = sizeof(struct audio_cal_info_audproc);
 		break;
 	case ADM_AUDVOL_CAL_TYPE:
+	case ADM_RTAC_AUDVOL_CAL_TYPE:
 		size = sizeof(struct audio_cal_info_audvol);
 		break;
 	case ASM_TOPOLOGY_CAL_TYPE:
@@ -183,12 +185,14 @@ size_t get_user_cal_type_size(int32_t cal_type)
 		size = sizeof(struct audio_cal_type_adm_top);
 		break;
 	case ADM_CUST_TOPOLOGY_CAL_TYPE:
+	case CORE_CUSTOM_TOPOLOGIES_CAL_TYPE:
 		size = sizeof(struct audio_cal_type_basic);
 		break;
 	case ADM_AUDPROC_CAL_TYPE:
 		size = sizeof(struct audio_cal_type_audproc);
 		break;
 	case ADM_AUDVOL_CAL_TYPE:
+	case ADM_RTAC_AUDVOL_CAL_TYPE:
 		size = sizeof(struct audio_cal_type_audvol);
 		break;
 	case ASM_TOPOLOGY_CAL_TYPE:
diff --git a/sound/soc/msm/qdsp6v2/q6adm.c b/sound/soc/msm/qdsp6v2/q6adm.c
index 51e2603..31ebb55 100644
--- a/sound/soc/msm/qdsp6v2/q6adm.c
+++ b/sound/soc/msm/qdsp6v2/q6adm.c
@@ -1726,7 +1726,7 @@ static int adm_memory_unmap_regions(void)
 	return ret;
 }
 
-static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
+static int remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 {
 	int ret = 0;
 
@@ -1749,7 +1749,7 @@ static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 			mem_map_handles[cal_index]);
 	}
 done:
-	return;
+	return ret;
 }
 
 static void send_adm_custom_topology(void)
@@ -1773,7 +1773,12 @@ static void send_adm_custom_topology(void)
 
 	pr_debug("%s: Sending cal_index %d\n", __func__, cal_index);
 
-	remap_cal_data(cal_block, cal_index);
+	result = remap_cal_data(cal_block, cal_index);
+	if (result) {
+		pr_err("%s: Remap_cal_data failed for cal %d!\n",
+			__func__, cal_index);
+		goto unlock;
+	}
 	atomic_set(&this_adm.mem_map_index, cal_index);
 	atomic_set(&this_adm.mem_map_handles[cal_index],
 		cal_block->map_data.q6map_handle);
@@ -2035,6 +2040,28 @@ static struct cal_block_data *adm_find_cal(int cal_index, int path,
 	return adm_find_cal_by_app_type(cal_index, path, app_type);
 }
 
+static int adm_remap_and_send_cal_block(int cal_index, int port_id,
+	int copp_idx, struct cal_block_data *cal_block, int perf_mode,
+	int app_type, int acdb_id, int sample_rate)
+{
+	int ret = 0;
+
+	pr_debug("%s: Sending cal_index cal %d\n", __func__, cal_index);
+	ret = remap_cal_data(cal_block, cal_index);
+	if (ret) {
+		pr_err("%s: Remap_cal_data failed for cal %d!\n",
+			__func__, cal_index);
+		goto done;
+	}
+	ret = send_adm_cal_block(port_id, copp_idx, cal_block, perf_mode,
+				app_type, acdb_id, sample_rate);
+	if (ret < 0)
+		pr_debug("%s: No cal sent for cal_index %d, port_id = 0x%x! ret %d sample_rate %d\n",
+			__func__, cal_index, port_id, ret, sample_rate);
+done:
+	return ret;
+}
+
 static void send_adm_cal_type(int cal_index, int path, int port_id,
 			      int copp_idx, int perf_mode, int app_type,
 			      int acdb_id, int sample_rate)
@@ -2056,13 +2083,8 @@ static void send_adm_cal_type(int cal_index, int path, int port_id,
 	if (cal_block == NULL)
 		goto unlock;
 
-	pr_debug("%s: Sending cal_index cal %d\n", __func__, cal_index);
-	remap_cal_data(cal_block, cal_index);
-	ret = send_adm_cal_block(port_id, copp_idx, cal_block, perf_mode,
-				app_type, acdb_id, sample_rate);
-	if (ret < 0)
-		pr_debug("%s: No cal sent for cal_index %d, port_id = 0x%x! ret %d sample_rate %d\n",
-			__func__, cal_index, port_id, ret, sample_rate);
+	ret = adm_remap_and_send_cal_block(cal_index, port_id, copp_idx,
+		cal_block, perf_mode, app_type, acdb_id, sample_rate);
 unlock:
 	mutex_unlock(&this_adm.cal_data[cal_index]->lock);
 done:
@@ -2747,6 +2769,79 @@ int adm_close(int port_id, int perf_mode, int copp_idx)
 	return 0;
 }
 
+int send_rtac_audvol_cal(void)
+{
+	int ret = 0;
+	int ret2 = 0;
+	int i = 0;
+	int copp_idx, port_idx, acdb_id, app_id, path;
+	struct cal_block_data *cal_block = NULL;
+	struct audio_cal_info_audvol *audvol_cal_info = NULL;
+	struct rtac_adm rtac_adm_data;
+
+	mutex_lock(&this_adm.cal_data[ADM_RTAC_AUDVOL_CAL]->lock);
+
+	cal_block = cal_utils_get_only_cal_block(
+		this_adm.cal_data[ADM_RTAC_AUDVOL_CAL]);
+	if (cal_block == NULL) {
+		pr_err("%s: can't find cal block!\n", __func__);
+		goto unlock;
+	}
+
+	audvol_cal_info = cal_block->cal_info;
+	if (audvol_cal_info == NULL) {
+		pr_err("%s: audvol_cal_info is NULL!\n", __func__);
+		goto unlock;
+	}
+
+	get_rtac_adm_data(&rtac_adm_data);
+	for (; i < rtac_adm_data.num_of_dev; i++) {
+
+		acdb_id = rtac_adm_data.device[i].acdb_dev_id;
+		if (acdb_id == 0)
+			acdb_id = audvol_cal_info->acdb_id;
+
+		app_id = rtac_adm_data.device[i].app_type;
+		if (app_id == 0)
+			app_id = audvol_cal_info->app_type;
+
+		path = afe_get_port_type(rtac_adm_data.device[i].afe_port);
+		if ((acdb_id == audvol_cal_info->acdb_id) &&
+			(app_id == audvol_cal_info->app_type) &&
+			(path == audvol_cal_info->path)) {
+
+			if (adm_get_indexes_from_copp_id(rtac_adm_data.
+				device[i].copp, &copp_idx, &port_idx) != 0) {
+				pr_debug("%s: Copp Id %d is not active\n",
+					__func__,
+					rtac_adm_data.device[i].copp);
+				continue;
+			}
+
+			ret2 = adm_remap_and_send_cal_block(ADM_RTAC_AUDVOL_CAL,
+				rtac_adm_data.device[i].afe_port,
+				copp_idx, cal_block,
+				atomic_read(&this_adm.copp.
+				mode[port_idx][copp_idx]),
+				audvol_cal_info->app_type,
+				audvol_cal_info->acdb_id,
+				atomic_read(&this_adm.copp.
+				rate[port_idx][copp_idx]));
+			if (ret2 < 0) {
+				pr_debug("%s: remap and send failed for copp Id %d, acdb id %d, app type %d, path %d\n",
+					__func__, rtac_adm_data.device[i].copp,
+					audvol_cal_info->acdb_id,
+					audvol_cal_info->app_type,
+					audvol_cal_info->path);
+				ret = ret2;
+			}
+		}
+	}
+unlock:
+	mutex_unlock(&this_adm.cal_data[ADM_RTAC_AUDVOL_CAL]->lock);
+	return ret;
+}
+
 int adm_map_rtac_block(struct rtac_cal_block_data *cal_block)
 {
 	int	result = 0;
@@ -2856,6 +2951,9 @@ static int get_cal_type_index(int32_t cal_type)
 	case ADM_RTAC_APR_CAL_TYPE:
 		ret = ADM_RTAC_APR_CAL;
 		break;
+	case ADM_RTAC_AUDVOL_CAL_TYPE:
+		ret = ADM_RTAC_AUDVOL_CAL;
+		break;
 	default:
 		pr_err("%s: invalid cal type %d!\n", __func__, cal_type);
 	}
@@ -2944,6 +3042,8 @@ static int adm_set_cal(int32_t cal_type, size_t data_size, void *data)
 		mutex_lock(&this_adm.cal_data[ADM_CUSTOM_TOP_CAL]->lock);
 		this_adm.set_custom_topology = 1;
 		mutex_unlock(&this_adm.cal_data[ADM_CUSTOM_TOP_CAL]->lock);
+	} else if (cal_index == ADM_RTAC_AUDVOL_CAL) {
+		send_rtac_audvol_cal();
 	}
 done:
 	return ret;
@@ -3057,7 +3157,13 @@ static int adm_init_cal_data(void)
 
 		{{SRS_TRUMEDIA_CAL_TYPE,
 		{NULL, NULL, NULL, NULL, NULL, NULL} },
-		{NULL, NULL, cal_utils_match_buf_num} }
+		{NULL, NULL, cal_utils_match_buf_num} },
+
+		{{ADM_RTAC_AUDVOL_CAL_TYPE,
+		{adm_alloc_cal, adm_dealloc_cal, NULL,
+		adm_set_cal, NULL, NULL} },
+		{adm_map_cal_data, adm_unmap_cal_data,
+		cal_utils_match_buf_num} },
 	};
 	pr_debug("%s:\n", __func__);
 
diff --git a/sound/soc/msm/qdsp6v2/q6afe.c b/sound/soc/msm/qdsp6v2/q6afe.c
index a487fed..87a7e31 100644
--- a/sound/soc/msm/qdsp6v2/q6afe.c
+++ b/sound/soc/msm/qdsp6v2/q6afe.c
@@ -127,7 +127,7 @@ bool afe_close_done[2] = {true, true};
 
 static int afe_get_cal_hw_delay(int32_t path,
 				struct audio_cal_hw_delay_entry *entry);
-static void remap_cal_data(struct cal_block_data *cal_block, int cal_index);
+static int remap_cal_data(struct cal_block_data *cal_block, int cal_index);
 
 void afe_set_aanc_info(struct aanc_data *q6_aanc_info)
 {
@@ -622,7 +622,12 @@ static void afe_send_custom_topology(void)
 
 	pr_debug("%s: Sending cal_index cal %d\n", __func__, cal_index);
 
-	remap_cal_data(cal_block, cal_index);
+	ret = remap_cal_data(cal_block, cal_index);
+	if (ret) {
+		pr_err("%s: Remap_cal_data failed for cal %d!\n",
+			__func__, cal_index);
+		goto unlock;
+	}
 	ret = afe_send_custom_topology_block(cal_block);
 	if (ret < 0) {
 		pr_err("%s: No cal sent for cal_index %d! ret %d\n",
@@ -1076,7 +1081,7 @@ static int afe_send_port_topology_id(u16 port_id)
 
 }
 
-static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
+static int remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 {
 	int ret = 0;
 
@@ -1100,7 +1105,7 @@ static void remap_cal_data(struct cal_block_data *cal_block, int cal_index)
 			mem_map_cal_handles[cal_index]);
 	}
 done:
-	return;
+	return ret;
 }
 
 static void send_afe_cal_type(int cal_index, int port_id)
@@ -1124,7 +1129,12 @@ static void send_afe_cal_type(int cal_index, int port_id)
 
 	pr_debug("%s: Sending cal_index cal %d\n", __func__, cal_index);
 
-	remap_cal_data(cal_block, cal_index);
+	ret = remap_cal_data(cal_block, cal_index);
+	if (ret) {
+		pr_err("%s: Remap_cal_data failed for cal %d!\n",
+			__func__, cal_index);
+		goto unlock;
+	}
 	ret = afe_send_cal_block(port_id, cal_block);
 	if (ret < 0)
 		pr_debug("%s: No cal sent for cal_index %d, port_id = 0x%x! ret %d\n",
diff --git a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
index 7b92547a..949ff39 100644
--- a/sound/soc/msm/qdsp6v2/q6asm.c
+++ b/sound/soc/msm/qdsp6v2/q6asm.c
@@ -501,7 +501,7 @@ static int q6asm_map_cal_memory(struct cal_block_data *cal_block)
 	return result;
 }
 
-static void remap_cal_data(struct cal_block_data *cal_block)
+static int remap_cal_data(struct cal_block_data *cal_block)
 {
 	int ret = 0;
 
@@ -516,7 +516,7 @@ static void remap_cal_data(struct cal_block_data *cal_block)
 		}
 	}
 done:
-	return;
+	return ret;
 }
 
 static int q6asm_unmap_cal_memory(struct cal_block_data *cal_block)
@@ -603,7 +603,12 @@ int send_asm_custom_topology(struct audio_client *ac)
 
 	pr_debug("%s: Sending cal_index %d\n", __func__, ASM_CUSTOM_TOP_CAL);
 
-	remap_cal_data(cal_block);
+	result = remap_cal_data(cal_block);
+	if (result) {
+		pr_err("%s: Remap_cal_data failed for cal %d!\n",
+			__func__, ASM_CUSTOM_TOP_CAL);
+		goto unlock;
+	}
 	q6asm_add_hdr_custom_topology(ac, &asm_top.hdr, sizeof(asm_top), TRUE);
 	atomic_set(&ac->mem_state, -1);
 	asm_top.hdr.opcode = ASM_CMD_ADD_TOPOLOGIES;
diff --git a/sound/soc/msm/qdsp6v2/q6core.c b/sound/soc/msm/qdsp6v2/q6core.c
index 41ebf637..ed7299ea 100644
--- a/sound/soc/msm/qdsp6v2/q6core.c
+++ b/sound/soc/msm/qdsp6v2/q6core.c
@@ -33,6 +33,12 @@
  */
 #define Q6_READY_TIMEOUT_MS 100
 
+enum {
+	META_CAL,
+	CUST_TOP_CAL,
+	CORE_MAX_CAL
+};
+
 struct q6core_str {
 	struct apr_svc *core_handle_q;
 	wait_queue_head_t bus_bw_req_wait;
@@ -49,7 +55,9 @@ struct q6core_str {
 	} cmd_resp_payload;
 	struct avcs_cmd_rsp_get_low_power_segments_info_t lp_ocm_payload;
 	u32 param;
-	struct cal_type_data *cal_data;
+	struct cal_type_data *cal_data[CORE_MAX_CAL];
+	uint32_t mem_map_cal_handle;
+	int32_t adsp_status;
 };
 
 static struct q6core_str q6core_lcl;
@@ -94,6 +102,32 @@ static int32_t aprv2_core_fn_q(struct apr_client_data *data, void *priv)
 			pr_info("%s: Cmd = AVCS_CMD_GET_LOW_POWER_SEGMENTS_INFO status[0x%x]\n",
 				__func__, payload1[1]);
 			break;
+		case AVCS_CMD_SHARED_MEM_UNMAP_REGIONS:
+			pr_debug("%s: Cmd = AVCS_CMD_SHARED_MEM_UNMAP_REGIONS status[0x%x]\n",
+				__func__, payload1[1]);
+			q6core_lcl.bus_bw_resp_received = 1;
+			wake_up(&q6core_lcl.bus_bw_req_wait);
+			break;
+		case AVCS_CMD_SHARED_MEM_MAP_REGIONS:
+			pr_debug("%s: Cmd = AVCS_CMD_SHARED_MEM_MAP_REGIONS status[0x%x]\n",
+				__func__, payload1[1]);
+			q6core_lcl.bus_bw_resp_received = 1;
+			wake_up(&q6core_lcl.bus_bw_req_wait);
+			break;
+		case AVCS_CMD_REGISTER_TOPOLOGIES:
+			pr_debug("%s: Cmd = AVCS_CMD_REGISTER_TOPOLOGIES status[0x%x]\n",
+				__func__, payload1[1]);
+			/* -ADSP status to match Linux error standard */
+			q6core_lcl.adsp_status = -payload1[1];
+			q6core_lcl.bus_bw_resp_received = 1;
+			wake_up(&q6core_lcl.bus_bw_req_wait);
+			break;
+		case AVCS_CMD_DEREGISTER_TOPOLOGIES:
+			pr_debug("%s: Cmd = AVCS_CMD_DEREGISTER_TOPOLOGIES status[0x%x]\n",
+				__func__, payload1[1]);
+			q6core_lcl.bus_bw_resp_received = 1;
+			wake_up(&q6core_lcl.bus_bw_req_wait);
+			break;
 		default:
 			pr_err("%s: Invalid cmd rsp[0x%x][0x%x] opcode %d\n",
 					__func__,
@@ -136,7 +170,14 @@ static int32_t aprv2_core_fn_q(struct apr_client_data *data, void *priv)
 		q6core_lcl.core_handle_q = NULL;
 		break;
 	}
-
+	case AVCS_CMDRSP_SHARED_MEM_MAP_REGIONS:
+		payload1 = data->payload;
+		pr_debug("%s: AVCS_CMDRSP_SHARED_MEM_MAP_REGIONS handle %d\n",
+			__func__, payload1[0]);
+		q6core_lcl.mem_map_cal_handle = payload1[0];
+		q6core_lcl.bus_bw_resp_received = 1;
+		wake_up(&q6core_lcl.bus_bw_req_wait);
+		break;
 	case AVCS_CMDRSP_ADSP_EVENT_GET_STATE:
 		payload1 = data->payload;
 		q6core_lcl.param = payload1[0];
@@ -202,16 +243,18 @@ int32_t core_set_license(uint32_t key, uint32_t module_id)
 	pr_debug("%s: key:0x%x, id:0x%x\n", __func__, key, module_id);
 
 	mutex_lock(&(q6core_lcl.cmd_lock));
-	if (q6core_lcl.cal_data == NULL) {
+	if (q6core_lcl.cal_data[META_CAL] == NULL) {
 		pr_err("%s: cal_data not initialized yet!!\n", __func__);
 		rc = -EINVAL;
 		goto cmd_unlock;
 	}
 
-	mutex_lock(&((q6core_lcl.cal_data)->lock));
-	cal_block = cal_utils_get_only_cal_block(q6core_lcl.cal_data);
-	if (cal_block == NULL || cal_block->cal_data.kvaddr == NULL ||
-					cal_block->cal_data.size <= 0) {
+	mutex_lock(&((q6core_lcl.cal_data[META_CAL])->lock));
+	cal_block =
+		cal_utils_get_only_cal_block(q6core_lcl.cal_data[META_CAL]);
+	if (cal_block == NULL ||
+		cal_block->cal_data.kvaddr == NULL ||
+		cal_block->cal_data.size <= 0) {
 		pr_err("%s: Invalid cal block to send", __func__);
 		rc = -EINVAL;
 		goto cal_data_unlock;
@@ -233,7 +276,7 @@ int32_t core_set_license(uint32_t key, uint32_t module_id)
 	}
 
 	packet_size = sizeof(struct avcs_cmd_set_license) +
-						cal_block->cal_data.size;
+					cal_block->cal_data.size;
 	/*round up total packet_size to next 4 byte boundary*/
 	packet_size = ((packet_size + 0x3)>>2)<<2;
 
@@ -263,7 +306,8 @@ int32_t core_set_license(uint32_t key, uint32_t module_id)
 	cmd_setl->overwrite = 1;
 	cmd_setl->size = cal_block->cal_data.size;
 	memcpy((uint8_t *)cmd_setl + sizeof(struct avcs_cmd_set_license),
-			cal_block->cal_data.kvaddr, cal_block->cal_data.size);
+		cal_block->cal_data.kvaddr,
+		cal_block->cal_data.size);
 	pr_info("%s: Set license opcode=0x%x ,key=0x%x, id =0x%x, size = %d\n",
 			__func__, cmd_setl->hdr.opcode,
 			metainfo->nKey, cmd_setl->id, cmd_setl->size);
@@ -275,7 +319,7 @@ int32_t core_set_license(uint32_t key, uint32_t module_id)
 fail_cmd:
 	kfree(cmd_setl);
 cal_data_unlock:
-	mutex_unlock(&((q6core_lcl.cal_data)->lock));
+	mutex_unlock(&((q6core_lcl.cal_data[META_CAL])->lock));
 cmd_unlock:
 	mutex_unlock(&(q6core_lcl.cmd_lock));
 
@@ -568,36 +612,366 @@ bool q6core_is_adsp_ready(void)
 	return ret;
 }
 
+
+static int q6core_map_memory_regions(phys_addr_t *buf_add, uint32_t mempool_id,
+			uint32_t *bufsz, uint32_t bufcnt, uint32_t *map_handle)
+{
+	struct avs_cmd_shared_mem_map_regions *mmap_regions = NULL;
+	struct avs_shared_map_region_payload *mregions = NULL;
+	void *mmap_region_cmd = NULL;
+	void *payload = NULL;
+	int ret = 0;
+	int i = 0;
+	int cmd_size = 0;
+
+	cmd_size = sizeof(struct avs_cmd_shared_mem_map_regions)
+			+ sizeof(struct avs_shared_map_region_payload)
+			* bufcnt;
+
+	mmap_region_cmd = kzalloc(cmd_size, GFP_KERNEL);
+	if (mmap_region_cmd == NULL)
+		return -ENOMEM;
+
+	mmap_regions = (struct avs_cmd_shared_mem_map_regions *)mmap_region_cmd;
+	mmap_regions->hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+						APR_HDR_LEN(APR_HDR_SIZE),
+								APR_PKT_VER);
+	mmap_regions->hdr.pkt_size = cmd_size;
+	mmap_regions->hdr.src_port = 0;
+	mmap_regions->hdr.dest_port = 0;
+	mmap_regions->hdr.token = 0;
+	mmap_regions->hdr.opcode = AVCS_CMD_SHARED_MEM_MAP_REGIONS;
+	mmap_regions->mem_pool_id = ADSP_MEMORY_MAP_SHMEM8_4K_POOL & 0x00ff;
+	mmap_regions->num_regions = bufcnt & 0x00ff;
+	mmap_regions->property_flag = 0x00;
+
+	payload = ((u8 *) mmap_region_cmd +
+				sizeof(struct avs_cmd_shared_mem_map_regions));
+	mregions = (struct avs_shared_map_region_payload *)payload;
+
+	for (i = 0; i < bufcnt; i++) {
+		mregions->shm_addr_lsw = lower_32_bits(buf_add[i]);
+		mregions->shm_addr_msw = upper_32_bits(buf_add[i]);
+		mregions->mem_size_bytes = bufsz[i];
+		++mregions;
+	}
+
+	pr_debug("%s: sending memory map, addr %pa, size %d, bufcnt = %d\n",
+		__func__, buf_add, bufsz[0], mmap_regions->num_regions);
+
+	*map_handle = 0;
+	q6core_lcl.bus_bw_resp_received = 0;
+	ret = apr_send_pkt(q6core_lcl.core_handle_q, (uint32_t *)
+		mmap_regions);
+	if (ret < 0) {
+		pr_err("%s: mmap regions failed %d\n",
+			__func__, ret);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	ret = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("%s: timeout. waited for memory map\n", __func__);
+		ret = -ETIME;
+		goto done;
+	}
+
+	*map_handle = q6core_lcl.mem_map_cal_handle;
+done:
+	kfree(mmap_region_cmd);
+	return ret;
+}
+
+static int q6core_memory_unmap_regions(uint32_t mem_map_handle)
+{
+	struct avs_cmd_shared_mem_unmap_regions unmap_regions;
+	int ret = 0;
+
+	memset(&unmap_regions, 0, sizeof(unmap_regions));
+	unmap_regions.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+		APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	unmap_regions.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE,
+		sizeof(unmap_regions));
+	unmap_regions.hdr.src_svc = APR_SVC_ADSP_CORE;
+	unmap_regions.hdr.src_domain = APR_DOMAIN_APPS;
+	unmap_regions.hdr.src_port = 0;
+	unmap_regions.hdr.dest_svc = APR_SVC_ADSP_CORE;
+	unmap_regions.hdr.dest_domain = APR_DOMAIN_ADSP;
+	unmap_regions.hdr.dest_port = 0;
+	unmap_regions.hdr.token = 0;
+	unmap_regions.hdr.opcode = AVCS_CMD_SHARED_MEM_UNMAP_REGIONS;
+	unmap_regions.mem_map_handle = mem_map_handle;
+
+	q6core_lcl.bus_bw_resp_received = 0;
+
+	pr_debug("%s: unmap regions map handle %d\n",
+		__func__, mem_map_handle);
+
+	ret = apr_send_pkt(q6core_lcl.core_handle_q, (uint32_t *)
+		&unmap_regions);
+	if (ret < 0) {
+		pr_err("%s: unmap regions failed %d\n",
+			__func__, ret);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	ret = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("%s: timeout. waited for memory_unmap\n",
+		       __func__);
+		ret = -ETIME;
+		goto done;
+	}
+done:
+	return ret;
+}
+
+static int q6core_dereg_all_custom_topologies(void)
+{
+	int ret = 0;
+	struct avcs_cmd_deregister_topologies dereg_top;
+
+	memset(&dereg_top, 0, sizeof(dereg_top));
+	dereg_top.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+		APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	dereg_top.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE, sizeof(dereg_top));
+	dereg_top.hdr.src_svc = APR_SVC_ADSP_CORE;
+	dereg_top.hdr.src_domain = APR_DOMAIN_APPS;
+	dereg_top.hdr.src_port = 0;
+	dereg_top.hdr.dest_svc = APR_SVC_ADSP_CORE;
+	dereg_top.hdr.dest_domain = APR_DOMAIN_ADSP;
+	dereg_top.hdr.dest_port = 0;
+	dereg_top.hdr.token = 0;
+	dereg_top.hdr.opcode = AVCS_CMD_DEREGISTER_TOPOLOGIES;
+	dereg_top.payload_addr_lsw = 0;
+	dereg_top.payload_addr_msw = 0;
+	dereg_top.mem_map_handle = 0;
+	dereg_top.payload_size = 0;
+	dereg_top.mode = AVCS_MODE_DEREGISTER_ALL_CUSTOM_TOPOLOGIES;
+
+	q6core_lcl.bus_bw_resp_received = 0;
+
+	pr_debug("%s: Deregister topologies mode %d\n",
+		__func__, dereg_top.mode);
+
+	ret = apr_send_pkt(q6core_lcl.core_handle_q, (uint32_t *) &dereg_top);
+	if (ret < 0) {
+		pr_err("%s: Deregister topologies failed %d\n",
+			__func__, ret);
+		goto done;
+	}
+
+	ret = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("%s: wait_event timeout for Deregister topologies\n",
+			__func__);
+		goto done;
+	}
+done:
+	return ret;
+}
+
+static int q6core_send_custom_topologies(void)
+{
+	int ret = 0;
+	int ret2 = 0;
+	struct cal_block_data *cal_block = NULL;
+	struct avcs_cmd_register_topologies reg_top;
+
+	memset(&reg_top, 0, sizeof(reg_top));
+	mutex_lock(&q6core_lcl.cal_data[CUST_TOP_CAL]->lock);
+	mutex_lock(&q6core_lcl.cmd_lock);
+
+	cal_block = cal_utils_get_only_cal_block(
+		q6core_lcl.cal_data[CUST_TOP_CAL]);
+	if (cal_block == NULL) {
+		pr_debug("%s: cal block is NULL!\n", __func__);
+		goto unlock;
+	}
+	if (cal_block->cal_data.size <= 0) {
+		pr_debug("%s: cal size is %zd not sending\n",
+			__func__, cal_block->cal_data.size);
+		goto unlock;
+	}
+
+	if (!q6core_is_adsp_ready()) {
+		pr_err("%s: ADSP is not ready!\n", __func__);
+		ret  = -ENODEV;
+		goto unlock;
+	}
+
+	q6core_dereg_all_custom_topologies();
+
+	ret = q6core_map_memory_regions(&cal_block->cal_data.paddr, 0,
+		(uint32_t *)&cal_block->map_data.map_size, 1,
+		&cal_block->map_data.q6map_handle);
+	if (!ret)  {
+		pr_err("%s: q6core_map_memory_regions failed\n", __func__);
+		goto unlock;
+	}
+
+	reg_top.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
+		APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
+	reg_top.hdr.pkt_size = APR_PKT_SIZE(APR_HDR_SIZE, sizeof(reg_top));
+	reg_top.hdr.src_svc = APR_SVC_ADSP_CORE;
+	reg_top.hdr.src_domain = APR_DOMAIN_APPS;
+	reg_top.hdr.src_port = 0;
+	reg_top.hdr.dest_svc = APR_SVC_ADSP_CORE;
+	reg_top.hdr.dest_domain = APR_DOMAIN_ADSP;
+	reg_top.hdr.dest_port = 0;
+	reg_top.hdr.token = 0;
+	reg_top.hdr.opcode = AVCS_CMD_REGISTER_TOPOLOGIES;
+	reg_top.payload_addr_lsw =
+		lower_32_bits(cal_block->cal_data.paddr);
+	reg_top.payload_addr_msw =
+		upper_32_bits(cal_block->cal_data.paddr);
+	reg_top.mem_map_handle = cal_block->map_data.q6map_handle;
+	reg_top.payload_size = cal_block->cal_data.size;
+
+	q6core_lcl.adsp_status = 0;
+	q6core_lcl.bus_bw_resp_received = 0;
+
+	pr_debug("%s: Register topologies addr %pa, size %zd, map handle %d\n",
+		__func__, &cal_block->cal_data.paddr, cal_block->cal_data.size,
+		cal_block->map_data.q6map_handle);
+
+	ret = apr_send_pkt(q6core_lcl.core_handle_q, (uint32_t *) &reg_top);
+	if (ret < 0) {
+		pr_err("%s: Register topologies failed %d\n",
+			__func__, ret);
+		goto unmap;
+	}
+
+	ret = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
+				(q6core_lcl.bus_bw_resp_received == 1),
+				msecs_to_jiffies(TIMEOUT_MS));
+	if (!ret) {
+		pr_err("%s: wait_event timeout for Register topologies\n",
+			__func__);
+		goto unmap;
+	}
+
+	if (q6core_lcl.adsp_status < 0)
+		ret = q6core_lcl.adsp_status;
+unmap:
+	ret2 = q6core_memory_unmap_regions(cal_block->map_data.q6map_handle);
+	if (!ret2)  {
+		pr_err("%s: q6core_memory_unmap_regions failed for map handle %d\n",
+			__func__, cal_block->map_data.q6map_handle);
+		ret = ret2;
+		goto unlock;
+	}
+
+unlock:
+	mutex_unlock(&q6core_lcl.cmd_lock);
+	mutex_unlock(&q6core_lcl.cal_data[CUST_TOP_CAL]->lock);
+
+	return ret;
+}
+
+static int get_cal_type_index(int32_t cal_type)
+{
+	int ret = -EINVAL;
+
+	switch (cal_type) {
+	case AUDIO_CORE_METAINFO_CAL_TYPE:
+		ret = META_CAL;
+		break;
+	case CORE_CUSTOM_TOPOLOGIES_CAL_TYPE:
+		ret = CUST_TOP_CAL;
+		break;
+	default:
+		pr_err("%s: invalid cal type %d!\n", __func__, cal_type);
+	}
+	return ret;
+}
+
 static int q6core_alloc_cal(int32_t cal_type,
 			    size_t data_size, void *data)
 {
-	int ret = cal_utils_alloc_cal(data_size, data,
-				      q6core_lcl.cal_data, 0, NULL);
-	if (ret < 0)
+	int ret = 0;
+	int cal_index;
+
+	cal_index = get_cal_type_index(cal_type);
+	if (cal_index < 0) {
+		pr_err("%s: could not get cal index %d!\n",
+			__func__, cal_index);
+		ret = -EINVAL;
+		goto done;
+	}
+
+
+	ret = cal_utils_alloc_cal(data_size, data,
+		q6core_lcl.cal_data[cal_index], 0, NULL);
+	if (ret < 0) {
 		pr_err("%s: cal_utils_alloc_block failed, ret = %d, cal type = %d!\n",
 			__func__, ret, cal_type);
+		goto done;
+	}
+done:
 	return ret;
 }
 
 static int q6core_dealloc_cal(int32_t cal_type,
 			      size_t data_size, void *data)
 {
-	int ret = cal_utils_dealloc_cal(data_size, data,
-					q6core_lcl.cal_data);
-	if (ret < 0)
+	int ret = 0;
+	int cal_index;
+
+	cal_index = get_cal_type_index(cal_type);
+	if (cal_index < 0) {
+		pr_err("%s: could not get cal index %d!\n",
+			__func__, cal_index);
+		ret = -EINVAL;
+		goto done;
+	}
+
+
+	ret = cal_utils_dealloc_cal(data_size, data,
+					q6core_lcl.cal_data[cal_index]);
+	if (ret < 0) {
 		pr_err("%s: cal_utils_dealloc_block failed, ret = %d, cal type = %d!\n",
 			__func__, ret, cal_type);
+		goto done;
+	}
+done:
 	return ret;
 }
 
 static int q6core_set_cal(int32_t cal_type,
 	size_t data_size, void *data)
 {
-	int ret = cal_utils_set_cal(data_size, data,
-				    q6core_lcl.cal_data, 0, NULL);
-	if (ret < 0)
+	int ret = 0;
+	int cal_index;
+
+	cal_index = get_cal_type_index(cal_type);
+	if (cal_index < 0) {
+		pr_err("%s: could not get cal index %d!\n",
+			__func__, cal_index);
+		ret = -EINVAL;
+		goto done;
+	}
+
+
+	ret = cal_utils_set_cal(data_size, data,
+				    q6core_lcl.cal_data[cal_index], 0, NULL);
+	if (ret < 0) {
 		pr_err("%s: cal_utils_set_cal failed, ret = %d, cal type = %d!\n",
 		__func__, ret, cal_type);
+		goto done;
+	}
+
+	if (cal_index == CUST_TOP_CAL)
+		ret = q6core_send_custom_topologies();
+done:
 	return ret;
 }
 
@@ -605,23 +979,29 @@ static void q6core_delete_cal_data(void)
 {
 	pr_debug("%s:\n", __func__);
 
-	cal_utils_destroy_cal_types(1, &q6core_lcl.cal_data);
+	cal_utils_destroy_cal_types(CORE_MAX_CAL, q6core_lcl.cal_data);
+	return;
 }
 
 
 static int q6core_init_cal_data(void)
 {
 	int ret = 0;
-	struct cal_type_info    cal_type_info = {
-		{AUDIO_CORE_METAINFO_CAL_TYPE,
+	struct cal_type_info    cal_type_info[] = {
+		{{AUDIO_CORE_METAINFO_CAL_TYPE,
+		{q6core_alloc_cal, q6core_dealloc_cal, NULL,
+		q6core_set_cal, NULL, NULL} },
+		{NULL, NULL, cal_utils_match_buf_num} },
+
+		{{CORE_CUSTOM_TOPOLOGIES_CAL_TYPE,
 		{q6core_alloc_cal, q6core_dealloc_cal, NULL,
 		q6core_set_cal, NULL, NULL} },
-		{NULL, NULL, cal_utils_match_buf_num}
+		{NULL, NULL, cal_utils_match_buf_num} }
 	};
 	pr_debug("%s:\n", __func__);
 
-	ret = cal_utils_create_cal_types(1, &q6core_lcl.cal_data,
-		&cal_type_info);
+	ret = cal_utils_create_cal_types(CORE_MAX_CAL,
+		q6core_lcl.cal_data, cal_type_info);
 	if (ret < 0) {
 		pr_err("%s: could not create cal type!\n",
 			__func__);
@@ -644,6 +1024,8 @@ static int __init core_init(void)
 	init_waitqueue_head(&q6core_lcl.cmd_req_wait);
 	q6core_lcl.cmd_resp_received_flag = FLAG_NONE;
 	mutex_init(&q6core_lcl.cmd_lock);
+	q6core_lcl.mem_map_cal_handle = 0;
+	q6core_lcl.adsp_status = 0;
 
 	q6core_init_cal_data();
 	return 0;
diff --git a/sound/soc/msm/qdsp6v2/rtac.c b/sound/soc/msm/qdsp6v2/rtac.c
index feed251..f6d781b 100644
--- a/sound/soc/msm/qdsp6v2/rtac.c
+++ b/sound/soc/msm/qdsp6v2/rtac.c
@@ -34,7 +34,6 @@
 
 /* Max size of payload (buf size - apr header) */
 #define MAX_PAYLOAD_SIZE		4076
-#define RTAC_MAX_ACTIVE_DEVICES		4
 #define RTAC_MAX_ACTIVE_VOICE_COMBOS	2
 #define RTAC_MAX_ACTIVE_POPP		8
 #define RTAC_BUF_SIZE			163840
@@ -71,28 +70,7 @@ static struct rtac_apr_data	rtac_asm_apr_data[SESSION_MAX+1];
 static struct rtac_apr_data	rtac_afe_apr_data;
 static struct rtac_apr_data	rtac_voice_apr_data[RTAC_VOICE_MODES];
 
-
 /* ADM info & APR */
-struct rtac_popp_data {
-	uint32_t	popp;
-	uint32_t	popp_topology;
-};
-
-struct rtac_adm_data {
-	uint32_t		topology_id;
-	uint32_t		afe_port;
-	uint32_t		copp;
-	uint32_t		num_of_popp;
-	uint32_t		app_type;
-	uint32_t		acdb_dev_id;
-	struct rtac_popp_data	popp[RTAC_MAX_ACTIVE_POPP];
-};
-
-struct rtac_adm {
-	uint32_t			num_of_dev;
-	struct rtac_adm_data		device[RTAC_MAX_ACTIVE_DEVICES];
-};
-
 static struct rtac_adm		rtac_adm_data;
 static u32			*rtac_adm_buffer;
 
@@ -1590,6 +1568,12 @@ u32 send_voice_apr(u32 mode, void *buf, u32 opcode)
 	return result;
 }
 
+void get_rtac_adm_data(struct rtac_adm *adm_data)
+{
+	mutex_lock(&rtac_adm_mutex);
+	memcpy(adm_data, &rtac_adm_data, sizeof(struct rtac_adm));
+	mutex_unlock(&rtac_adm_mutex);
+}
 
 
 static long rtac_ioctl_shared(struct file *f,
@@ -1604,25 +1588,31 @@ static long rtac_ioctl_shared(struct file *f,
 
 	switch (cmd) {
 	case AUDIO_GET_RTAC_ADM_INFO: {
+		mutex_lock(&rtac_adm_mutex);
 		if (copy_to_user((void *)arg, &rtac_adm_data,
 						sizeof(rtac_adm_data))) {
 			pr_err("%s: copy_to_user failed for AUDIO_GET_RTAC_ADM_INFO\n",
 					__func__);
+			mutex_unlock(&rtac_adm_mutex);
 			return -EFAULT;
 		} else {
 			result = sizeof(rtac_adm_data);
 		}
+		mutex_unlock(&rtac_adm_mutex);
 		break;
 	}
 	case AUDIO_GET_RTAC_VOICE_INFO: {
+		mutex_lock(&rtac_voice_mutex);
 		if (copy_to_user((void *)arg, &rtac_voice_data,
 						sizeof(rtac_voice_data))) {
 			pr_err("%s: copy_to_user failed for AUDIO_GET_RTAC_VOICE_INFO\n",
 					__func__);
+			mutex_unlock(&rtac_voice_mutex);
 			return -EFAULT;
 		} else {
 			result = sizeof(rtac_voice_data);
 		}
+		mutex_unlock(&rtac_voice_mutex);
 		break;
 	}
 
